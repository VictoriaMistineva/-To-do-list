import { createNanoEvents } from './nanoevents';
const AudioContext = window.AudioContext || window.webkitAudioContext;
let context;
let processor;
const downsampleBuffer = (buffer, sampleRate, outSampleRate) => {
    if (outSampleRate > sampleRate) {
        throw new Error('downsampling rate show be smaller than original sample rate');
    }
    const sampleRateRatio = sampleRate / outSampleRate;
    const newLength = Math.round(buffer.length / sampleRateRatio);
    const result = new Int16Array(newLength);
    let empty = true;
    let offsetResult = 0;
    let offsetBuffer = 0;
    while (offsetResult < result.length) {
        const nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);
        let accum = 0;
        let count = 0;
        for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {
            accum += buffer[i];
            count++;
        }
        if (empty && accum > 0) {
            empty = false;
        }
        result[offsetResult] = Math.min(1, accum / count) * 0x7fff;
        offsetResult++;
        offsetBuffer = nextOffsetBuffer;
    }
    return {
        buffer: result.buffer,
        empty,
    };
};
const TARGET_SAMPLE_RATE = 16000;
export const createAudioRecorder = (stream) => {
    const { on, emit } = createNanoEvents();
    let state = 'inactive';
    let input;
    const start = () => {
        if (state !== 'inactive') {
            throw new Error("Can't start not inactive recorder");
        }
        state = 'recording';
        if (!context) {
            context = new AudioContext({
                sampleRate: 16000,
            });
        }
        input = context.createMediaStreamSource(stream);
        if (!processor) {
            processor = context.createScriptProcessor(2048, 1, 1);
        }
        const listener = (e) => {
            const buffer = e.inputBuffer.getChannelData(0);
            const data = downsampleBuffer(buffer, context.sampleRate, TARGET_SAMPLE_RATE);
            const last = state === 'inactive';
            emit('data', data.buffer, last);
            if (last) {
                processor.removeEventListener('audioprocess', listener);
            }
        };
        processor.addEventListener('audioprocess', listener);
        input.connect(processor);
        processor.connect(context.destination);
    };
    const stop = () => {
        if (state === 'inactive') {
            throw new Error("Can't stop inactive recorder");
        }
        state = 'inactive';
        stream.getTracks().forEach((track) => {
            track.stop();
        });
        input.disconnect();
    };
    return {
        get state() {
            return state;
        },
        start,
        stop,
        on,
        sampleRate: TARGET_SAMPLE_RATE,
    };
};
