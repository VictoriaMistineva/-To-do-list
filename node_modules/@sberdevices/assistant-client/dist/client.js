var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { Message, Settings, SystemMessage, Device, Text, Voice, LegacyDevice, InitialSettings, } from './proto';
import { PacketWrapperFromServer } from './asr';
import { createNanoEvents } from './nanoevents';
import { createVoicePlayer } from './createVoicePlayer';
export const MESSAGE_NAMES = {
    ANSWER_TO_USER: 'ANSWER_TO_USER',
    STT: 'STT',
};
export const appendHeader = (buffer) => {
    // Добавляем 4 байта в начало с длинной сообщения
    const arrayBuffer = new ArrayBuffer(4);
    const dataView = new DataView(arrayBuffer, 0);
    dataView.setInt32(0, buffer.length, true);
    const uint8Array = new Uint8Array(4 + buffer.length);
    uint8Array.set(new Uint8Array(arrayBuffer));
    uint8Array.set(buffer, 4);
    return uint8Array;
};
const compileBasePayload = ({ userId, token, userChannel, version, messageName, vpsToken, }) => {
    if (version < 3) {
        return {
            userId,
            token,
            userChannel,
            messageName,
            vpsToken,
            version,
        };
    }
    return {
        token,
        messageName,
        version,
    };
};
export const createClient = (clientParams, logger, voiceSettings) => {
    const { url, userId, token, userChannel, locale, device, settings, legacyDevice, version, messageName, vpsToken, } = clientParams;
    const basePayload = compileBasePayload({ userId, token, messageName, vpsToken, userChannel, version });
    let status = 'connecting';
    const messageQueue = [];
    const { on, emit, once } = createNanoEvents();
    const pendingMessages = new Map();
    const commitedMessages = new Map();
    let currentSettings = { device, legacyDevice, settings, locale };
    let currentMessageId = Date.now();
    let retries = 0;
    let destroyed = false;
    let ws;
    let timeOut;
    let clearRetryTimer;
    const voicePlayer = createVoicePlayer(voiceSettings);
    const getMessageId = () => {
        return currentMessageId++;
    };
    const waitForAnswerToUser = (messageId) => {
        return new Promise((resolve) => {
            const off = on('systemMessage', (systemMessageData, originalMessage) => {
                if (originalMessage.messageId === messageId &&
                    originalMessage.messageName === MESSAGE_NAMES.ANSWER_TO_USER) {
                    off();
                    resolve(systemMessageData);
                }
            });
        });
    };
    const send = (_a) => {
        var { payload, messageId } = _a, other = __rest(_a, ["payload", "messageId"]);
        const message = Message.create(Object.assign(Object.assign(Object.assign(Object.assign({ messageName: '' }, basePayload), payload), { messageId }), other));
        const buffer = Message.encode(message).finish();
        const bufferWithHeader = appendHeader(buffer);
        logger === null || logger === void 0 ? void 0 : logger.logOutcoming(message);
        emit('outcoming', message);
        if (status === 'ready') {
            ws.send(bufferWithHeader);
        }
        else {
            messageQueue.push(bufferWithHeader);
        }
    };
    const sendDevice = (data, last = true, messageId = getMessageId()) => {
        currentSettings = Object.assign(Object.assign({}, currentSettings), { device: data });
        return send({
            payload: {
                device: Device.create(data),
                last: last ? 1 : -1,
            },
            messageId,
        });
    };
    const sendInitialSettings = (data, last = true, messageId = getMessageId()) => {
        if (data.device && data.settings) {
            currentSettings = Object.assign(Object.assign({}, currentSettings), { device: data.device, settings: data.settings, locale: data.locale || undefined });
        }
        return send({
            payload: {
                initialSettings: InitialSettings.create(data),
                last: last ? 1 : -1,
            },
            messageId,
        });
    };
    const sendLegacyDevice = (data, last = true, messageId = getMessageId()) => {
        currentSettings = Object.assign(Object.assign({}, currentSettings), { legacyDevice: data });
        return send({
            payload: {
                legacyDevice: LegacyDevice.create(data),
                last: last ? 1 : -1,
            },
            messageId,
        });
    };
    const sendSettings = (data, last = true, messageId = getMessageId()) => {
        currentSettings = Object.assign(Object.assign({}, currentSettings), { settings: data });
        return send({
            payload: {
                settings: Settings.create(data),
                last: last ? 1 : -1,
            },
            messageId,
        });
    };
    const sendText = (data, params = {}, type = '', messageId = getMessageId()) => {
        var _a;
        const text = type ? { data, type } : { data };
        send(Object.assign({ payload: {
                text: Text.create(text),
                last: (_a = params.last) !== null && _a !== void 0 ? _a : 1,
            }, messageId }, params));
        return waitForAnswerToUser(messageId);
    };
    const createVoiceStream = (meta, messageId = getMessageId()) => {
        let hasFinished = false;
        const voiceStreamEM = createNanoEvents();
        const write = (data, last = false) => {
            if (!hasFinished) {
                send({
                    payload: {
                        voice: Voice.create({
                            data: new Uint8Array(data),
                        }),
                        last: -1,
                    },
                    messageId,
                });
                hasFinished = last;
            }
        };
        meta &&
            send({
                payload: { systemMessage: SystemMessage.create({ data: JSON.stringify(meta) }), last: -1 },
                messageId,
            });
        on('message', (message) => {
            var _a, _b;
            if (message.status && message.status.code != null && message.status.code < 0) {
                hasFinished = true;
            }
            if (message.messageId === messageId && message.messageName === MESSAGE_NAMES.STT) {
                if (message.last === 1) {
                    hasFinished = true;
                    send({ payload: { voice: Voice.create(), last: 1 }, messageId });
                }
                if (message.text) {
                    voiceStreamEM.emit('stt', message.text.data || '', message.last === 1);
                }
                if ((_a = message.bytes) === null || _a === void 0 ? void 0 : _a.data) {
                    const { decoderResultField } = PacketWrapperFromServer.decode(message.bytes.data);
                    if (decoderResultField && ((_b = decoderResultField.hypothesis) === null || _b === void 0 ? void 0 : _b.length)) {
                        voiceStreamEM.emit('stt', decoderResultField.hypothesis[0].normalizedText || '', !!decoderResultField.isFinal);
                    }
                }
            }
        });
        return {
            write,
            answerToUser: waitForAnswerToUser(messageId),
            on: voiceStreamEM.on,
        };
    };
    const sendSystemMessage = ({ data, messageName = '' }, last = true, messageId = getMessageId()) => {
        send({
            payload: {
                systemMessage: SystemMessage.create({
                    data: JSON.stringify(data),
                }),
                messageName,
                last: last ? 1 : -1,
            },
            messageId,
        });
        return waitForAnswerToUser(messageId);
    };
    const updateDefauls = (obj) => {
        Object.assign(basePayload, obj);
    };
    const destroy = () => {
        destroyed = true;
        ws && ws.close();
        clearTimeout(timeOut);
        timeOut = undefined;
    };
    const startWebSocket = () => {
        status = 'connecting';
        setTimeout(() => {
            emit('connecting');
        }, 0);
        ws = new WebSocket(url);
        ws.binaryType = 'arraybuffer';
        ws.addEventListener('open', () => {
            status = 'ready';
            clearRetryTimer = window.setTimeout(() => {
                retries = 0;
            }, 500);
            if (ws.readyState === 1) {
                if (version < 3) {
                    if (version === 1 && currentSettings.legacyDevice) {
                        sendLegacyDevice(currentSettings.legacyDevice);
                    }
                    else if (version === 2 && currentSettings.device) {
                        sendDevice(currentSettings.device);
                    }
                    sendSettings(currentSettings.settings);
                }
                else {
                    sendInitialSettings({
                        userId,
                        userChannel,
                        device: currentSettings.device,
                        settings: currentSettings.settings,
                        locale: version > 3 ? currentSettings.locale : undefined,
                    });
                }
                logger === null || logger === void 0 ? void 0 : logger.logInit(Object.assign(Object.assign({}, clientParams), currentSettings));
                while (messageQueue.length > 0) {
                    const message = messageQueue.shift();
                    ws.send(message);
                }
            }
            emit('ready');
        });
        ws.addEventListener('close', () => {
            status = 'closed';
            clearTimeout(clearRetryTimer);
            if (!ws || (ws.readyState === 3 && !destroyed)) {
                if (timeOut) {
                    clearTimeout(timeOut);
                }
                timeOut = window.setTimeout(() => {
                    startWebSocket();
                    retries++;
                }, 300 * retries);
            }
            emit('close');
        });
        ws.addEventListener('message', (e) => {
            var _a, _b, _c;
            const message = Message.decode(new Uint8Array(e.data).slice(4));
            const messages = pendingMessages.get(message.messageId) || [];
            logger === null || logger === void 0 ? void 0 : logger.logIncoming(message);
            messages.push(message);
            if ((_b = (_a = message.voice) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.length)
                voicePlayer.streamToDataToPlayer(message.voice.data);
            if (message.last === 1) {
                voicePlayer.setFinish();
                commitedMessages.set(message.messageId, messages);
                pendingMessages.delete(message.messageId);
            }
            else {
                pendingMessages.set(message.messageId, messages);
            }
            emit('message', message);
            if ((_c = message.systemMessage) === null || _c === void 0 ? void 0 : _c.data) {
                const systemMessage = JSON.parse(message.systemMessage.data);
                emit('systemMessage', systemMessage, message);
            }
        });
    };
    startWebSocket();
    const batch = (cb) => {
        const batchingMessageId = getMessageId();
        let lastMessageSent = false;
        const checkLastMessageStatus = (last) => {
            if (lastMessageSent) {
                if (last) {
                    throw new Error("Can't send two last items in batch");
                }
                else {
                    throw new Error("Can't send messages in batch after last message have been sent");
                }
            }
            else if (last) {
                lastMessageSent = true;
            }
        };
        const threeParamsMethods = Object.entries({
            sendDevice,
            sendSettings,
            sendInitialSettings,
            sendLegacyDevice,
        }).reduce((acc, curr) => {
            const key = curr[0];
            acc[key] = (...params) => {
                checkLastMessageStatus(params[1]);
                return curr[1](params[0], params[1], batchingMessageId);
            };
            return acc;
        }, {});
        const upgradedSend = (params) => {
            checkLastMessageStatus(params.payload.last === 1);
            return send(Object.assign(Object.assign({}, params), { messageId: batchingMessageId }));
        };
        const upgradedSendText = (...[data, params, type]) => {
            checkLastMessageStatus((params === null || params === void 0 ? void 0 : params.last) === 1);
            return sendText(data, params, type, batchingMessageId);
        };
        const upgradedCreateVoiceStream = (meta) => {
            const stream = createVoiceStream(meta, batchingMessageId);
            return Object.assign(Object.assign({}, stream), { write: (data, last) => {
                    checkLastMessageStatus(last);
                    return stream.write(data, last);
                } });
        };
        const upgradedSendSystemMessage = (data, last) => {
            checkLastMessageStatus(last);
            return sendSystemMessage(data, last, batchingMessageId);
        };
        return cb(Object.assign(Object.assign({}, threeParamsMethods), { send: upgradedSend, sendText: upgradedSendText, createVoiceStream: upgradedCreateVoiceStream, sendSystemMessage: upgradedSendSystemMessage }));
    };
    return {
        once,
        send,
        sendDevice,
        sendLegacyDevice,
        sendSettings,
        sendText,
        createVoiceStream,
        sendSystemMessage,
        on,
        updateDefauls,
        destroy,
        batch,
        get currentMessageId() {
            return currentMessageId;
        },
    };
};
