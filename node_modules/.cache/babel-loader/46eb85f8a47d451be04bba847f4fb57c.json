{"ast":null,"code":"\"use strict\";\n/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n\n(function (global, factory) {\n  /* global define, require, module */\n\n  /* AMD */\n  if (typeof define === 'function' && define.amd) define(['protobufjs/minimal'], factory);\n  /* CommonJS */\n  else if (typeof require === 'function' && typeof module === 'object' && module && module.exports) module.exports = factory(require('protobufjs/minimal'));\n})(this, function ($protobuf) {\n  'use strict'; // Common aliases\n\n  var $Reader = $protobuf.Reader,\n      $Writer = $protobuf.Writer,\n      $util = $protobuf.util; // Exported root namespace\n\n  var $root = $protobuf.roots['default'] || ($protobuf.roots['default'] = {});\n\n  $root.Data = function () {\n    /**\n     * Properties of a Data.\n     * @exports IData\n     * @interface IData\n     * @property {string|null} [streamName] Data streamName\n     * @property {Uint8Array|null} [data] Data data\n     */\n\n    /**\n     * Constructs a new Data.\n     * @exports Data\n     * @classdesc Represents a Data.\n     * @implements IData\n     * @constructor\n     * @param {IData=} [properties] Properties to set\n     */\n    function Data(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * Data streamName.\n     * @member {string} streamName\n     * @memberof Data\n     * @instance\n     */\n\n\n    Data.prototype.streamName = '';\n    /**\n     * Data data.\n     * @member {Uint8Array} data\n     * @memberof Data\n     * @instance\n     */\n\n    Data.prototype.data = $util.newBuffer([]);\n    /**\n     * Creates a new Data instance using the specified properties.\n     * @function create\n     * @memberof Data\n     * @static\n     * @param {IData=} [properties] Properties to set\n     * @returns {Data} Data instance\n     */\n\n    Data.create = function create(properties) {\n      return new Data(properties);\n    };\n    /**\n     * Encodes the specified Data message. Does not implicitly {@link Data.verify|verify} messages.\n     * @function encode\n     * @memberof Data\n     * @static\n     * @param {IData} message Data message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    Data.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.streamName != null && Object.hasOwnProperty.call(message, 'streamName')) writer.uint32(\n      /* id 1, wireType 2 =*/\n      10).string(message.streamName);\n      if (message.data != null && Object.hasOwnProperty.call(message, 'data')) writer.uint32(\n      /* id 2, wireType 2 =*/\n      18).bytes(message.data);\n      return writer;\n    };\n    /**\n     * Encodes the specified Data message, length delimited. Does not implicitly {@link Data.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Data\n     * @static\n     * @param {IData} message Data message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    Data.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a Data message from the specified reader or buffer.\n     * @function decode\n     * @memberof Data\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Data} Data\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    Data.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.Data();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.streamName = reader.string();\n            break;\n\n          case 2:\n            message.data = reader.bytes();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a Data message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Data\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Data} Data\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    Data.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a Data message.\n     * @function verify\n     * @memberof Data\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    Data.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      if (message.streamName != null && message.hasOwnProperty('streamName')) if (!$util.isString(message.streamName)) return 'streamName: string expected';\n      if (message.data != null && message.hasOwnProperty('data')) if (!(message.data && typeof message.data.length === 'number' || $util.isString(message.data))) return 'data: buffer expected';\n      return null;\n    };\n    /**\n     * Creates a Data message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Data\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {Data} Data\n     */\n\n\n    Data.fromObject = function fromObject(object) {\n      if (object instanceof $root.Data) return object;\n      var message = new $root.Data();\n      if (object.streamName != null) message.streamName = String(object.streamName);\n      if (object.data != null) if (typeof object.data === 'string') $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);else if (object.data.length) message.data = object.data;\n      return message;\n    };\n    /**\n     * Creates a plain object from a Data message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Data\n     * @static\n     * @param {Data} message Data\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    Data.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n\n      if (options.defaults) {\n        object.streamName = '';\n        if (options.bytes === String) object.data = '';else {\n          object.data = [];\n          if (options.bytes !== Array) object.data = $util.newBuffer(object.data);\n        }\n      }\n\n      if (message.streamName != null && message.hasOwnProperty('streamName')) object.streamName = message.streamName;\n      if (message.data != null && message.hasOwnProperty('data')) object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;\n      return object;\n    };\n    /**\n     * Converts this Data to JSON.\n     * @function toJSON\n     * @memberof Data\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    Data.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return Data;\n  }();\n\n  $root.Variables = function () {\n    /**\n     * Properties of a Variables.\n     * @exports IVariables\n     * @interface IVariables\n     * @property {Object.<string,string>|null} [variables] Variables variables\n     */\n\n    /**\n     * Constructs a new Variables.\n     * @exports Variables\n     * @classdesc Represents a Variables.\n     * @implements IVariables\n     * @constructor\n     * @param {IVariables=} [properties] Properties to set\n     */\n    function Variables(properties) {\n      this.variables = {};\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * Variables variables.\n     * @member {Object.<string,string>} variables\n     * @memberof Variables\n     * @instance\n     */\n\n\n    Variables.prototype.variables = $util.emptyObject;\n    /**\n     * Creates a new Variables instance using the specified properties.\n     * @function create\n     * @memberof Variables\n     * @static\n     * @param {IVariables=} [properties] Properties to set\n     * @returns {Variables} Variables instance\n     */\n\n    Variables.create = function create(properties) {\n      return new Variables(properties);\n    };\n    /**\n     * Encodes the specified Variables message. Does not implicitly {@link Variables.verify|verify} messages.\n     * @function encode\n     * @memberof Variables\n     * @static\n     * @param {IVariables} message Variables message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    Variables.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.variables != null && Object.hasOwnProperty.call(message, 'variables')) for (var keys = Object.keys(message.variables), i = 0; i < keys.length; ++i) writer.uint32(\n      /* id 1, wireType 2 =*/\n      10).fork().uint32(\n      /* id 1, wireType 2 =*/\n      10).string(keys[i]).uint32(\n      /* id 2, wireType 2 =*/\n      18).string(message.variables[keys[i]]).ldelim();\n      return writer;\n    };\n    /**\n     * Encodes the specified Variables message, length delimited. Does not implicitly {@link Variables.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Variables\n     * @static\n     * @param {IVariables} message Variables message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    Variables.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a Variables message from the specified reader or buffer.\n     * @function decode\n     * @memberof Variables\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Variables} Variables\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    Variables.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.Variables(),\n          key;\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            reader.skip().pos++;\n            if (message.variables === $util.emptyObject) message.variables = {};\n            key = reader.string();\n            reader.pos++;\n            message.variables[key] = reader.string();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a Variables message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Variables\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Variables} Variables\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    Variables.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a Variables message.\n     * @function verify\n     * @memberof Variables\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    Variables.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n\n      if (message.variables != null && message.hasOwnProperty('variables')) {\n        if (!$util.isObject(message.variables)) return 'variables: object expected';\n        var key = Object.keys(message.variables);\n\n        for (var i = 0; i < key.length; ++i) if (!$util.isString(message.variables[key[i]])) return 'variables: string{k:string} expected';\n      }\n\n      return null;\n    };\n    /**\n     * Creates a Variables message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Variables\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {Variables} Variables\n     */\n\n\n    Variables.fromObject = function fromObject(object) {\n      if (object instanceof $root.Variables) return object;\n      var message = new $root.Variables();\n\n      if (object.variables) {\n        if (typeof object.variables !== 'object') throw TypeError('.Variables.variables: object expected');\n        message.variables = {};\n\n        for (var keys = Object.keys(object.variables), i = 0; i < keys.length; ++i) message.variables[keys[i]] = String(object.variables[keys[i]]);\n      }\n\n      return message;\n    };\n    /**\n     * Creates a plain object from a Variables message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Variables\n     * @static\n     * @param {Variables} message Variables\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    Variables.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.objects || options.defaults) object.variables = {};\n      var keys2;\n\n      if (message.variables && (keys2 = Object.keys(message.variables)).length) {\n        object.variables = {};\n\n        for (var j = 0; j < keys2.length; ++j) object.variables[keys2[j]] = message.variables[keys2[j]];\n      }\n\n      return object;\n    };\n    /**\n     * Converts this Variables to JSON.\n     * @function toJSON\n     * @memberof Variables\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    Variables.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return Variables;\n  }();\n\n  $root.Info = function () {\n    /**\n     * Properties of an Info.\n     * @exports IInfo\n     * @interface IInfo\n     * @property {string|null} [info] Info info\n     * @property {string|null} [messageId] Info messageId\n     * @property {string|null} [channelName] Info channelName\n     * @property {string|null} [sessionId] Info sessionId\n     * @property {string|null} [userId] Info userId\n     */\n\n    /**\n     * Constructs a new Info.\n     * @exports Info\n     * @classdesc Represents an Info.\n     * @implements IInfo\n     * @constructor\n     * @param {IInfo=} [properties] Properties to set\n     */\n    function Info(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * Info info.\n     * @member {string} info\n     * @memberof Info\n     * @instance\n     */\n\n\n    Info.prototype.info = '';\n    /**\n     * Info messageId.\n     * @member {string} messageId\n     * @memberof Info\n     * @instance\n     */\n\n    Info.prototype.messageId = '';\n    /**\n     * Info channelName.\n     * @member {string} channelName\n     * @memberof Info\n     * @instance\n     */\n\n    Info.prototype.channelName = '';\n    /**\n     * Info sessionId.\n     * @member {string} sessionId\n     * @memberof Info\n     * @instance\n     */\n\n    Info.prototype.sessionId = '';\n    /**\n     * Info userId.\n     * @member {string} userId\n     * @memberof Info\n     * @instance\n     */\n\n    Info.prototype.userId = '';\n    /**\n     * Creates a new Info instance using the specified properties.\n     * @function create\n     * @memberof Info\n     * @static\n     * @param {IInfo=} [properties] Properties to set\n     * @returns {Info} Info instance\n     */\n\n    Info.create = function create(properties) {\n      return new Info(properties);\n    };\n    /**\n     * Encodes the specified Info message. Does not implicitly {@link Info.verify|verify} messages.\n     * @function encode\n     * @memberof Info\n     * @static\n     * @param {IInfo} message Info message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    Info.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.info != null && Object.hasOwnProperty.call(message, 'info')) writer.uint32(\n      /* id 1, wireType 2 =*/\n      10).string(message.info);\n      if (message.messageId != null && Object.hasOwnProperty.call(message, 'messageId')) writer.uint32(\n      /* id 2, wireType 2 =*/\n      18).string(message.messageId);\n      if (message.channelName != null && Object.hasOwnProperty.call(message, 'channelName')) writer.uint32(\n      /* id 3, wireType 2 =*/\n      26).string(message.channelName);\n      if (message.sessionId != null && Object.hasOwnProperty.call(message, 'sessionId')) writer.uint32(\n      /* id 4, wireType 2 =*/\n      34).string(message.sessionId);\n      if (message.userId != null && Object.hasOwnProperty.call(message, 'userId')) writer.uint32(\n      /* id 5, wireType 2 =*/\n      42).string(message.userId);\n      return writer;\n    };\n    /**\n     * Encodes the specified Info message, length delimited. Does not implicitly {@link Info.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Info\n     * @static\n     * @param {IInfo} message Info message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    Info.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes an Info message from the specified reader or buffer.\n     * @function decode\n     * @memberof Info\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Info} Info\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    Info.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.Info();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.info = reader.string();\n            break;\n\n          case 2:\n            message.messageId = reader.string();\n            break;\n\n          case 3:\n            message.channelName = reader.string();\n            break;\n\n          case 4:\n            message.sessionId = reader.string();\n            break;\n\n          case 5:\n            message.userId = reader.string();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes an Info message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Info\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Info} Info\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    Info.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies an Info message.\n     * @function verify\n     * @memberof Info\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    Info.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      if (message.info != null && message.hasOwnProperty('info')) if (!$util.isString(message.info)) return 'info: string expected';\n      if (message.messageId != null && message.hasOwnProperty('messageId')) if (!$util.isString(message.messageId)) return 'messageId: string expected';\n      if (message.channelName != null && message.hasOwnProperty('channelName')) if (!$util.isString(message.channelName)) return 'channelName: string expected';\n      if (message.sessionId != null && message.hasOwnProperty('sessionId')) if (!$util.isString(message.sessionId)) return 'sessionId: string expected';\n      if (message.userId != null && message.hasOwnProperty('userId')) if (!$util.isString(message.userId)) return 'userId: string expected';\n      return null;\n    };\n    /**\n     * Creates an Info message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Info\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {Info} Info\n     */\n\n\n    Info.fromObject = function fromObject(object) {\n      if (object instanceof $root.Info) return object;\n      var message = new $root.Info();\n      if (object.info != null) message.info = String(object.info);\n      if (object.messageId != null) message.messageId = String(object.messageId);\n      if (object.channelName != null) message.channelName = String(object.channelName);\n      if (object.sessionId != null) message.sessionId = String(object.sessionId);\n      if (object.userId != null) message.userId = String(object.userId);\n      return message;\n    };\n    /**\n     * Creates a plain object from an Info message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Info\n     * @static\n     * @param {Info} message Info\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    Info.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n\n      if (options.defaults) {\n        object.info = '';\n        object.messageId = '';\n        object.channelName = '';\n        object.sessionId = '';\n        object.userId = '';\n      }\n\n      if (message.info != null && message.hasOwnProperty('info')) object.info = message.info;\n      if (message.messageId != null && message.hasOwnProperty('messageId')) object.messageId = message.messageId;\n      if (message.channelName != null && message.hasOwnProperty('channelName')) object.channelName = message.channelName;\n      if (message.sessionId != null && message.hasOwnProperty('sessionId')) object.sessionId = message.sessionId;\n      if (message.userId != null && message.hasOwnProperty('userId')) object.userId = message.userId;\n      return object;\n    };\n    /**\n     * Converts this Info to JSON.\n     * @function toJSON\n     * @memberof Info\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    Info.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return Info;\n  }();\n\n  $root.Finalized = function () {\n    /**\n     * Properties of a Finalized.\n     * @exports IFinalized\n     * @interface IFinalized\n     */\n\n    /**\n     * Constructs a new Finalized.\n     * @exports Finalized\n     * @classdesc Represents a Finalized.\n     * @implements IFinalized\n     * @constructor\n     * @param {IFinalized=} [properties] Properties to set\n     */\n    function Finalized(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * Creates a new Finalized instance using the specified properties.\n     * @function create\n     * @memberof Finalized\n     * @static\n     * @param {IFinalized=} [properties] Properties to set\n     * @returns {Finalized} Finalized instance\n     */\n\n\n    Finalized.create = function create(properties) {\n      return new Finalized(properties);\n    };\n    /**\n     * Encodes the specified Finalized message. Does not implicitly {@link Finalized.verify|verify} messages.\n     * @function encode\n     * @memberof Finalized\n     * @static\n     * @param {IFinalized} message Finalized message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    Finalized.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      return writer;\n    };\n    /**\n     * Encodes the specified Finalized message, length delimited. Does not implicitly {@link Finalized.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Finalized\n     * @static\n     * @param {IFinalized} message Finalized message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    Finalized.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a Finalized message from the specified reader or buffer.\n     * @function decode\n     * @memberof Finalized\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Finalized} Finalized\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    Finalized.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.Finalized();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a Finalized message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Finalized\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Finalized} Finalized\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    Finalized.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a Finalized message.\n     * @function verify\n     * @memberof Finalized\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    Finalized.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      return null;\n    };\n    /**\n     * Creates a Finalized message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Finalized\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {Finalized} Finalized\n     */\n\n\n    Finalized.fromObject = function fromObject(object) {\n      if (object instanceof $root.Finalized) return object;\n      return new $root.Finalized();\n    };\n    /**\n     * Creates a plain object from a Finalized message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Finalized\n     * @static\n     * @param {Finalized} message Finalized\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    Finalized.toObject = function toObject() {\n      return {};\n    };\n    /**\n     * Converts this Finalized to JSON.\n     * @function toJSON\n     * @memberof Finalized\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    Finalized.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return Finalized;\n  }();\n\n  $root.SetOptions = function () {\n    /**\n     * Properties of a SetOptions.\n     * @exports ISetOptions\n     * @interface ISetOptions\n     * @property {SetOptions.INonFinalHypothesisOptions|null} [nonFinalHypothesisOptions] SetOptions nonFinalHypothesisOptions\n     * @property {SetOptions.IShortPhraseModelOptions|null} [shortPhraseModelOptions] SetOptions shortPhraseModelOptions\n     * @property {SetOptions.ISampleRateOptions|null} [sampleRateOptions] SetOptions sampleRateOptions\n     * @property {SetOptions.IAudioEncodingOptions|null} [audioEncodingOptions] SetOptions audioEncodingOptions\n     * @property {SetOptions.ILanguageOptions|null} [languageOptions] SetOptions languageOptions\n     * @property {SetOptions.IProfanityFilterOptions|null} [profanityFilterOptions] SetOptions profanityFilterOptions\n     * @property {SetOptions.INormalizationOptions|null} [normalizationOptions] SetOptions normalizationOptions\n     * @property {SetOptions.INBestOptions|null} [nBestOptions] SetOptions nBestOptions\n     * @property {SetOptions.IModelOptions|null} [modelOptions] SetOptions modelOptions\n     * @property {IInfo|null} [info] SetOptions info\n     */\n\n    /**\n     * Constructs a new SetOptions.\n     * @exports SetOptions\n     * @classdesc Represents a SetOptions.\n     * @implements ISetOptions\n     * @constructor\n     * @param {ISetOptions=} [properties] Properties to set\n     */\n    function SetOptions(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * SetOptions nonFinalHypothesisOptions.\n     * @member {SetOptions.INonFinalHypothesisOptions|null|undefined} nonFinalHypothesisOptions\n     * @memberof SetOptions\n     * @instance\n     */\n\n\n    SetOptions.prototype.nonFinalHypothesisOptions = null;\n    /**\n     * SetOptions shortPhraseModelOptions.\n     * @member {SetOptions.IShortPhraseModelOptions|null|undefined} shortPhraseModelOptions\n     * @memberof SetOptions\n     * @instance\n     */\n\n    SetOptions.prototype.shortPhraseModelOptions = null;\n    /**\n     * SetOptions sampleRateOptions.\n     * @member {SetOptions.ISampleRateOptions|null|undefined} sampleRateOptions\n     * @memberof SetOptions\n     * @instance\n     */\n\n    SetOptions.prototype.sampleRateOptions = null;\n    /**\n     * SetOptions audioEncodingOptions.\n     * @member {SetOptions.IAudioEncodingOptions|null|undefined} audioEncodingOptions\n     * @memberof SetOptions\n     * @instance\n     */\n\n    SetOptions.prototype.audioEncodingOptions = null;\n    /**\n     * SetOptions languageOptions.\n     * @member {SetOptions.ILanguageOptions|null|undefined} languageOptions\n     * @memberof SetOptions\n     * @instance\n     */\n\n    SetOptions.prototype.languageOptions = null;\n    /**\n     * SetOptions profanityFilterOptions.\n     * @member {SetOptions.IProfanityFilterOptions|null|undefined} profanityFilterOptions\n     * @memberof SetOptions\n     * @instance\n     */\n\n    SetOptions.prototype.profanityFilterOptions = null;\n    /**\n     * SetOptions normalizationOptions.\n     * @member {SetOptions.INormalizationOptions|null|undefined} normalizationOptions\n     * @memberof SetOptions\n     * @instance\n     */\n\n    SetOptions.prototype.normalizationOptions = null;\n    /**\n     * SetOptions nBestOptions.\n     * @member {SetOptions.INBestOptions|null|undefined} nBestOptions\n     * @memberof SetOptions\n     * @instance\n     */\n\n    SetOptions.prototype.nBestOptions = null;\n    /**\n     * SetOptions modelOptions.\n     * @member {SetOptions.IModelOptions|null|undefined} modelOptions\n     * @memberof SetOptions\n     * @instance\n     */\n\n    SetOptions.prototype.modelOptions = null;\n    /**\n     * SetOptions info.\n     * @member {IInfo|null|undefined} info\n     * @memberof SetOptions\n     * @instance\n     */\n\n    SetOptions.prototype.info = null;\n    /**\n     * Creates a new SetOptions instance using the specified properties.\n     * @function create\n     * @memberof SetOptions\n     * @static\n     * @param {ISetOptions=} [properties] Properties to set\n     * @returns {SetOptions} SetOptions instance\n     */\n\n    SetOptions.create = function create(properties) {\n      return new SetOptions(properties);\n    };\n    /**\n     * Encodes the specified SetOptions message. Does not implicitly {@link SetOptions.verify|verify} messages.\n     * @function encode\n     * @memberof SetOptions\n     * @static\n     * @param {ISetOptions} message SetOptions message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    SetOptions.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.nonFinalHypothesisOptions != null && Object.hasOwnProperty.call(message, 'nonFinalHypothesisOptions')) $root.SetOptions.NonFinalHypothesisOptions.encode(message.nonFinalHypothesisOptions, writer.uint32(\n      /* id 1, wireType 2 =*/\n      10).fork()).ldelim();\n      if (message.shortPhraseModelOptions != null && Object.hasOwnProperty.call(message, 'shortPhraseModelOptions')) $root.SetOptions.ShortPhraseModelOptions.encode(message.shortPhraseModelOptions, writer.uint32(\n      /* id 2, wireType 2 =*/\n      18).fork()).ldelim();\n      if (message.sampleRateOptions != null && Object.hasOwnProperty.call(message, 'sampleRateOptions')) $root.SetOptions.SampleRateOptions.encode(message.sampleRateOptions, writer.uint32(\n      /* id 3, wireType 2 =*/\n      26).fork()).ldelim();\n      if (message.audioEncodingOptions != null && Object.hasOwnProperty.call(message, 'audioEncodingOptions')) $root.SetOptions.AudioEncodingOptions.encode(message.audioEncodingOptions, writer.uint32(\n      /* id 4, wireType 2 =*/\n      34).fork()).ldelim();\n      if (message.languageOptions != null && Object.hasOwnProperty.call(message, 'languageOptions')) $root.SetOptions.LanguageOptions.encode(message.languageOptions, writer.uint32(\n      /* id 5, wireType 2 =*/\n      42).fork()).ldelim();\n      if (message.profanityFilterOptions != null && Object.hasOwnProperty.call(message, 'profanityFilterOptions')) $root.SetOptions.ProfanityFilterOptions.encode(message.profanityFilterOptions, writer.uint32(\n      /* id 6, wireType 2 =*/\n      50).fork()).ldelim();\n      if (message.normalizationOptions != null && Object.hasOwnProperty.call(message, 'normalizationOptions')) $root.SetOptions.NormalizationOptions.encode(message.normalizationOptions, writer.uint32(\n      /* id 7, wireType 2 =*/\n      58).fork()).ldelim();\n      if (message.nBestOptions != null && Object.hasOwnProperty.call(message, 'nBestOptions')) $root.SetOptions.NBestOptions.encode(message.nBestOptions, writer.uint32(\n      /* id 8, wireType 2 =*/\n      66).fork()).ldelim();\n      if (message.modelOptions != null && Object.hasOwnProperty.call(message, 'modelOptions')) $root.SetOptions.ModelOptions.encode(message.modelOptions, writer.uint32(\n      /* id 9, wireType 2 =*/\n      74).fork()).ldelim();\n      if (message.info != null && Object.hasOwnProperty.call(message, 'info')) $root.Info.encode(message.info, writer.uint32(\n      /* id 10, wireType 2 =*/\n      82).fork()).ldelim();\n      return writer;\n    };\n    /**\n     * Encodes the specified SetOptions message, length delimited. Does not implicitly {@link SetOptions.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof SetOptions\n     * @static\n     * @param {ISetOptions} message SetOptions message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    SetOptions.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a SetOptions message from the specified reader or buffer.\n     * @function decode\n     * @memberof SetOptions\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {SetOptions} SetOptions\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    SetOptions.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.SetOptions();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.nonFinalHypothesisOptions = $root.SetOptions.NonFinalHypothesisOptions.decode(reader, reader.uint32());\n            break;\n\n          case 2:\n            message.shortPhraseModelOptions = $root.SetOptions.ShortPhraseModelOptions.decode(reader, reader.uint32());\n            break;\n\n          case 3:\n            message.sampleRateOptions = $root.SetOptions.SampleRateOptions.decode(reader, reader.uint32());\n            break;\n\n          case 4:\n            message.audioEncodingOptions = $root.SetOptions.AudioEncodingOptions.decode(reader, reader.uint32());\n            break;\n\n          case 5:\n            message.languageOptions = $root.SetOptions.LanguageOptions.decode(reader, reader.uint32());\n            break;\n\n          case 6:\n            message.profanityFilterOptions = $root.SetOptions.ProfanityFilterOptions.decode(reader, reader.uint32());\n            break;\n\n          case 7:\n            message.normalizationOptions = $root.SetOptions.NormalizationOptions.decode(reader, reader.uint32());\n            break;\n\n          case 8:\n            message.nBestOptions = $root.SetOptions.NBestOptions.decode(reader, reader.uint32());\n            break;\n\n          case 9:\n            message.modelOptions = $root.SetOptions.ModelOptions.decode(reader, reader.uint32());\n            break;\n\n          case 10:\n            message.info = $root.Info.decode(reader, reader.uint32());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a SetOptions message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof SetOptions\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {SetOptions} SetOptions\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    SetOptions.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a SetOptions message.\n     * @function verify\n     * @memberof SetOptions\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    SetOptions.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n\n      if (message.nonFinalHypothesisOptions != null && message.hasOwnProperty('nonFinalHypothesisOptions')) {\n        var error = $root.SetOptions.NonFinalHypothesisOptions.verify(message.nonFinalHypothesisOptions);\n        if (error) return 'nonFinalHypothesisOptions.' + error;\n      }\n\n      if (message.shortPhraseModelOptions != null && message.hasOwnProperty('shortPhraseModelOptions')) {\n        var error = $root.SetOptions.ShortPhraseModelOptions.verify(message.shortPhraseModelOptions);\n        if (error) return 'shortPhraseModelOptions.' + error;\n      }\n\n      if (message.sampleRateOptions != null && message.hasOwnProperty('sampleRateOptions')) {\n        var error = $root.SetOptions.SampleRateOptions.verify(message.sampleRateOptions);\n        if (error) return 'sampleRateOptions.' + error;\n      }\n\n      if (message.audioEncodingOptions != null && message.hasOwnProperty('audioEncodingOptions')) {\n        var error = $root.SetOptions.AudioEncodingOptions.verify(message.audioEncodingOptions);\n        if (error) return 'audioEncodingOptions.' + error;\n      }\n\n      if (message.languageOptions != null && message.hasOwnProperty('languageOptions')) {\n        var error = $root.SetOptions.LanguageOptions.verify(message.languageOptions);\n        if (error) return 'languageOptions.' + error;\n      }\n\n      if (message.profanityFilterOptions != null && message.hasOwnProperty('profanityFilterOptions')) {\n        var error = $root.SetOptions.ProfanityFilterOptions.verify(message.profanityFilterOptions);\n        if (error) return 'profanityFilterOptions.' + error;\n      }\n\n      if (message.normalizationOptions != null && message.hasOwnProperty('normalizationOptions')) {\n        var error = $root.SetOptions.NormalizationOptions.verify(message.normalizationOptions);\n        if (error) return 'normalizationOptions.' + error;\n      }\n\n      if (message.nBestOptions != null && message.hasOwnProperty('nBestOptions')) {\n        var error = $root.SetOptions.NBestOptions.verify(message.nBestOptions);\n        if (error) return 'nBestOptions.' + error;\n      }\n\n      if (message.modelOptions != null && message.hasOwnProperty('modelOptions')) {\n        var error = $root.SetOptions.ModelOptions.verify(message.modelOptions);\n        if (error) return 'modelOptions.' + error;\n      }\n\n      if (message.info != null && message.hasOwnProperty('info')) {\n        var error = $root.Info.verify(message.info);\n        if (error) return 'info.' + error;\n      }\n\n      return null;\n    };\n    /**\n     * Creates a SetOptions message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof SetOptions\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {SetOptions} SetOptions\n     */\n\n\n    SetOptions.fromObject = function fromObject(object) {\n      if (object instanceof $root.SetOptions) return object;\n      var message = new $root.SetOptions();\n\n      if (object.nonFinalHypothesisOptions != null) {\n        if (typeof object.nonFinalHypothesisOptions !== 'object') throw TypeError('.SetOptions.nonFinalHypothesisOptions: object expected');\n        message.nonFinalHypothesisOptions = $root.SetOptions.NonFinalHypothesisOptions.fromObject(object.nonFinalHypothesisOptions);\n      }\n\n      if (object.shortPhraseModelOptions != null) {\n        if (typeof object.shortPhraseModelOptions !== 'object') throw TypeError('.SetOptions.shortPhraseModelOptions: object expected');\n        message.shortPhraseModelOptions = $root.SetOptions.ShortPhraseModelOptions.fromObject(object.shortPhraseModelOptions);\n      }\n\n      if (object.sampleRateOptions != null) {\n        if (typeof object.sampleRateOptions !== 'object') throw TypeError('.SetOptions.sampleRateOptions: object expected');\n        message.sampleRateOptions = $root.SetOptions.SampleRateOptions.fromObject(object.sampleRateOptions);\n      }\n\n      if (object.audioEncodingOptions != null) {\n        if (typeof object.audioEncodingOptions !== 'object') throw TypeError('.SetOptions.audioEncodingOptions: object expected');\n        message.audioEncodingOptions = $root.SetOptions.AudioEncodingOptions.fromObject(object.audioEncodingOptions);\n      }\n\n      if (object.languageOptions != null) {\n        if (typeof object.languageOptions !== 'object') throw TypeError('.SetOptions.languageOptions: object expected');\n        message.languageOptions = $root.SetOptions.LanguageOptions.fromObject(object.languageOptions);\n      }\n\n      if (object.profanityFilterOptions != null) {\n        if (typeof object.profanityFilterOptions !== 'object') throw TypeError('.SetOptions.profanityFilterOptions: object expected');\n        message.profanityFilterOptions = $root.SetOptions.ProfanityFilterOptions.fromObject(object.profanityFilterOptions);\n      }\n\n      if (object.normalizationOptions != null) {\n        if (typeof object.normalizationOptions !== 'object') throw TypeError('.SetOptions.normalizationOptions: object expected');\n        message.normalizationOptions = $root.SetOptions.NormalizationOptions.fromObject(object.normalizationOptions);\n      }\n\n      if (object.nBestOptions != null) {\n        if (typeof object.nBestOptions !== 'object') throw TypeError('.SetOptions.nBestOptions: object expected');\n        message.nBestOptions = $root.SetOptions.NBestOptions.fromObject(object.nBestOptions);\n      }\n\n      if (object.modelOptions != null) {\n        if (typeof object.modelOptions !== 'object') throw TypeError('.SetOptions.modelOptions: object expected');\n        message.modelOptions = $root.SetOptions.ModelOptions.fromObject(object.modelOptions);\n      }\n\n      if (object.info != null) {\n        if (typeof object.info !== 'object') throw TypeError('.SetOptions.info: object expected');\n        message.info = $root.Info.fromObject(object.info);\n      }\n\n      return message;\n    };\n    /**\n     * Creates a plain object from a SetOptions message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof SetOptions\n     * @static\n     * @param {SetOptions} message SetOptions\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    SetOptions.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n\n      if (options.defaults) {\n        object.nonFinalHypothesisOptions = null;\n        object.shortPhraseModelOptions = null;\n        object.sampleRateOptions = null;\n        object.audioEncodingOptions = null;\n        object.languageOptions = null;\n        object.profanityFilterOptions = null;\n        object.normalizationOptions = null;\n        object.nBestOptions = null;\n        object.modelOptions = null;\n        object.info = null;\n      }\n\n      if (message.nonFinalHypothesisOptions != null && message.hasOwnProperty('nonFinalHypothesisOptions')) object.nonFinalHypothesisOptions = $root.SetOptions.NonFinalHypothesisOptions.toObject(message.nonFinalHypothesisOptions, options);\n      if (message.shortPhraseModelOptions != null && message.hasOwnProperty('shortPhraseModelOptions')) object.shortPhraseModelOptions = $root.SetOptions.ShortPhraseModelOptions.toObject(message.shortPhraseModelOptions, options);\n      if (message.sampleRateOptions != null && message.hasOwnProperty('sampleRateOptions')) object.sampleRateOptions = $root.SetOptions.SampleRateOptions.toObject(message.sampleRateOptions, options);\n      if (message.audioEncodingOptions != null && message.hasOwnProperty('audioEncodingOptions')) object.audioEncodingOptions = $root.SetOptions.AudioEncodingOptions.toObject(message.audioEncodingOptions, options);\n      if (message.languageOptions != null && message.hasOwnProperty('languageOptions')) object.languageOptions = $root.SetOptions.LanguageOptions.toObject(message.languageOptions, options);\n      if (message.profanityFilterOptions != null && message.hasOwnProperty('profanityFilterOptions')) object.profanityFilterOptions = $root.SetOptions.ProfanityFilterOptions.toObject(message.profanityFilterOptions, options);\n      if (message.normalizationOptions != null && message.hasOwnProperty('normalizationOptions')) object.normalizationOptions = $root.SetOptions.NormalizationOptions.toObject(message.normalizationOptions, options);\n      if (message.nBestOptions != null && message.hasOwnProperty('nBestOptions')) object.nBestOptions = $root.SetOptions.NBestOptions.toObject(message.nBestOptions, options);\n      if (message.modelOptions != null && message.hasOwnProperty('modelOptions')) object.modelOptions = $root.SetOptions.ModelOptions.toObject(message.modelOptions, options);\n      if (message.info != null && message.hasOwnProperty('info')) object.info = $root.Info.toObject(message.info, options);\n      return object;\n    };\n    /**\n     * Converts this SetOptions to JSON.\n     * @function toJSON\n     * @memberof SetOptions\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    SetOptions.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    SetOptions.NonFinalHypothesisOptions = function () {\n      /**\n       * Properties of a NonFinalHypothesisOptions.\n       * @memberof SetOptions\n       * @interface INonFinalHypothesisOptions\n       * @property {boolean|null} [enableNonFinalHypothesisReport] NonFinalHypothesisOptions enableNonFinalHypothesisReport\n       * @property {number|null} [nonFinalHypothesisReportIntervalSeconds] NonFinalHypothesisOptions nonFinalHypothesisReportIntervalSeconds\n       */\n\n      /**\n       * Constructs a new NonFinalHypothesisOptions.\n       * @memberof SetOptions\n       * @classdesc Represents a NonFinalHypothesisOptions.\n       * @implements INonFinalHypothesisOptions\n       * @constructor\n       * @param {SetOptions.INonFinalHypothesisOptions=} [properties] Properties to set\n       */\n      function NonFinalHypothesisOptions(properties) {\n        if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * NonFinalHypothesisOptions enableNonFinalHypothesisReport.\n       * @member {boolean} enableNonFinalHypothesisReport\n       * @memberof SetOptions.NonFinalHypothesisOptions\n       * @instance\n       */\n\n\n      NonFinalHypothesisOptions.prototype.enableNonFinalHypothesisReport = false;\n      /**\n       * NonFinalHypothesisOptions nonFinalHypothesisReportIntervalSeconds.\n       * @member {number} nonFinalHypothesisReportIntervalSeconds\n       * @memberof SetOptions.NonFinalHypothesisOptions\n       * @instance\n       */\n\n      NonFinalHypothesisOptions.prototype.nonFinalHypothesisReportIntervalSeconds = 0;\n      /**\n       * Creates a new NonFinalHypothesisOptions instance using the specified properties.\n       * @function create\n       * @memberof SetOptions.NonFinalHypothesisOptions\n       * @static\n       * @param {SetOptions.INonFinalHypothesisOptions=} [properties] Properties to set\n       * @returns {SetOptions.NonFinalHypothesisOptions} NonFinalHypothesisOptions instance\n       */\n\n      NonFinalHypothesisOptions.create = function create(properties) {\n        return new NonFinalHypothesisOptions(properties);\n      };\n      /**\n       * Encodes the specified NonFinalHypothesisOptions message. Does not implicitly {@link SetOptions.NonFinalHypothesisOptions.verify|verify} messages.\n       * @function encode\n       * @memberof SetOptions.NonFinalHypothesisOptions\n       * @static\n       * @param {SetOptions.INonFinalHypothesisOptions} message NonFinalHypothesisOptions message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      NonFinalHypothesisOptions.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create();\n        if (message.enableNonFinalHypothesisReport != null && Object.hasOwnProperty.call(message, 'enableNonFinalHypothesisReport')) writer.uint32(\n        /* id 1, wireType 0 =*/\n        8).bool(message.enableNonFinalHypothesisReport);\n        if (message.nonFinalHypothesisReportIntervalSeconds != null && Object.hasOwnProperty.call(message, 'nonFinalHypothesisReportIntervalSeconds')) writer.uint32(\n        /* id 2, wireType 5 =*/\n        21).float(message.nonFinalHypothesisReportIntervalSeconds);\n        return writer;\n      };\n      /**\n       * Encodes the specified NonFinalHypothesisOptions message, length delimited. Does not implicitly {@link SetOptions.NonFinalHypothesisOptions.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof SetOptions.NonFinalHypothesisOptions\n       * @static\n       * @param {SetOptions.INonFinalHypothesisOptions} message NonFinalHypothesisOptions message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      NonFinalHypothesisOptions.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n      /**\n       * Decodes a NonFinalHypothesisOptions message from the specified reader or buffer.\n       * @function decode\n       * @memberof SetOptions.NonFinalHypothesisOptions\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {SetOptions.NonFinalHypothesisOptions} NonFinalHypothesisOptions\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      NonFinalHypothesisOptions.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.SetOptions.NonFinalHypothesisOptions();\n\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              message.enableNonFinalHypothesisReport = reader.bool();\n              break;\n\n            case 2:\n              message.nonFinalHypothesisReportIntervalSeconds = reader.float();\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n      /**\n       * Decodes a NonFinalHypothesisOptions message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof SetOptions.NonFinalHypothesisOptions\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {SetOptions.NonFinalHypothesisOptions} NonFinalHypothesisOptions\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      NonFinalHypothesisOptions.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n      };\n      /**\n       * Verifies a NonFinalHypothesisOptions message.\n       * @function verify\n       * @memberof SetOptions.NonFinalHypothesisOptions\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n\n\n      NonFinalHypothesisOptions.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected';\n        if (message.enableNonFinalHypothesisReport != null && message.hasOwnProperty('enableNonFinalHypothesisReport')) if (typeof message.enableNonFinalHypothesisReport !== 'boolean') return 'enableNonFinalHypothesisReport: boolean expected';\n        if (message.nonFinalHypothesisReportIntervalSeconds != null && message.hasOwnProperty('nonFinalHypothesisReportIntervalSeconds')) if (typeof message.nonFinalHypothesisReportIntervalSeconds !== 'number') return 'nonFinalHypothesisReportIntervalSeconds: number expected';\n        return null;\n      };\n      /**\n       * Creates a NonFinalHypothesisOptions message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof SetOptions.NonFinalHypothesisOptions\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {SetOptions.NonFinalHypothesisOptions} NonFinalHypothesisOptions\n       */\n\n\n      NonFinalHypothesisOptions.fromObject = function fromObject(object) {\n        if (object instanceof $root.SetOptions.NonFinalHypothesisOptions) return object;\n        var message = new $root.SetOptions.NonFinalHypothesisOptions();\n        if (object.enableNonFinalHypothesisReport != null) message.enableNonFinalHypothesisReport = Boolean(object.enableNonFinalHypothesisReport);\n        if (object.nonFinalHypothesisReportIntervalSeconds != null) message.nonFinalHypothesisReportIntervalSeconds = Number(object.nonFinalHypothesisReportIntervalSeconds);\n        return message;\n      };\n      /**\n       * Creates a plain object from a NonFinalHypothesisOptions message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof SetOptions.NonFinalHypothesisOptions\n       * @static\n       * @param {SetOptions.NonFinalHypothesisOptions} message NonFinalHypothesisOptions\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n\n\n      NonFinalHypothesisOptions.toObject = function toObject(message, options) {\n        if (!options) options = {};\n        var object = {};\n\n        if (options.defaults) {\n          object.enableNonFinalHypothesisReport = false;\n          object.nonFinalHypothesisReportIntervalSeconds = 0;\n        }\n\n        if (message.enableNonFinalHypothesisReport != null && message.hasOwnProperty('enableNonFinalHypothesisReport')) object.enableNonFinalHypothesisReport = message.enableNonFinalHypothesisReport;\n        if (message.nonFinalHypothesisReportIntervalSeconds != null && message.hasOwnProperty('nonFinalHypothesisReportIntervalSeconds')) object.nonFinalHypothesisReportIntervalSeconds = options.json && !isFinite(message.nonFinalHypothesisReportIntervalSeconds) ? String(message.nonFinalHypothesisReportIntervalSeconds) : message.nonFinalHypothesisReportIntervalSeconds;\n        return object;\n      };\n      /**\n       * Converts this NonFinalHypothesisOptions to JSON.\n       * @function toJSON\n       * @memberof SetOptions.NonFinalHypothesisOptions\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n\n\n      NonFinalHypothesisOptions.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      return NonFinalHypothesisOptions;\n    }();\n\n    SetOptions.ShortPhraseModelOptions = function () {\n      /**\n       * Properties of a ShortPhraseModelOptions.\n       * @memberof SetOptions\n       * @interface IShortPhraseModelOptions\n       * @property {boolean|null} [enableShortPhraseModel] ShortPhraseModelOptions enableShortPhraseModel\n       * @property {number|null} [shortPhraseModelCutoff] ShortPhraseModelOptions shortPhraseModelCutoff\n       */\n\n      /**\n       * Constructs a new ShortPhraseModelOptions.\n       * @memberof SetOptions\n       * @classdesc Represents a ShortPhraseModelOptions.\n       * @implements IShortPhraseModelOptions\n       * @constructor\n       * @param {SetOptions.IShortPhraseModelOptions=} [properties] Properties to set\n       */\n      function ShortPhraseModelOptions(properties) {\n        if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * ShortPhraseModelOptions enableShortPhraseModel.\n       * @member {boolean} enableShortPhraseModel\n       * @memberof SetOptions.ShortPhraseModelOptions\n       * @instance\n       */\n\n\n      ShortPhraseModelOptions.prototype.enableShortPhraseModel = false;\n      /**\n       * ShortPhraseModelOptions shortPhraseModelCutoff.\n       * @member {number} shortPhraseModelCutoff\n       * @memberof SetOptions.ShortPhraseModelOptions\n       * @instance\n       */\n\n      ShortPhraseModelOptions.prototype.shortPhraseModelCutoff = 0;\n      /**\n       * Creates a new ShortPhraseModelOptions instance using the specified properties.\n       * @function create\n       * @memberof SetOptions.ShortPhraseModelOptions\n       * @static\n       * @param {SetOptions.IShortPhraseModelOptions=} [properties] Properties to set\n       * @returns {SetOptions.ShortPhraseModelOptions} ShortPhraseModelOptions instance\n       */\n\n      ShortPhraseModelOptions.create = function create(properties) {\n        return new ShortPhraseModelOptions(properties);\n      };\n      /**\n       * Encodes the specified ShortPhraseModelOptions message. Does not implicitly {@link SetOptions.ShortPhraseModelOptions.verify|verify} messages.\n       * @function encode\n       * @memberof SetOptions.ShortPhraseModelOptions\n       * @static\n       * @param {SetOptions.IShortPhraseModelOptions} message ShortPhraseModelOptions message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      ShortPhraseModelOptions.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create();\n        if (message.enableShortPhraseModel != null && Object.hasOwnProperty.call(message, 'enableShortPhraseModel')) writer.uint32(\n        /* id 1, wireType 0 =*/\n        8).bool(message.enableShortPhraseModel);\n        if (message.shortPhraseModelCutoff != null && Object.hasOwnProperty.call(message, 'shortPhraseModelCutoff')) writer.uint32(\n        /* id 2, wireType 5 =*/\n        21).float(message.shortPhraseModelCutoff);\n        return writer;\n      };\n      /**\n       * Encodes the specified ShortPhraseModelOptions message, length delimited. Does not implicitly {@link SetOptions.ShortPhraseModelOptions.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof SetOptions.ShortPhraseModelOptions\n       * @static\n       * @param {SetOptions.IShortPhraseModelOptions} message ShortPhraseModelOptions message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      ShortPhraseModelOptions.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n      /**\n       * Decodes a ShortPhraseModelOptions message from the specified reader or buffer.\n       * @function decode\n       * @memberof SetOptions.ShortPhraseModelOptions\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {SetOptions.ShortPhraseModelOptions} ShortPhraseModelOptions\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      ShortPhraseModelOptions.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.SetOptions.ShortPhraseModelOptions();\n\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              message.enableShortPhraseModel = reader.bool();\n              break;\n\n            case 2:\n              message.shortPhraseModelCutoff = reader.float();\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n      /**\n       * Decodes a ShortPhraseModelOptions message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof SetOptions.ShortPhraseModelOptions\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {SetOptions.ShortPhraseModelOptions} ShortPhraseModelOptions\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      ShortPhraseModelOptions.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n      };\n      /**\n       * Verifies a ShortPhraseModelOptions message.\n       * @function verify\n       * @memberof SetOptions.ShortPhraseModelOptions\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n\n\n      ShortPhraseModelOptions.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected';\n        if (message.enableShortPhraseModel != null && message.hasOwnProperty('enableShortPhraseModel')) if (typeof message.enableShortPhraseModel !== 'boolean') return 'enableShortPhraseModel: boolean expected';\n        if (message.shortPhraseModelCutoff != null && message.hasOwnProperty('shortPhraseModelCutoff')) if (typeof message.shortPhraseModelCutoff !== 'number') return 'shortPhraseModelCutoff: number expected';\n        return null;\n      };\n      /**\n       * Creates a ShortPhraseModelOptions message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof SetOptions.ShortPhraseModelOptions\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {SetOptions.ShortPhraseModelOptions} ShortPhraseModelOptions\n       */\n\n\n      ShortPhraseModelOptions.fromObject = function fromObject(object) {\n        if (object instanceof $root.SetOptions.ShortPhraseModelOptions) return object;\n        var message = new $root.SetOptions.ShortPhraseModelOptions();\n        if (object.enableShortPhraseModel != null) message.enableShortPhraseModel = Boolean(object.enableShortPhraseModel);\n        if (object.shortPhraseModelCutoff != null) message.shortPhraseModelCutoff = Number(object.shortPhraseModelCutoff);\n        return message;\n      };\n      /**\n       * Creates a plain object from a ShortPhraseModelOptions message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof SetOptions.ShortPhraseModelOptions\n       * @static\n       * @param {SetOptions.ShortPhraseModelOptions} message ShortPhraseModelOptions\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n\n\n      ShortPhraseModelOptions.toObject = function toObject(message, options) {\n        if (!options) options = {};\n        var object = {};\n\n        if (options.defaults) {\n          object.enableShortPhraseModel = false;\n          object.shortPhraseModelCutoff = 0;\n        }\n\n        if (message.enableShortPhraseModel != null && message.hasOwnProperty('enableShortPhraseModel')) object.enableShortPhraseModel = message.enableShortPhraseModel;\n        if (message.shortPhraseModelCutoff != null && message.hasOwnProperty('shortPhraseModelCutoff')) object.shortPhraseModelCutoff = options.json && !isFinite(message.shortPhraseModelCutoff) ? String(message.shortPhraseModelCutoff) : message.shortPhraseModelCutoff;\n        return object;\n      };\n      /**\n       * Converts this ShortPhraseModelOptions to JSON.\n       * @function toJSON\n       * @memberof SetOptions.ShortPhraseModelOptions\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n\n\n      ShortPhraseModelOptions.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      return ShortPhraseModelOptions;\n    }();\n\n    SetOptions.SampleRateOptions = function () {\n      /**\n       * Properties of a SampleRateOptions.\n       * @memberof SetOptions\n       * @interface ISampleRateOptions\n       * @property {number|null} [sampleRate] SampleRateOptions sampleRate\n       */\n\n      /**\n       * Constructs a new SampleRateOptions.\n       * @memberof SetOptions\n       * @classdesc Represents a SampleRateOptions.\n       * @implements ISampleRateOptions\n       * @constructor\n       * @param {SetOptions.ISampleRateOptions=} [properties] Properties to set\n       */\n      function SampleRateOptions(properties) {\n        if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * SampleRateOptions sampleRate.\n       * @member {number} sampleRate\n       * @memberof SetOptions.SampleRateOptions\n       * @instance\n       */\n\n\n      SampleRateOptions.prototype.sampleRate = 0;\n      /**\n       * Creates a new SampleRateOptions instance using the specified properties.\n       * @function create\n       * @memberof SetOptions.SampleRateOptions\n       * @static\n       * @param {SetOptions.ISampleRateOptions=} [properties] Properties to set\n       * @returns {SetOptions.SampleRateOptions} SampleRateOptions instance\n       */\n\n      SampleRateOptions.create = function create(properties) {\n        return new SampleRateOptions(properties);\n      };\n      /**\n       * Encodes the specified SampleRateOptions message. Does not implicitly {@link SetOptions.SampleRateOptions.verify|verify} messages.\n       * @function encode\n       * @memberof SetOptions.SampleRateOptions\n       * @static\n       * @param {SetOptions.ISampleRateOptions} message SampleRateOptions message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      SampleRateOptions.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create();\n        if (message.sampleRate != null && Object.hasOwnProperty.call(message, 'sampleRate')) writer.uint32(\n        /* id 1, wireType 0 =*/\n        8).int32(message.sampleRate);\n        return writer;\n      };\n      /**\n       * Encodes the specified SampleRateOptions message, length delimited. Does not implicitly {@link SetOptions.SampleRateOptions.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof SetOptions.SampleRateOptions\n       * @static\n       * @param {SetOptions.ISampleRateOptions} message SampleRateOptions message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      SampleRateOptions.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n      /**\n       * Decodes a SampleRateOptions message from the specified reader or buffer.\n       * @function decode\n       * @memberof SetOptions.SampleRateOptions\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {SetOptions.SampleRateOptions} SampleRateOptions\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      SampleRateOptions.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.SetOptions.SampleRateOptions();\n\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              message.sampleRate = reader.int32();\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n      /**\n       * Decodes a SampleRateOptions message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof SetOptions.SampleRateOptions\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {SetOptions.SampleRateOptions} SampleRateOptions\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      SampleRateOptions.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n      };\n      /**\n       * Verifies a SampleRateOptions message.\n       * @function verify\n       * @memberof SetOptions.SampleRateOptions\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n\n\n      SampleRateOptions.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected';\n        if (message.sampleRate != null && message.hasOwnProperty('sampleRate')) if (!$util.isInteger(message.sampleRate)) return 'sampleRate: integer expected';\n        return null;\n      };\n      /**\n       * Creates a SampleRateOptions message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof SetOptions.SampleRateOptions\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {SetOptions.SampleRateOptions} SampleRateOptions\n       */\n\n\n      SampleRateOptions.fromObject = function fromObject(object) {\n        if (object instanceof $root.SetOptions.SampleRateOptions) return object;\n        var message = new $root.SetOptions.SampleRateOptions();\n        if (object.sampleRate != null) message.sampleRate = object.sampleRate | 0;\n        return message;\n      };\n      /**\n       * Creates a plain object from a SampleRateOptions message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof SetOptions.SampleRateOptions\n       * @static\n       * @param {SetOptions.SampleRateOptions} message SampleRateOptions\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n\n\n      SampleRateOptions.toObject = function toObject(message, options) {\n        if (!options) options = {};\n        var object = {};\n        if (options.defaults) object.sampleRate = 0;\n        if (message.sampleRate != null && message.hasOwnProperty('sampleRate')) object.sampleRate = message.sampleRate;\n        return object;\n      };\n      /**\n       * Converts this SampleRateOptions to JSON.\n       * @function toJSON\n       * @memberof SetOptions.SampleRateOptions\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n\n\n      SampleRateOptions.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      return SampleRateOptions;\n    }();\n    /**\n     * AudioEncoding enum.\n     * @name SetOptions.AudioEncoding\n     * @enum {number}\n     * @property {number} PCM_S16LE=0 PCM_S16LE value\n     * @property {number} OPUS=1 OPUS value\n     */\n\n\n    SetOptions.AudioEncoding = function () {\n      var valuesById = {},\n          values = Object.create(valuesById);\n      values[valuesById[0] = 'PCM_S16LE'] = 0;\n      values[valuesById[1] = 'OPUS'] = 1;\n      return values;\n    }();\n\n    SetOptions.AudioEncodingOptions = function () {\n      /**\n       * Properties of an AudioEncodingOptions.\n       * @memberof SetOptions\n       * @interface IAudioEncodingOptions\n       * @property {SetOptions.AudioEncoding|null} [encoding] AudioEncodingOptions encoding\n       */\n\n      /**\n       * Constructs a new AudioEncodingOptions.\n       * @memberof SetOptions\n       * @classdesc Represents an AudioEncodingOptions.\n       * @implements IAudioEncodingOptions\n       * @constructor\n       * @param {SetOptions.IAudioEncodingOptions=} [properties] Properties to set\n       */\n      function AudioEncodingOptions(properties) {\n        if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * AudioEncodingOptions encoding.\n       * @member {SetOptions.AudioEncoding} encoding\n       * @memberof SetOptions.AudioEncodingOptions\n       * @instance\n       */\n\n\n      AudioEncodingOptions.prototype.encoding = 0;\n      /**\n       * Creates a new AudioEncodingOptions instance using the specified properties.\n       * @function create\n       * @memberof SetOptions.AudioEncodingOptions\n       * @static\n       * @param {SetOptions.IAudioEncodingOptions=} [properties] Properties to set\n       * @returns {SetOptions.AudioEncodingOptions} AudioEncodingOptions instance\n       */\n\n      AudioEncodingOptions.create = function create(properties) {\n        return new AudioEncodingOptions(properties);\n      };\n      /**\n       * Encodes the specified AudioEncodingOptions message. Does not implicitly {@link SetOptions.AudioEncodingOptions.verify|verify} messages.\n       * @function encode\n       * @memberof SetOptions.AudioEncodingOptions\n       * @static\n       * @param {SetOptions.IAudioEncodingOptions} message AudioEncodingOptions message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      AudioEncodingOptions.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create();\n        if (message.encoding != null && Object.hasOwnProperty.call(message, 'encoding')) writer.uint32(\n        /* id 1, wireType 0 =*/\n        8).int32(message.encoding);\n        return writer;\n      };\n      /**\n       * Encodes the specified AudioEncodingOptions message, length delimited. Does not implicitly {@link SetOptions.AudioEncodingOptions.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof SetOptions.AudioEncodingOptions\n       * @static\n       * @param {SetOptions.IAudioEncodingOptions} message AudioEncodingOptions message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      AudioEncodingOptions.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n      /**\n       * Decodes an AudioEncodingOptions message from the specified reader or buffer.\n       * @function decode\n       * @memberof SetOptions.AudioEncodingOptions\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {SetOptions.AudioEncodingOptions} AudioEncodingOptions\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      AudioEncodingOptions.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.SetOptions.AudioEncodingOptions();\n\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              message.encoding = reader.int32();\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n      /**\n       * Decodes an AudioEncodingOptions message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof SetOptions.AudioEncodingOptions\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {SetOptions.AudioEncodingOptions} AudioEncodingOptions\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      AudioEncodingOptions.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n      };\n      /**\n       * Verifies an AudioEncodingOptions message.\n       * @function verify\n       * @memberof SetOptions.AudioEncodingOptions\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n\n\n      AudioEncodingOptions.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected';\n        if (message.encoding != null && message.hasOwnProperty('encoding')) switch (message.encoding) {\n          default:\n            return 'encoding: enum value expected';\n\n          case 0:\n          case 1:\n            break;\n        }\n        return null;\n      };\n      /**\n       * Creates an AudioEncodingOptions message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof SetOptions.AudioEncodingOptions\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {SetOptions.AudioEncodingOptions} AudioEncodingOptions\n       */\n\n\n      AudioEncodingOptions.fromObject = function fromObject(object) {\n        if (object instanceof $root.SetOptions.AudioEncodingOptions) return object;\n        var message = new $root.SetOptions.AudioEncodingOptions();\n\n        switch (object.encoding) {\n          case 'PCM_S16LE':\n          case 0:\n            message.encoding = 0;\n            break;\n\n          case 'OPUS':\n          case 1:\n            message.encoding = 1;\n            break;\n        }\n\n        return message;\n      };\n      /**\n       * Creates a plain object from an AudioEncodingOptions message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof SetOptions.AudioEncodingOptions\n       * @static\n       * @param {SetOptions.AudioEncodingOptions} message AudioEncodingOptions\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n\n\n      AudioEncodingOptions.toObject = function toObject(message, options) {\n        if (!options) options = {};\n        var object = {};\n        if (options.defaults) object.encoding = options.enums === String ? 'PCM_S16LE' : 0;\n        if (message.encoding != null && message.hasOwnProperty('encoding')) object.encoding = options.enums === String ? $root.SetOptions.AudioEncoding[message.encoding] : message.encoding;\n        return object;\n      };\n      /**\n       * Converts this AudioEncodingOptions to JSON.\n       * @function toJSON\n       * @memberof SetOptions.AudioEncodingOptions\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n\n\n      AudioEncodingOptions.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      return AudioEncodingOptions;\n    }();\n\n    SetOptions.LanguageOptions = function () {\n      /**\n       * Properties of a LanguageOptions.\n       * @memberof SetOptions\n       * @interface ILanguageOptions\n       * @property {string|null} [languageCode] LanguageOptions languageCode\n       */\n\n      /**\n       * Constructs a new LanguageOptions.\n       * @memberof SetOptions\n       * @classdesc Represents a LanguageOptions.\n       * @implements ILanguageOptions\n       * @constructor\n       * @param {SetOptions.ILanguageOptions=} [properties] Properties to set\n       */\n      function LanguageOptions(properties) {\n        if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * LanguageOptions languageCode.\n       * @member {string} languageCode\n       * @memberof SetOptions.LanguageOptions\n       * @instance\n       */\n\n\n      LanguageOptions.prototype.languageCode = '';\n      /**\n       * Creates a new LanguageOptions instance using the specified properties.\n       * @function create\n       * @memberof SetOptions.LanguageOptions\n       * @static\n       * @param {SetOptions.ILanguageOptions=} [properties] Properties to set\n       * @returns {SetOptions.LanguageOptions} LanguageOptions instance\n       */\n\n      LanguageOptions.create = function create(properties) {\n        return new LanguageOptions(properties);\n      };\n      /**\n       * Encodes the specified LanguageOptions message. Does not implicitly {@link SetOptions.LanguageOptions.verify|verify} messages.\n       * @function encode\n       * @memberof SetOptions.LanguageOptions\n       * @static\n       * @param {SetOptions.ILanguageOptions} message LanguageOptions message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      LanguageOptions.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create();\n        if (message.languageCode != null && Object.hasOwnProperty.call(message, 'languageCode')) writer.uint32(\n        /* id 1, wireType 2 =*/\n        10).string(message.languageCode);\n        return writer;\n      };\n      /**\n       * Encodes the specified LanguageOptions message, length delimited. Does not implicitly {@link SetOptions.LanguageOptions.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof SetOptions.LanguageOptions\n       * @static\n       * @param {SetOptions.ILanguageOptions} message LanguageOptions message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      LanguageOptions.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n      /**\n       * Decodes a LanguageOptions message from the specified reader or buffer.\n       * @function decode\n       * @memberof SetOptions.LanguageOptions\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {SetOptions.LanguageOptions} LanguageOptions\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      LanguageOptions.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.SetOptions.LanguageOptions();\n\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              message.languageCode = reader.string();\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n      /**\n       * Decodes a LanguageOptions message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof SetOptions.LanguageOptions\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {SetOptions.LanguageOptions} LanguageOptions\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      LanguageOptions.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n      };\n      /**\n       * Verifies a LanguageOptions message.\n       * @function verify\n       * @memberof SetOptions.LanguageOptions\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n\n\n      LanguageOptions.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected';\n        if (message.languageCode != null && message.hasOwnProperty('languageCode')) if (!$util.isString(message.languageCode)) return 'languageCode: string expected';\n        return null;\n      };\n      /**\n       * Creates a LanguageOptions message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof SetOptions.LanguageOptions\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {SetOptions.LanguageOptions} LanguageOptions\n       */\n\n\n      LanguageOptions.fromObject = function fromObject(object) {\n        if (object instanceof $root.SetOptions.LanguageOptions) return object;\n        var message = new $root.SetOptions.LanguageOptions();\n        if (object.languageCode != null) message.languageCode = String(object.languageCode);\n        return message;\n      };\n      /**\n       * Creates a plain object from a LanguageOptions message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof SetOptions.LanguageOptions\n       * @static\n       * @param {SetOptions.LanguageOptions} message LanguageOptions\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n\n\n      LanguageOptions.toObject = function toObject(message, options) {\n        if (!options) options = {};\n        var object = {};\n        if (options.defaults) object.languageCode = '';\n        if (message.languageCode != null && message.hasOwnProperty('languageCode')) object.languageCode = message.languageCode;\n        return object;\n      };\n      /**\n       * Converts this LanguageOptions to JSON.\n       * @function toJSON\n       * @memberof SetOptions.LanguageOptions\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n\n\n      LanguageOptions.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      return LanguageOptions;\n    }();\n\n    SetOptions.ProfanityFilterOptions = function () {\n      /**\n       * Properties of a ProfanityFilterOptions.\n       * @memberof SetOptions\n       * @interface IProfanityFilterOptions\n       * @property {boolean|null} [enable] ProfanityFilterOptions enable\n       */\n\n      /**\n       * Constructs a new ProfanityFilterOptions.\n       * @memberof SetOptions\n       * @classdesc Represents a ProfanityFilterOptions.\n       * @implements IProfanityFilterOptions\n       * @constructor\n       * @param {SetOptions.IProfanityFilterOptions=} [properties] Properties to set\n       */\n      function ProfanityFilterOptions(properties) {\n        if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * ProfanityFilterOptions enable.\n       * @member {boolean} enable\n       * @memberof SetOptions.ProfanityFilterOptions\n       * @instance\n       */\n\n\n      ProfanityFilterOptions.prototype.enable = false;\n      /**\n       * Creates a new ProfanityFilterOptions instance using the specified properties.\n       * @function create\n       * @memberof SetOptions.ProfanityFilterOptions\n       * @static\n       * @param {SetOptions.IProfanityFilterOptions=} [properties] Properties to set\n       * @returns {SetOptions.ProfanityFilterOptions} ProfanityFilterOptions instance\n       */\n\n      ProfanityFilterOptions.create = function create(properties) {\n        return new ProfanityFilterOptions(properties);\n      };\n      /**\n       * Encodes the specified ProfanityFilterOptions message. Does not implicitly {@link SetOptions.ProfanityFilterOptions.verify|verify} messages.\n       * @function encode\n       * @memberof SetOptions.ProfanityFilterOptions\n       * @static\n       * @param {SetOptions.IProfanityFilterOptions} message ProfanityFilterOptions message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      ProfanityFilterOptions.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create();\n        if (message.enable != null && Object.hasOwnProperty.call(message, 'enable')) writer.uint32(\n        /* id 1, wireType 0 =*/\n        8).bool(message.enable);\n        return writer;\n      };\n      /**\n       * Encodes the specified ProfanityFilterOptions message, length delimited. Does not implicitly {@link SetOptions.ProfanityFilterOptions.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof SetOptions.ProfanityFilterOptions\n       * @static\n       * @param {SetOptions.IProfanityFilterOptions} message ProfanityFilterOptions message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      ProfanityFilterOptions.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n      /**\n       * Decodes a ProfanityFilterOptions message from the specified reader or buffer.\n       * @function decode\n       * @memberof SetOptions.ProfanityFilterOptions\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {SetOptions.ProfanityFilterOptions} ProfanityFilterOptions\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      ProfanityFilterOptions.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.SetOptions.ProfanityFilterOptions();\n\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              message.enable = reader.bool();\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n      /**\n       * Decodes a ProfanityFilterOptions message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof SetOptions.ProfanityFilterOptions\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {SetOptions.ProfanityFilterOptions} ProfanityFilterOptions\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      ProfanityFilterOptions.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n      };\n      /**\n       * Verifies a ProfanityFilterOptions message.\n       * @function verify\n       * @memberof SetOptions.ProfanityFilterOptions\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n\n\n      ProfanityFilterOptions.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected';\n        if (message.enable != null && message.hasOwnProperty('enable')) if (typeof message.enable !== 'boolean') return 'enable: boolean expected';\n        return null;\n      };\n      /**\n       * Creates a ProfanityFilterOptions message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof SetOptions.ProfanityFilterOptions\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {SetOptions.ProfanityFilterOptions} ProfanityFilterOptions\n       */\n\n\n      ProfanityFilterOptions.fromObject = function fromObject(object) {\n        if (object instanceof $root.SetOptions.ProfanityFilterOptions) return object;\n        var message = new $root.SetOptions.ProfanityFilterOptions();\n        if (object.enable != null) message.enable = Boolean(object.enable);\n        return message;\n      };\n      /**\n       * Creates a plain object from a ProfanityFilterOptions message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof SetOptions.ProfanityFilterOptions\n       * @static\n       * @param {SetOptions.ProfanityFilterOptions} message ProfanityFilterOptions\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n\n\n      ProfanityFilterOptions.toObject = function toObject(message, options) {\n        if (!options) options = {};\n        var object = {};\n        if (options.defaults) object.enable = false;\n        if (message.enable != null && message.hasOwnProperty('enable')) object.enable = message.enable;\n        return object;\n      };\n      /**\n       * Converts this ProfanityFilterOptions to JSON.\n       * @function toJSON\n       * @memberof SetOptions.ProfanityFilterOptions\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n\n\n      ProfanityFilterOptions.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      return ProfanityFilterOptions;\n    }();\n\n    SetOptions.NormalizationOptions = function () {\n      /**\n       * Properties of a NormalizationOptions.\n       * @memberof SetOptions\n       * @interface INormalizationOptions\n       * @property {boolean|null} [enable] NormalizationOptions enable\n       */\n\n      /**\n       * Constructs a new NormalizationOptions.\n       * @memberof SetOptions\n       * @classdesc Represents a NormalizationOptions.\n       * @implements INormalizationOptions\n       * @constructor\n       * @param {SetOptions.INormalizationOptions=} [properties] Properties to set\n       */\n      function NormalizationOptions(properties) {\n        if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * NormalizationOptions enable.\n       * @member {boolean} enable\n       * @memberof SetOptions.NormalizationOptions\n       * @instance\n       */\n\n\n      NormalizationOptions.prototype.enable = false;\n      /**\n       * Creates a new NormalizationOptions instance using the specified properties.\n       * @function create\n       * @memberof SetOptions.NormalizationOptions\n       * @static\n       * @param {SetOptions.INormalizationOptions=} [properties] Properties to set\n       * @returns {SetOptions.NormalizationOptions} NormalizationOptions instance\n       */\n\n      NormalizationOptions.create = function create(properties) {\n        return new NormalizationOptions(properties);\n      };\n      /**\n       * Encodes the specified NormalizationOptions message. Does not implicitly {@link SetOptions.NormalizationOptions.verify|verify} messages.\n       * @function encode\n       * @memberof SetOptions.NormalizationOptions\n       * @static\n       * @param {SetOptions.INormalizationOptions} message NormalizationOptions message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      NormalizationOptions.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create();\n        if (message.enable != null && Object.hasOwnProperty.call(message, 'enable')) writer.uint32(\n        /* id 1, wireType 0 =*/\n        8).bool(message.enable);\n        return writer;\n      };\n      /**\n       * Encodes the specified NormalizationOptions message, length delimited. Does not implicitly {@link SetOptions.NormalizationOptions.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof SetOptions.NormalizationOptions\n       * @static\n       * @param {SetOptions.INormalizationOptions} message NormalizationOptions message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      NormalizationOptions.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n      /**\n       * Decodes a NormalizationOptions message from the specified reader or buffer.\n       * @function decode\n       * @memberof SetOptions.NormalizationOptions\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {SetOptions.NormalizationOptions} NormalizationOptions\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      NormalizationOptions.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.SetOptions.NormalizationOptions();\n\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              message.enable = reader.bool();\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n      /**\n       * Decodes a NormalizationOptions message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof SetOptions.NormalizationOptions\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {SetOptions.NormalizationOptions} NormalizationOptions\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      NormalizationOptions.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n      };\n      /**\n       * Verifies a NormalizationOptions message.\n       * @function verify\n       * @memberof SetOptions.NormalizationOptions\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n\n\n      NormalizationOptions.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected';\n        if (message.enable != null && message.hasOwnProperty('enable')) if (typeof message.enable !== 'boolean') return 'enable: boolean expected';\n        return null;\n      };\n      /**\n       * Creates a NormalizationOptions message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof SetOptions.NormalizationOptions\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {SetOptions.NormalizationOptions} NormalizationOptions\n       */\n\n\n      NormalizationOptions.fromObject = function fromObject(object) {\n        if (object instanceof $root.SetOptions.NormalizationOptions) return object;\n        var message = new $root.SetOptions.NormalizationOptions();\n        if (object.enable != null) message.enable = Boolean(object.enable);\n        return message;\n      };\n      /**\n       * Creates a plain object from a NormalizationOptions message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof SetOptions.NormalizationOptions\n       * @static\n       * @param {SetOptions.NormalizationOptions} message NormalizationOptions\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n\n\n      NormalizationOptions.toObject = function toObject(message, options) {\n        if (!options) options = {};\n        var object = {};\n        if (options.defaults) object.enable = false;\n        if (message.enable != null && message.hasOwnProperty('enable')) object.enable = message.enable;\n        return object;\n      };\n      /**\n       * Converts this NormalizationOptions to JSON.\n       * @function toJSON\n       * @memberof SetOptions.NormalizationOptions\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n\n\n      NormalizationOptions.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      return NormalizationOptions;\n    }();\n\n    SetOptions.NBestOptions = function () {\n      /**\n       * Properties of a NBestOptions.\n       * @memberof SetOptions\n       * @interface INBestOptions\n       * @property {number|null} [count] NBestOptions count\n       */\n\n      /**\n       * Constructs a new NBestOptions.\n       * @memberof SetOptions\n       * @classdesc Represents a NBestOptions.\n       * @implements INBestOptions\n       * @constructor\n       * @param {SetOptions.INBestOptions=} [properties] Properties to set\n       */\n      function NBestOptions(properties) {\n        if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * NBestOptions count.\n       * @member {number} count\n       * @memberof SetOptions.NBestOptions\n       * @instance\n       */\n\n\n      NBestOptions.prototype.count = 0;\n      /**\n       * Creates a new NBestOptions instance using the specified properties.\n       * @function create\n       * @memberof SetOptions.NBestOptions\n       * @static\n       * @param {SetOptions.INBestOptions=} [properties] Properties to set\n       * @returns {SetOptions.NBestOptions} NBestOptions instance\n       */\n\n      NBestOptions.create = function create(properties) {\n        return new NBestOptions(properties);\n      };\n      /**\n       * Encodes the specified NBestOptions message. Does not implicitly {@link SetOptions.NBestOptions.verify|verify} messages.\n       * @function encode\n       * @memberof SetOptions.NBestOptions\n       * @static\n       * @param {SetOptions.INBestOptions} message NBestOptions message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      NBestOptions.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create();\n        if (message.count != null && Object.hasOwnProperty.call(message, 'count')) writer.uint32(\n        /* id 1, wireType 0 =*/\n        8).int32(message.count);\n        return writer;\n      };\n      /**\n       * Encodes the specified NBestOptions message, length delimited. Does not implicitly {@link SetOptions.NBestOptions.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof SetOptions.NBestOptions\n       * @static\n       * @param {SetOptions.INBestOptions} message NBestOptions message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      NBestOptions.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n      /**\n       * Decodes a NBestOptions message from the specified reader or buffer.\n       * @function decode\n       * @memberof SetOptions.NBestOptions\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {SetOptions.NBestOptions} NBestOptions\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      NBestOptions.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.SetOptions.NBestOptions();\n\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              message.count = reader.int32();\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n      /**\n       * Decodes a NBestOptions message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof SetOptions.NBestOptions\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {SetOptions.NBestOptions} NBestOptions\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      NBestOptions.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n      };\n      /**\n       * Verifies a NBestOptions message.\n       * @function verify\n       * @memberof SetOptions.NBestOptions\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n\n\n      NBestOptions.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected';\n        if (message.count != null && message.hasOwnProperty('count')) if (!$util.isInteger(message.count)) return 'count: integer expected';\n        return null;\n      };\n      /**\n       * Creates a NBestOptions message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof SetOptions.NBestOptions\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {SetOptions.NBestOptions} NBestOptions\n       */\n\n\n      NBestOptions.fromObject = function fromObject(object) {\n        if (object instanceof $root.SetOptions.NBestOptions) return object;\n        var message = new $root.SetOptions.NBestOptions();\n        if (object.count != null) message.count = object.count | 0;\n        return message;\n      };\n      /**\n       * Creates a plain object from a NBestOptions message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof SetOptions.NBestOptions\n       * @static\n       * @param {SetOptions.NBestOptions} message NBestOptions\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n\n\n      NBestOptions.toObject = function toObject(message, options) {\n        if (!options) options = {};\n        var object = {};\n        if (options.defaults) object.count = 0;\n        if (message.count != null && message.hasOwnProperty('count')) object.count = message.count;\n        return object;\n      };\n      /**\n       * Converts this NBestOptions to JSON.\n       * @function toJSON\n       * @memberof SetOptions.NBestOptions\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n\n\n      NBestOptions.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      return NBestOptions;\n    }();\n\n    SetOptions.ModelOptions = function () {\n      /**\n       * Properties of a ModelOptions.\n       * @memberof SetOptions\n       * @interface IModelOptions\n       * @property {string|null} [modelName] ModelOptions modelName\n       * @property {Array.<SetOptions.ModelOptions.IContext>|null} [contexts] ModelOptions contexts\n       */\n\n      /**\n       * Constructs a new ModelOptions.\n       * @memberof SetOptions\n       * @classdesc Represents a ModelOptions.\n       * @implements IModelOptions\n       * @constructor\n       * @param {SetOptions.IModelOptions=} [properties] Properties to set\n       */\n      function ModelOptions(properties) {\n        this.contexts = [];\n        if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * ModelOptions modelName.\n       * @member {string} modelName\n       * @memberof SetOptions.ModelOptions\n       * @instance\n       */\n\n\n      ModelOptions.prototype.modelName = '';\n      /**\n       * ModelOptions contexts.\n       * @member {Array.<SetOptions.ModelOptions.IContext>} contexts\n       * @memberof SetOptions.ModelOptions\n       * @instance\n       */\n\n      ModelOptions.prototype.contexts = $util.emptyArray;\n      /**\n       * Creates a new ModelOptions instance using the specified properties.\n       * @function create\n       * @memberof SetOptions.ModelOptions\n       * @static\n       * @param {SetOptions.IModelOptions=} [properties] Properties to set\n       * @returns {SetOptions.ModelOptions} ModelOptions instance\n       */\n\n      ModelOptions.create = function create(properties) {\n        return new ModelOptions(properties);\n      };\n      /**\n       * Encodes the specified ModelOptions message. Does not implicitly {@link SetOptions.ModelOptions.verify|verify} messages.\n       * @function encode\n       * @memberof SetOptions.ModelOptions\n       * @static\n       * @param {SetOptions.IModelOptions} message ModelOptions message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      ModelOptions.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create();\n        if (message.modelName != null && Object.hasOwnProperty.call(message, 'modelName')) writer.uint32(\n        /* id 1, wireType 2 =*/\n        10).string(message.modelName);\n        if (message.contexts != null && message.contexts.length) for (var i = 0; i < message.contexts.length; ++i) $root.SetOptions.ModelOptions.Context.encode(message.contexts[i], writer.uint32(\n        /* id 2, wireType 2 =*/\n        18).fork()).ldelim();\n        return writer;\n      };\n      /**\n       * Encodes the specified ModelOptions message, length delimited. Does not implicitly {@link SetOptions.ModelOptions.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof SetOptions.ModelOptions\n       * @static\n       * @param {SetOptions.IModelOptions} message ModelOptions message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      ModelOptions.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n      /**\n       * Decodes a ModelOptions message from the specified reader or buffer.\n       * @function decode\n       * @memberof SetOptions.ModelOptions\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {SetOptions.ModelOptions} ModelOptions\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      ModelOptions.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.SetOptions.ModelOptions();\n\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              message.modelName = reader.string();\n              break;\n\n            case 2:\n              if (!(message.contexts && message.contexts.length)) message.contexts = [];\n              message.contexts.push($root.SetOptions.ModelOptions.Context.decode(reader, reader.uint32()));\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n      /**\n       * Decodes a ModelOptions message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof SetOptions.ModelOptions\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {SetOptions.ModelOptions} ModelOptions\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      ModelOptions.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n      };\n      /**\n       * Verifies a ModelOptions message.\n       * @function verify\n       * @memberof SetOptions.ModelOptions\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n\n\n      ModelOptions.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected';\n        if (message.modelName != null && message.hasOwnProperty('modelName')) if (!$util.isString(message.modelName)) return 'modelName: string expected';\n\n        if (message.contexts != null && message.hasOwnProperty('contexts')) {\n          if (!Array.isArray(message.contexts)) return 'contexts: array expected';\n\n          for (var i = 0; i < message.contexts.length; ++i) {\n            var error = $root.SetOptions.ModelOptions.Context.verify(message.contexts[i]);\n            if (error) return 'contexts.' + error;\n          }\n        }\n\n        return null;\n      };\n      /**\n       * Creates a ModelOptions message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof SetOptions.ModelOptions\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {SetOptions.ModelOptions} ModelOptions\n       */\n\n\n      ModelOptions.fromObject = function fromObject(object) {\n        if (object instanceof $root.SetOptions.ModelOptions) return object;\n        var message = new $root.SetOptions.ModelOptions();\n        if (object.modelName != null) message.modelName = String(object.modelName);\n\n        if (object.contexts) {\n          if (!Array.isArray(object.contexts)) throw TypeError('.SetOptions.ModelOptions.contexts: array expected');\n          message.contexts = [];\n\n          for (var i = 0; i < object.contexts.length; ++i) {\n            if (typeof object.contexts[i] !== 'object') throw TypeError('.SetOptions.ModelOptions.contexts: object expected');\n            message.contexts[i] = $root.SetOptions.ModelOptions.Context.fromObject(object.contexts[i]);\n          }\n        }\n\n        return message;\n      };\n      /**\n       * Creates a plain object from a ModelOptions message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof SetOptions.ModelOptions\n       * @static\n       * @param {SetOptions.ModelOptions} message ModelOptions\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n\n\n      ModelOptions.toObject = function toObject(message, options) {\n        if (!options) options = {};\n        var object = {};\n        if (options.arrays || options.defaults) object.contexts = [];\n        if (options.defaults) object.modelName = '';\n        if (message.modelName != null && message.hasOwnProperty('modelName')) object.modelName = message.modelName;\n\n        if (message.contexts && message.contexts.length) {\n          object.contexts = [];\n\n          for (var j = 0; j < message.contexts.length; ++j) object.contexts[j] = $root.SetOptions.ModelOptions.Context.toObject(message.contexts[j], options);\n        }\n\n        return object;\n      };\n      /**\n       * Converts this ModelOptions to JSON.\n       * @function toJSON\n       * @memberof SetOptions.ModelOptions\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n\n\n      ModelOptions.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      ModelOptions.Context = function () {\n        /**\n         * Properties of a Context.\n         * @memberof SetOptions.ModelOptions\n         * @interface IContext\n         * @property {string|null} [id] Context id\n         * @property {SetOptions.ModelOptions.Context.ContextType|null} [contextType] Context contextType\n         * @property {Array.<string>|null} [prefixes] Context prefixes\n         * @property {Array.<string>|null} [values] Context values\n         */\n\n        /**\n         * Constructs a new Context.\n         * @memberof SetOptions.ModelOptions\n         * @classdesc Represents a Context.\n         * @implements IContext\n         * @constructor\n         * @param {SetOptions.ModelOptions.IContext=} [properties] Properties to set\n         */\n        function Context(properties) {\n          this.prefixes = [];\n          this.values = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * Context id.\n         * @member {string} id\n         * @memberof SetOptions.ModelOptions.Context\n         * @instance\n         */\n\n\n        Context.prototype.id = '';\n        /**\n         * Context contextType.\n         * @member {SetOptions.ModelOptions.Context.ContextType} contextType\n         * @memberof SetOptions.ModelOptions.Context\n         * @instance\n         */\n\n        Context.prototype.contextType = 0;\n        /**\n         * Context prefixes.\n         * @member {Array.<string>} prefixes\n         * @memberof SetOptions.ModelOptions.Context\n         * @instance\n         */\n\n        Context.prototype.prefixes = $util.emptyArray;\n        /**\n         * Context values.\n         * @member {Array.<string>} values\n         * @memberof SetOptions.ModelOptions.Context\n         * @instance\n         */\n\n        Context.prototype.values = $util.emptyArray;\n        /**\n         * Creates a new Context instance using the specified properties.\n         * @function create\n         * @memberof SetOptions.ModelOptions.Context\n         * @static\n         * @param {SetOptions.ModelOptions.IContext=} [properties] Properties to set\n         * @returns {SetOptions.ModelOptions.Context} Context instance\n         */\n\n        Context.create = function create(properties) {\n          return new Context(properties);\n        };\n        /**\n         * Encodes the specified Context message. Does not implicitly {@link SetOptions.ModelOptions.Context.verify|verify} messages.\n         * @function encode\n         * @memberof SetOptions.ModelOptions.Context\n         * @static\n         * @param {SetOptions.ModelOptions.IContext} message Context message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Context.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).string(message.id);\n          if (message.contextType != null && Object.hasOwnProperty.call(message, 'contextType')) writer.uint32(\n          /* id 2, wireType 0 =*/\n          16).int32(message.contextType);\n          if (message.prefixes != null && message.prefixes.length) for (var i = 0; i < message.prefixes.length; ++i) writer.uint32(\n          /* id 3, wireType 2 =*/\n          26).string(message.prefixes[i]);\n          if (message.values != null && message.values.length) for (var i = 0; i < message.values.length; ++i) writer.uint32(\n          /* id 4, wireType 2 =*/\n          34).string(message.values[i]);\n          return writer;\n        };\n        /**\n         * Encodes the specified Context message, length delimited. Does not implicitly {@link SetOptions.ModelOptions.Context.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof SetOptions.ModelOptions.Context\n         * @static\n         * @param {SetOptions.ModelOptions.IContext} message Context message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        Context.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a Context message from the specified reader or buffer.\n         * @function decode\n         * @memberof SetOptions.ModelOptions.Context\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {SetOptions.ModelOptions.Context} Context\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Context.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.SetOptions.ModelOptions.Context();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.id = reader.string();\n                break;\n\n              case 2:\n                message.contextType = reader.int32();\n                break;\n\n              case 3:\n                if (!(message.prefixes && message.prefixes.length)) message.prefixes = [];\n                message.prefixes.push(reader.string());\n                break;\n\n              case 4:\n                if (!(message.values && message.values.length)) message.values = [];\n                message.values.push(reader.string());\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a Context message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof SetOptions.ModelOptions.Context\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {SetOptions.ModelOptions.Context} Context\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        Context.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a Context message.\n         * @function verify\n         * @memberof SetOptions.ModelOptions.Context\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        Context.verify = function verify(message) {\n          if (typeof message !== 'object' || message === null) return 'object expected';\n          if (message.id != null && message.hasOwnProperty('id')) if (!$util.isString(message.id)) return 'id: string expected';\n          if (message.contextType != null && message.hasOwnProperty('contextType')) switch (message.contextType) {\n            default:\n              return 'contextType: enum value expected';\n\n            case 0:\n            case 1:\n              break;\n          }\n\n          if (message.prefixes != null && message.hasOwnProperty('prefixes')) {\n            if (!Array.isArray(message.prefixes)) return 'prefixes: array expected';\n\n            for (var i = 0; i < message.prefixes.length; ++i) if (!$util.isString(message.prefixes[i])) return 'prefixes: string[] expected';\n          }\n\n          if (message.values != null && message.hasOwnProperty('values')) {\n            if (!Array.isArray(message.values)) return 'values: array expected';\n\n            for (var i = 0; i < message.values.length; ++i) if (!$util.isString(message.values[i])) return 'values: string[] expected';\n          }\n\n          return null;\n        };\n        /**\n         * Creates a Context message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof SetOptions.ModelOptions.Context\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {SetOptions.ModelOptions.Context} Context\n         */\n\n\n        Context.fromObject = function fromObject(object) {\n          if (object instanceof $root.SetOptions.ModelOptions.Context) return object;\n          var message = new $root.SetOptions.ModelOptions.Context();\n          if (object.id != null) message.id = String(object.id);\n\n          switch (object.contextType) {\n            case 'GENERAL':\n            case 0:\n              message.contextType = 0;\n              break;\n\n            case 'ADDRESSBOOK':\n            case 1:\n              message.contextType = 1;\n              break;\n          }\n\n          if (object.prefixes) {\n            if (!Array.isArray(object.prefixes)) throw TypeError('.SetOptions.ModelOptions.Context.prefixes: array expected');\n            message.prefixes = [];\n\n            for (var i = 0; i < object.prefixes.length; ++i) message.prefixes[i] = String(object.prefixes[i]);\n          }\n\n          if (object.values) {\n            if (!Array.isArray(object.values)) throw TypeError('.SetOptions.ModelOptions.Context.values: array expected');\n            message.values = [];\n\n            for (var i = 0; i < object.values.length; ++i) message.values[i] = String(object.values[i]);\n          }\n\n          return message;\n        };\n        /**\n         * Creates a plain object from a Context message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof SetOptions.ModelOptions.Context\n         * @static\n         * @param {SetOptions.ModelOptions.Context} message Context\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        Context.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.arrays || options.defaults) {\n            object.prefixes = [];\n            object.values = [];\n          }\n\n          if (options.defaults) {\n            object.id = '';\n            object.contextType = options.enums === String ? 'GENERAL' : 0;\n          }\n\n          if (message.id != null && message.hasOwnProperty('id')) object.id = message.id;\n          if (message.contextType != null && message.hasOwnProperty('contextType')) object.contextType = options.enums === String ? $root.SetOptions.ModelOptions.Context.ContextType[message.contextType] : message.contextType;\n\n          if (message.prefixes && message.prefixes.length) {\n            object.prefixes = [];\n\n            for (var j = 0; j < message.prefixes.length; ++j) object.prefixes[j] = message.prefixes[j];\n          }\n\n          if (message.values && message.values.length) {\n            object.values = [];\n\n            for (var j = 0; j < message.values.length; ++j) object.values[j] = message.values[j];\n          }\n\n          return object;\n        };\n        /**\n         * Converts this Context to JSON.\n         * @function toJSON\n         * @memberof SetOptions.ModelOptions.Context\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        Context.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        /**\n         * ContextType enum.\n         * @name SetOptions.ModelOptions.Context.ContextType\n         * @enum {number}\n         * @property {number} GENERAL=0 GENERAL value\n         * @property {number} ADDRESSBOOK=1 ADDRESSBOOK value\n         */\n\n\n        Context.ContextType = function () {\n          var valuesById = {},\n              values = Object.create(valuesById);\n          values[valuesById[0] = 'GENERAL'] = 0;\n          values[valuesById[1] = 'ADDRESSBOOK'] = 1;\n          return values;\n        }();\n\n        return Context;\n      }();\n\n      return ModelOptions;\n    }();\n\n    return SetOptions;\n  }();\n\n  $root.UndecodedSeconds = function () {\n    /**\n     * Properties of an UndecodedSeconds.\n     * @exports IUndecodedSeconds\n     * @interface IUndecodedSeconds\n     * @property {number|null} [undecodedSeconds] UndecodedSeconds undecodedSeconds\n     */\n\n    /**\n     * Constructs a new UndecodedSeconds.\n     * @exports UndecodedSeconds\n     * @classdesc Represents an UndecodedSeconds.\n     * @implements IUndecodedSeconds\n     * @constructor\n     * @param {IUndecodedSeconds=} [properties] Properties to set\n     */\n    function UndecodedSeconds(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * UndecodedSeconds undecodedSeconds.\n     * @member {number} undecodedSeconds\n     * @memberof UndecodedSeconds\n     * @instance\n     */\n\n\n    UndecodedSeconds.prototype.undecodedSeconds = 0;\n    /**\n     * Creates a new UndecodedSeconds instance using the specified properties.\n     * @function create\n     * @memberof UndecodedSeconds\n     * @static\n     * @param {IUndecodedSeconds=} [properties] Properties to set\n     * @returns {UndecodedSeconds} UndecodedSeconds instance\n     */\n\n    UndecodedSeconds.create = function create(properties) {\n      return new UndecodedSeconds(properties);\n    };\n    /**\n     * Encodes the specified UndecodedSeconds message. Does not implicitly {@link UndecodedSeconds.verify|verify} messages.\n     * @function encode\n     * @memberof UndecodedSeconds\n     * @static\n     * @param {IUndecodedSeconds} message UndecodedSeconds message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    UndecodedSeconds.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.undecodedSeconds != null && Object.hasOwnProperty.call(message, 'undecodedSeconds')) writer.uint32(\n      /* id 1, wireType 5 =*/\n      13).float(message.undecodedSeconds);\n      return writer;\n    };\n    /**\n     * Encodes the specified UndecodedSeconds message, length delimited. Does not implicitly {@link UndecodedSeconds.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof UndecodedSeconds\n     * @static\n     * @param {IUndecodedSeconds} message UndecodedSeconds message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    UndecodedSeconds.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes an UndecodedSeconds message from the specified reader or buffer.\n     * @function decode\n     * @memberof UndecodedSeconds\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {UndecodedSeconds} UndecodedSeconds\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    UndecodedSeconds.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.UndecodedSeconds();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.undecodedSeconds = reader.float();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes an UndecodedSeconds message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof UndecodedSeconds\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {UndecodedSeconds} UndecodedSeconds\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    UndecodedSeconds.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies an UndecodedSeconds message.\n     * @function verify\n     * @memberof UndecodedSeconds\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    UndecodedSeconds.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      if (message.undecodedSeconds != null && message.hasOwnProperty('undecodedSeconds')) if (typeof message.undecodedSeconds !== 'number') return 'undecodedSeconds: number expected';\n      return null;\n    };\n    /**\n     * Creates an UndecodedSeconds message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof UndecodedSeconds\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {UndecodedSeconds} UndecodedSeconds\n     */\n\n\n    UndecodedSeconds.fromObject = function fromObject(object) {\n      if (object instanceof $root.UndecodedSeconds) return object;\n      var message = new $root.UndecodedSeconds();\n      if (object.undecodedSeconds != null) message.undecodedSeconds = Number(object.undecodedSeconds);\n      return message;\n    };\n    /**\n     * Creates a plain object from an UndecodedSeconds message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof UndecodedSeconds\n     * @static\n     * @param {UndecodedSeconds} message UndecodedSeconds\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    UndecodedSeconds.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.defaults) object.undecodedSeconds = 0;\n      if (message.undecodedSeconds != null && message.hasOwnProperty('undecodedSeconds')) object.undecodedSeconds = options.json && !isFinite(message.undecodedSeconds) ? String(message.undecodedSeconds) : message.undecodedSeconds;\n      return object;\n    };\n    /**\n     * Converts this UndecodedSeconds to JSON.\n     * @function toJSON\n     * @memberof UndecodedSeconds\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    UndecodedSeconds.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return UndecodedSeconds;\n  }();\n\n  $root.FullyFinalized = function () {\n    /**\n     * Properties of a FullyFinalized.\n     * @exports IFullyFinalized\n     * @interface IFullyFinalized\n     */\n\n    /**\n     * Constructs a new FullyFinalized.\n     * @exports FullyFinalized\n     * @classdesc Represents a FullyFinalized.\n     * @implements IFullyFinalized\n     * @constructor\n     * @param {IFullyFinalized=} [properties] Properties to set\n     */\n    function FullyFinalized(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * Creates a new FullyFinalized instance using the specified properties.\n     * @function create\n     * @memberof FullyFinalized\n     * @static\n     * @param {IFullyFinalized=} [properties] Properties to set\n     * @returns {FullyFinalized} FullyFinalized instance\n     */\n\n\n    FullyFinalized.create = function create(properties) {\n      return new FullyFinalized(properties);\n    };\n    /**\n     * Encodes the specified FullyFinalized message. Does not implicitly {@link FullyFinalized.verify|verify} messages.\n     * @function encode\n     * @memberof FullyFinalized\n     * @static\n     * @param {IFullyFinalized} message FullyFinalized message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    FullyFinalized.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      return writer;\n    };\n    /**\n     * Encodes the specified FullyFinalized message, length delimited. Does not implicitly {@link FullyFinalized.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof FullyFinalized\n     * @static\n     * @param {IFullyFinalized} message FullyFinalized message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    FullyFinalized.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a FullyFinalized message from the specified reader or buffer.\n     * @function decode\n     * @memberof FullyFinalized\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {FullyFinalized} FullyFinalized\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    FullyFinalized.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.FullyFinalized();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a FullyFinalized message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof FullyFinalized\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {FullyFinalized} FullyFinalized\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    FullyFinalized.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a FullyFinalized message.\n     * @function verify\n     * @memberof FullyFinalized\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    FullyFinalized.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      return null;\n    };\n    /**\n     * Creates a FullyFinalized message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof FullyFinalized\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {FullyFinalized} FullyFinalized\n     */\n\n\n    FullyFinalized.fromObject = function fromObject(object) {\n      if (object instanceof $root.FullyFinalized) return object;\n      return new $root.FullyFinalized();\n    };\n    /**\n     * Creates a plain object from a FullyFinalized message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof FullyFinalized\n     * @static\n     * @param {FullyFinalized} message FullyFinalized\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    FullyFinalized.toObject = function toObject() {\n      return {};\n    };\n    /**\n     * Converts this FullyFinalized to JSON.\n     * @function toJSON\n     * @memberof FullyFinalized\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    FullyFinalized.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return FullyFinalized;\n  }();\n\n  $root.EmotionResult = function () {\n    /**\n     * Properties of an EmotionResult.\n     * @exports IEmotionResult\n     * @interface IEmotionResult\n     * @property {string|null} [name] EmotionResult name\n     * @property {number|null} [confidence] EmotionResult confidence\n     */\n\n    /**\n     * Constructs a new EmotionResult.\n     * @exports EmotionResult\n     * @classdesc Represents an EmotionResult.\n     * @implements IEmotionResult\n     * @constructor\n     * @param {IEmotionResult=} [properties] Properties to set\n     */\n    function EmotionResult(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * EmotionResult name.\n     * @member {string} name\n     * @memberof EmotionResult\n     * @instance\n     */\n\n\n    EmotionResult.prototype.name = '';\n    /**\n     * EmotionResult confidence.\n     * @member {number} confidence\n     * @memberof EmotionResult\n     * @instance\n     */\n\n    EmotionResult.prototype.confidence = 0;\n    /**\n     * Creates a new EmotionResult instance using the specified properties.\n     * @function create\n     * @memberof EmotionResult\n     * @static\n     * @param {IEmotionResult=} [properties] Properties to set\n     * @returns {EmotionResult} EmotionResult instance\n     */\n\n    EmotionResult.create = function create(properties) {\n      return new EmotionResult(properties);\n    };\n    /**\n     * Encodes the specified EmotionResult message. Does not implicitly {@link EmotionResult.verify|verify} messages.\n     * @function encode\n     * @memberof EmotionResult\n     * @static\n     * @param {IEmotionResult} message EmotionResult message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    EmotionResult.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.name != null && Object.hasOwnProperty.call(message, 'name')) writer.uint32(\n      /* id 1, wireType 2 =*/\n      10).string(message.name);\n      if (message.confidence != null && Object.hasOwnProperty.call(message, 'confidence')) writer.uint32(\n      /* id 2, wireType 5 =*/\n      21).float(message.confidence);\n      return writer;\n    };\n    /**\n     * Encodes the specified EmotionResult message, length delimited. Does not implicitly {@link EmotionResult.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof EmotionResult\n     * @static\n     * @param {IEmotionResult} message EmotionResult message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    EmotionResult.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes an EmotionResult message from the specified reader or buffer.\n     * @function decode\n     * @memberof EmotionResult\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {EmotionResult} EmotionResult\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    EmotionResult.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.EmotionResult();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.name = reader.string();\n            break;\n\n          case 2:\n            message.confidence = reader.float();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes an EmotionResult message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof EmotionResult\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {EmotionResult} EmotionResult\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    EmotionResult.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies an EmotionResult message.\n     * @function verify\n     * @memberof EmotionResult\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    EmotionResult.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      if (message.name != null && message.hasOwnProperty('name')) if (!$util.isString(message.name)) return 'name: string expected';\n      if (message.confidence != null && message.hasOwnProperty('confidence')) if (typeof message.confidence !== 'number') return 'confidence: number expected';\n      return null;\n    };\n    /**\n     * Creates an EmotionResult message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof EmotionResult\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {EmotionResult} EmotionResult\n     */\n\n\n    EmotionResult.fromObject = function fromObject(object) {\n      if (object instanceof $root.EmotionResult) return object;\n      var message = new $root.EmotionResult();\n      if (object.name != null) message.name = String(object.name);\n      if (object.confidence != null) message.confidence = Number(object.confidence);\n      return message;\n    };\n    /**\n     * Creates a plain object from an EmotionResult message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof EmotionResult\n     * @static\n     * @param {EmotionResult} message EmotionResult\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    EmotionResult.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n\n      if (options.defaults) {\n        object.name = '';\n        object.confidence = 0;\n      }\n\n      if (message.name != null && message.hasOwnProperty('name')) object.name = message.name;\n      if (message.confidence != null && message.hasOwnProperty('confidence')) object.confidence = options.json && !isFinite(message.confidence) ? String(message.confidence) : message.confidence;\n      return object;\n    };\n    /**\n     * Converts this EmotionResult to JSON.\n     * @function toJSON\n     * @memberof EmotionResult\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    EmotionResult.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return EmotionResult;\n  }();\n\n  $root.Hypothesis = function () {\n    /**\n     * Properties of a Hypothesis.\n     * @exports IHypothesis\n     * @interface IHypothesis\n     * @property {string|null} [words] Hypothesis words\n     * @property {number|null} [acousticCost] Hypothesis acousticCost\n     * @property {number|null} [linguisticCost] Hypothesis linguisticCost\n     * @property {number|null} [finalCost] Hypothesis finalCost\n     * @property {number|null} [phraseStart] Hypothesis phraseStart\n     * @property {number|null} [phraseEnd] Hypothesis phraseEnd\n     * @property {string|null} [normalizedText] Hypothesis normalizedText\n     */\n\n    /**\n     * Constructs a new Hypothesis.\n     * @exports Hypothesis\n     * @classdesc Represents a Hypothesis.\n     * @implements IHypothesis\n     * @constructor\n     * @param {IHypothesis=} [properties] Properties to set\n     */\n    function Hypothesis(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * Hypothesis words.\n     * @member {string} words\n     * @memberof Hypothesis\n     * @instance\n     */\n\n\n    Hypothesis.prototype.words = '';\n    /**\n     * Hypothesis acousticCost.\n     * @member {number} acousticCost\n     * @memberof Hypothesis\n     * @instance\n     */\n\n    Hypothesis.prototype.acousticCost = 0;\n    /**\n     * Hypothesis linguisticCost.\n     * @member {number} linguisticCost\n     * @memberof Hypothesis\n     * @instance\n     */\n\n    Hypothesis.prototype.linguisticCost = 0;\n    /**\n     * Hypothesis finalCost.\n     * @member {number} finalCost\n     * @memberof Hypothesis\n     * @instance\n     */\n\n    Hypothesis.prototype.finalCost = 0;\n    /**\n     * Hypothesis phraseStart.\n     * @member {number} phraseStart\n     * @memberof Hypothesis\n     * @instance\n     */\n\n    Hypothesis.prototype.phraseStart = 0;\n    /**\n     * Hypothesis phraseEnd.\n     * @member {number} phraseEnd\n     * @memberof Hypothesis\n     * @instance\n     */\n\n    Hypothesis.prototype.phraseEnd = 0;\n    /**\n     * Hypothesis normalizedText.\n     * @member {string} normalizedText\n     * @memberof Hypothesis\n     * @instance\n     */\n\n    Hypothesis.prototype.normalizedText = '';\n    /**\n     * Creates a new Hypothesis instance using the specified properties.\n     * @function create\n     * @memberof Hypothesis\n     * @static\n     * @param {IHypothesis=} [properties] Properties to set\n     * @returns {Hypothesis} Hypothesis instance\n     */\n\n    Hypothesis.create = function create(properties) {\n      return new Hypothesis(properties);\n    };\n    /**\n     * Encodes the specified Hypothesis message. Does not implicitly {@link Hypothesis.verify|verify} messages.\n     * @function encode\n     * @memberof Hypothesis\n     * @static\n     * @param {IHypothesis} message Hypothesis message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    Hypothesis.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.words != null && Object.hasOwnProperty.call(message, 'words')) writer.uint32(\n      /* id 1, wireType 2 =*/\n      10).string(message.words);\n      if (message.acousticCost != null && Object.hasOwnProperty.call(message, 'acousticCost')) writer.uint32(\n      /* id 2, wireType 5 =*/\n      21).float(message.acousticCost);\n      if (message.linguisticCost != null && Object.hasOwnProperty.call(message, 'linguisticCost')) writer.uint32(\n      /* id 3, wireType 5 =*/\n      29).float(message.linguisticCost);\n      if (message.finalCost != null && Object.hasOwnProperty.call(message, 'finalCost')) writer.uint32(\n      /* id 4, wireType 5 =*/\n      37).float(message.finalCost);\n      if (message.phraseStart != null && Object.hasOwnProperty.call(message, 'phraseStart')) writer.uint32(\n      /* id 5, wireType 5 =*/\n      45).float(message.phraseStart);\n      if (message.phraseEnd != null && Object.hasOwnProperty.call(message, 'phraseEnd')) writer.uint32(\n      /* id 6, wireType 5 =*/\n      53).float(message.phraseEnd);\n      if (message.normalizedText != null && Object.hasOwnProperty.call(message, 'normalizedText')) writer.uint32(\n      /* id 7, wireType 2 =*/\n      58).string(message.normalizedText);\n      return writer;\n    };\n    /**\n     * Encodes the specified Hypothesis message, length delimited. Does not implicitly {@link Hypothesis.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Hypothesis\n     * @static\n     * @param {IHypothesis} message Hypothesis message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    Hypothesis.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a Hypothesis message from the specified reader or buffer.\n     * @function decode\n     * @memberof Hypothesis\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Hypothesis} Hypothesis\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    Hypothesis.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.Hypothesis();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.words = reader.string();\n            break;\n\n          case 2:\n            message.acousticCost = reader.float();\n            break;\n\n          case 3:\n            message.linguisticCost = reader.float();\n            break;\n\n          case 4:\n            message.finalCost = reader.float();\n            break;\n\n          case 5:\n            message.phraseStart = reader.float();\n            break;\n\n          case 6:\n            message.phraseEnd = reader.float();\n            break;\n\n          case 7:\n            message.normalizedText = reader.string();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a Hypothesis message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Hypothesis\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Hypothesis} Hypothesis\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    Hypothesis.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a Hypothesis message.\n     * @function verify\n     * @memberof Hypothesis\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    Hypothesis.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      if (message.words != null && message.hasOwnProperty('words')) if (!$util.isString(message.words)) return 'words: string expected';\n      if (message.acousticCost != null && message.hasOwnProperty('acousticCost')) if (typeof message.acousticCost !== 'number') return 'acousticCost: number expected';\n      if (message.linguisticCost != null && message.hasOwnProperty('linguisticCost')) if (typeof message.linguisticCost !== 'number') return 'linguisticCost: number expected';\n      if (message.finalCost != null && message.hasOwnProperty('finalCost')) if (typeof message.finalCost !== 'number') return 'finalCost: number expected';\n      if (message.phraseStart != null && message.hasOwnProperty('phraseStart')) if (typeof message.phraseStart !== 'number') return 'phraseStart: number expected';\n      if (message.phraseEnd != null && message.hasOwnProperty('phraseEnd')) if (typeof message.phraseEnd !== 'number') return 'phraseEnd: number expected';\n      if (message.normalizedText != null && message.hasOwnProperty('normalizedText')) if (!$util.isString(message.normalizedText)) return 'normalizedText: string expected';\n      return null;\n    };\n    /**\n     * Creates a Hypothesis message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Hypothesis\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {Hypothesis} Hypothesis\n     */\n\n\n    Hypothesis.fromObject = function fromObject(object) {\n      if (object instanceof $root.Hypothesis) return object;\n      var message = new $root.Hypothesis();\n      if (object.words != null) message.words = String(object.words);\n      if (object.acousticCost != null) message.acousticCost = Number(object.acousticCost);\n      if (object.linguisticCost != null) message.linguisticCost = Number(object.linguisticCost);\n      if (object.finalCost != null) message.finalCost = Number(object.finalCost);\n      if (object.phraseStart != null) message.phraseStart = Number(object.phraseStart);\n      if (object.phraseEnd != null) message.phraseEnd = Number(object.phraseEnd);\n      if (object.normalizedText != null) message.normalizedText = String(object.normalizedText);\n      return message;\n    };\n    /**\n     * Creates a plain object from a Hypothesis message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Hypothesis\n     * @static\n     * @param {Hypothesis} message Hypothesis\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    Hypothesis.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n\n      if (options.defaults) {\n        object.words = '';\n        object.acousticCost = 0;\n        object.linguisticCost = 0;\n        object.finalCost = 0;\n        object.phraseStart = 0;\n        object.phraseEnd = 0;\n        object.normalizedText = '';\n      }\n\n      if (message.words != null && message.hasOwnProperty('words')) object.words = message.words;\n      if (message.acousticCost != null && message.hasOwnProperty('acousticCost')) object.acousticCost = options.json && !isFinite(message.acousticCost) ? String(message.acousticCost) : message.acousticCost;\n      if (message.linguisticCost != null && message.hasOwnProperty('linguisticCost')) object.linguisticCost = options.json && !isFinite(message.linguisticCost) ? String(message.linguisticCost) : message.linguisticCost;\n      if (message.finalCost != null && message.hasOwnProperty('finalCost')) object.finalCost = options.json && !isFinite(message.finalCost) ? String(message.finalCost) : message.finalCost;\n      if (message.phraseStart != null && message.hasOwnProperty('phraseStart')) object.phraseStart = options.json && !isFinite(message.phraseStart) ? String(message.phraseStart) : message.phraseStart;\n      if (message.phraseEnd != null && message.hasOwnProperty('phraseEnd')) object.phraseEnd = options.json && !isFinite(message.phraseEnd) ? String(message.phraseEnd) : message.phraseEnd;\n      if (message.normalizedText != null && message.hasOwnProperty('normalizedText')) object.normalizedText = message.normalizedText;\n      return object;\n    };\n    /**\n     * Converts this Hypothesis to JSON.\n     * @function toJSON\n     * @memberof Hypothesis\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    Hypothesis.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return Hypothesis;\n  }();\n\n  $root.DecoderResult = function () {\n    /**\n     * Properties of a DecoderResult.\n     * @exports IDecoderResult\n     * @interface IDecoderResult\n     * @property {Array.<IHypothesis>|null} [hypothesis] DecoderResult hypothesis\n     * @property {number|null} [chunkStart] DecoderResult chunkStart\n     * @property {number|null} [chunkEnd] DecoderResult chunkEnd\n     * @property {number|null} [timeEndpointDetectionMs] DecoderResult timeEndpointDetectionMs\n     * @property {number|null} [timeDecodingMs] DecoderResult timeDecodingMs\n     * @property {IVariables|null} [variables] DecoderResult variables\n     * @property {boolean|null} [isFinal] DecoderResult isFinal\n     * @property {Array.<IEmotionResult>|null} [emotionResult] DecoderResult emotionResult\n     * @property {Array.<DecoderResult.IContextAnswer>|null} [contextAnswer] DecoderResult contextAnswer\n     */\n\n    /**\n     * Constructs a new DecoderResult.\n     * @exports DecoderResult\n     * @classdesc Represents a DecoderResult.\n     * @implements IDecoderResult\n     * @constructor\n     * @param {IDecoderResult=} [properties] Properties to set\n     */\n    function DecoderResult(properties) {\n      this.hypothesis = [];\n      this.emotionResult = [];\n      this.contextAnswer = [];\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * DecoderResult hypothesis.\n     * @member {Array.<IHypothesis>} hypothesis\n     * @memberof DecoderResult\n     * @instance\n     */\n\n\n    DecoderResult.prototype.hypothesis = $util.emptyArray;\n    /**\n     * DecoderResult chunkStart.\n     * @member {number} chunkStart\n     * @memberof DecoderResult\n     * @instance\n     */\n\n    DecoderResult.prototype.chunkStart = 0;\n    /**\n     * DecoderResult chunkEnd.\n     * @member {number} chunkEnd\n     * @memberof DecoderResult\n     * @instance\n     */\n\n    DecoderResult.prototype.chunkEnd = 0;\n    /**\n     * DecoderResult timeEndpointDetectionMs.\n     * @member {number} timeEndpointDetectionMs\n     * @memberof DecoderResult\n     * @instance\n     */\n\n    DecoderResult.prototype.timeEndpointDetectionMs = 0;\n    /**\n     * DecoderResult timeDecodingMs.\n     * @member {number} timeDecodingMs\n     * @memberof DecoderResult\n     * @instance\n     */\n\n    DecoderResult.prototype.timeDecodingMs = 0;\n    /**\n     * DecoderResult variables.\n     * @member {IVariables|null|undefined} variables\n     * @memberof DecoderResult\n     * @instance\n     */\n\n    DecoderResult.prototype.variables = null;\n    /**\n     * DecoderResult isFinal.\n     * @member {boolean} isFinal\n     * @memberof DecoderResult\n     * @instance\n     */\n\n    DecoderResult.prototype.isFinal = false;\n    /**\n     * DecoderResult emotionResult.\n     * @member {Array.<IEmotionResult>} emotionResult\n     * @memberof DecoderResult\n     * @instance\n     */\n\n    DecoderResult.prototype.emotionResult = $util.emptyArray;\n    /**\n     * DecoderResult contextAnswer.\n     * @member {Array.<DecoderResult.IContextAnswer>} contextAnswer\n     * @memberof DecoderResult\n     * @instance\n     */\n\n    DecoderResult.prototype.contextAnswer = $util.emptyArray;\n    /**\n     * Creates a new DecoderResult instance using the specified properties.\n     * @function create\n     * @memberof DecoderResult\n     * @static\n     * @param {IDecoderResult=} [properties] Properties to set\n     * @returns {DecoderResult} DecoderResult instance\n     */\n\n    DecoderResult.create = function create(properties) {\n      return new DecoderResult(properties);\n    };\n    /**\n     * Encodes the specified DecoderResult message. Does not implicitly {@link DecoderResult.verify|verify} messages.\n     * @function encode\n     * @memberof DecoderResult\n     * @static\n     * @param {IDecoderResult} message DecoderResult message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    DecoderResult.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.hypothesis != null && message.hypothesis.length) for (var i = 0; i < message.hypothesis.length; ++i) $root.Hypothesis.encode(message.hypothesis[i], writer.uint32(\n      /* id 1, wireType 2 =*/\n      10).fork()).ldelim();\n      if (message.chunkStart != null && Object.hasOwnProperty.call(message, 'chunkStart')) writer.uint32(\n      /* id 2, wireType 5 =*/\n      21).float(message.chunkStart);\n      if (message.chunkEnd != null && Object.hasOwnProperty.call(message, 'chunkEnd')) writer.uint32(\n      /* id 3, wireType 5 =*/\n      29).float(message.chunkEnd);\n      if (message.timeEndpointDetectionMs != null && Object.hasOwnProperty.call(message, 'timeEndpointDetectionMs')) writer.uint32(\n      /* id 4, wireType 5 =*/\n      37).float(message.timeEndpointDetectionMs);\n      if (message.timeDecodingMs != null && Object.hasOwnProperty.call(message, 'timeDecodingMs')) writer.uint32(\n      /* id 5, wireType 5 =*/\n      45).float(message.timeDecodingMs);\n      if (message.variables != null && Object.hasOwnProperty.call(message, 'variables')) $root.Variables.encode(message.variables, writer.uint32(\n      /* id 6, wireType 2 =*/\n      50).fork()).ldelim();\n      if (message.isFinal != null && Object.hasOwnProperty.call(message, 'isFinal')) writer.uint32(\n      /* id 7, wireType 0 =*/\n      56).bool(message.isFinal);\n      if (message.emotionResult != null && message.emotionResult.length) for (var i = 0; i < message.emotionResult.length; ++i) $root.EmotionResult.encode(message.emotionResult[i], writer.uint32(\n      /* id 8, wireType 2 =*/\n      66).fork()).ldelim();\n      if (message.contextAnswer != null && message.contextAnswer.length) for (var i = 0; i < message.contextAnswer.length; ++i) $root.DecoderResult.ContextAnswer.encode(message.contextAnswer[i], writer.uint32(\n      /* id 9, wireType 2 =*/\n      74).fork()).ldelim();\n      return writer;\n    };\n    /**\n     * Encodes the specified DecoderResult message, length delimited. Does not implicitly {@link DecoderResult.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof DecoderResult\n     * @static\n     * @param {IDecoderResult} message DecoderResult message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    DecoderResult.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a DecoderResult message from the specified reader or buffer.\n     * @function decode\n     * @memberof DecoderResult\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {DecoderResult} DecoderResult\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    DecoderResult.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.DecoderResult();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            if (!(message.hypothesis && message.hypothesis.length)) message.hypothesis = [];\n            message.hypothesis.push($root.Hypothesis.decode(reader, reader.uint32()));\n            break;\n\n          case 2:\n            message.chunkStart = reader.float();\n            break;\n\n          case 3:\n            message.chunkEnd = reader.float();\n            break;\n\n          case 4:\n            message.timeEndpointDetectionMs = reader.float();\n            break;\n\n          case 5:\n            message.timeDecodingMs = reader.float();\n            break;\n\n          case 6:\n            message.variables = $root.Variables.decode(reader, reader.uint32());\n            break;\n\n          case 7:\n            message.isFinal = reader.bool();\n            break;\n\n          case 8:\n            if (!(message.emotionResult && message.emotionResult.length)) message.emotionResult = [];\n            message.emotionResult.push($root.EmotionResult.decode(reader, reader.uint32()));\n            break;\n\n          case 9:\n            if (!(message.contextAnswer && message.contextAnswer.length)) message.contextAnswer = [];\n            message.contextAnswer.push($root.DecoderResult.ContextAnswer.decode(reader, reader.uint32()));\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a DecoderResult message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof DecoderResult\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {DecoderResult} DecoderResult\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    DecoderResult.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a DecoderResult message.\n     * @function verify\n     * @memberof DecoderResult\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    DecoderResult.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n\n      if (message.hypothesis != null && message.hasOwnProperty('hypothesis')) {\n        if (!Array.isArray(message.hypothesis)) return 'hypothesis: array expected';\n\n        for (var i = 0; i < message.hypothesis.length; ++i) {\n          var error = $root.Hypothesis.verify(message.hypothesis[i]);\n          if (error) return 'hypothesis.' + error;\n        }\n      }\n\n      if (message.chunkStart != null && message.hasOwnProperty('chunkStart')) if (typeof message.chunkStart !== 'number') return 'chunkStart: number expected';\n      if (message.chunkEnd != null && message.hasOwnProperty('chunkEnd')) if (typeof message.chunkEnd !== 'number') return 'chunkEnd: number expected';\n      if (message.timeEndpointDetectionMs != null && message.hasOwnProperty('timeEndpointDetectionMs')) if (typeof message.timeEndpointDetectionMs !== 'number') return 'timeEndpointDetectionMs: number expected';\n      if (message.timeDecodingMs != null && message.hasOwnProperty('timeDecodingMs')) if (typeof message.timeDecodingMs !== 'number') return 'timeDecodingMs: number expected';\n\n      if (message.variables != null && message.hasOwnProperty('variables')) {\n        var error = $root.Variables.verify(message.variables);\n        if (error) return 'variables.' + error;\n      }\n\n      if (message.isFinal != null && message.hasOwnProperty('isFinal')) if (typeof message.isFinal !== 'boolean') return 'isFinal: boolean expected';\n\n      if (message.emotionResult != null && message.hasOwnProperty('emotionResult')) {\n        if (!Array.isArray(message.emotionResult)) return 'emotionResult: array expected';\n\n        for (var i = 0; i < message.emotionResult.length; ++i) {\n          var error = $root.EmotionResult.verify(message.emotionResult[i]);\n          if (error) return 'emotionResult.' + error;\n        }\n      }\n\n      if (message.contextAnswer != null && message.hasOwnProperty('contextAnswer')) {\n        if (!Array.isArray(message.contextAnswer)) return 'contextAnswer: array expected';\n\n        for (var i = 0; i < message.contextAnswer.length; ++i) {\n          var error = $root.DecoderResult.ContextAnswer.verify(message.contextAnswer[i]);\n          if (error) return 'contextAnswer.' + error;\n        }\n      }\n\n      return null;\n    };\n    /**\n     * Creates a DecoderResult message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof DecoderResult\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {DecoderResult} DecoderResult\n     */\n\n\n    DecoderResult.fromObject = function fromObject(object) {\n      if (object instanceof $root.DecoderResult) return object;\n      var message = new $root.DecoderResult();\n\n      if (object.hypothesis) {\n        if (!Array.isArray(object.hypothesis)) throw TypeError('.DecoderResult.hypothesis: array expected');\n        message.hypothesis = [];\n\n        for (var i = 0; i < object.hypothesis.length; ++i) {\n          if (typeof object.hypothesis[i] !== 'object') throw TypeError('.DecoderResult.hypothesis: object expected');\n          message.hypothesis[i] = $root.Hypothesis.fromObject(object.hypothesis[i]);\n        }\n      }\n\n      if (object.chunkStart != null) message.chunkStart = Number(object.chunkStart);\n      if (object.chunkEnd != null) message.chunkEnd = Number(object.chunkEnd);\n      if (object.timeEndpointDetectionMs != null) message.timeEndpointDetectionMs = Number(object.timeEndpointDetectionMs);\n      if (object.timeDecodingMs != null) message.timeDecodingMs = Number(object.timeDecodingMs);\n\n      if (object.variables != null) {\n        if (typeof object.variables !== 'object') throw TypeError('.DecoderResult.variables: object expected');\n        message.variables = $root.Variables.fromObject(object.variables);\n      }\n\n      if (object.isFinal != null) message.isFinal = Boolean(object.isFinal);\n\n      if (object.emotionResult) {\n        if (!Array.isArray(object.emotionResult)) throw TypeError('.DecoderResult.emotionResult: array expected');\n        message.emotionResult = [];\n\n        for (var i = 0; i < object.emotionResult.length; ++i) {\n          if (typeof object.emotionResult[i] !== 'object') throw TypeError('.DecoderResult.emotionResult: object expected');\n          message.emotionResult[i] = $root.EmotionResult.fromObject(object.emotionResult[i]);\n        }\n      }\n\n      if (object.contextAnswer) {\n        if (!Array.isArray(object.contextAnswer)) throw TypeError('.DecoderResult.contextAnswer: array expected');\n        message.contextAnswer = [];\n\n        for (var i = 0; i < object.contextAnswer.length; ++i) {\n          if (typeof object.contextAnswer[i] !== 'object') throw TypeError('.DecoderResult.contextAnswer: object expected');\n          message.contextAnswer[i] = $root.DecoderResult.ContextAnswer.fromObject(object.contextAnswer[i]);\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Creates a plain object from a DecoderResult message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof DecoderResult\n     * @static\n     * @param {DecoderResult} message DecoderResult\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    DecoderResult.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n\n      if (options.arrays || options.defaults) {\n        object.hypothesis = [];\n        object.emotionResult = [];\n        object.contextAnswer = [];\n      }\n\n      if (options.defaults) {\n        object.chunkStart = 0;\n        object.chunkEnd = 0;\n        object.timeEndpointDetectionMs = 0;\n        object.timeDecodingMs = 0;\n        object.variables = null;\n        object.isFinal = false;\n      }\n\n      if (message.hypothesis && message.hypothesis.length) {\n        object.hypothesis = [];\n\n        for (var j = 0; j < message.hypothesis.length; ++j) object.hypothesis[j] = $root.Hypothesis.toObject(message.hypothesis[j], options);\n      }\n\n      if (message.chunkStart != null && message.hasOwnProperty('chunkStart')) object.chunkStart = options.json && !isFinite(message.chunkStart) ? String(message.chunkStart) : message.chunkStart;\n      if (message.chunkEnd != null && message.hasOwnProperty('chunkEnd')) object.chunkEnd = options.json && !isFinite(message.chunkEnd) ? String(message.chunkEnd) : message.chunkEnd;\n      if (message.timeEndpointDetectionMs != null && message.hasOwnProperty('timeEndpointDetectionMs')) object.timeEndpointDetectionMs = options.json && !isFinite(message.timeEndpointDetectionMs) ? String(message.timeEndpointDetectionMs) : message.timeEndpointDetectionMs;\n      if (message.timeDecodingMs != null && message.hasOwnProperty('timeDecodingMs')) object.timeDecodingMs = options.json && !isFinite(message.timeDecodingMs) ? String(message.timeDecodingMs) : message.timeDecodingMs;\n      if (message.variables != null && message.hasOwnProperty('variables')) object.variables = $root.Variables.toObject(message.variables, options);\n      if (message.isFinal != null && message.hasOwnProperty('isFinal')) object.isFinal = message.isFinal;\n\n      if (message.emotionResult && message.emotionResult.length) {\n        object.emotionResult = [];\n\n        for (var j = 0; j < message.emotionResult.length; ++j) object.emotionResult[j] = $root.EmotionResult.toObject(message.emotionResult[j], options);\n      }\n\n      if (message.contextAnswer && message.contextAnswer.length) {\n        object.contextAnswer = [];\n\n        for (var j = 0; j < message.contextAnswer.length; ++j) object.contextAnswer[j] = $root.DecoderResult.ContextAnswer.toObject(message.contextAnswer[j], options);\n      }\n\n      return object;\n    };\n    /**\n     * Converts this DecoderResult to JSON.\n     * @function toJSON\n     * @memberof DecoderResult\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    DecoderResult.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    DecoderResult.ContextAnswer = function () {\n      /**\n       * Properties of a ContextAnswer.\n       * @memberof DecoderResult\n       * @interface IContextAnswer\n       * @property {Array.<DecoderResult.ContextAnswer.IContextRef>|null} [contextResult] ContextAnswer contextResult\n       */\n\n      /**\n       * Constructs a new ContextAnswer.\n       * @memberof DecoderResult\n       * @classdesc Represents a ContextAnswer.\n       * @implements IContextAnswer\n       * @constructor\n       * @param {DecoderResult.IContextAnswer=} [properties] Properties to set\n       */\n      function ContextAnswer(properties) {\n        this.contextResult = [];\n        if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * ContextAnswer contextResult.\n       * @member {Array.<DecoderResult.ContextAnswer.IContextRef>} contextResult\n       * @memberof DecoderResult.ContextAnswer\n       * @instance\n       */\n\n\n      ContextAnswer.prototype.contextResult = $util.emptyArray;\n      /**\n       * Creates a new ContextAnswer instance using the specified properties.\n       * @function create\n       * @memberof DecoderResult.ContextAnswer\n       * @static\n       * @param {DecoderResult.IContextAnswer=} [properties] Properties to set\n       * @returns {DecoderResult.ContextAnswer} ContextAnswer instance\n       */\n\n      ContextAnswer.create = function create(properties) {\n        return new ContextAnswer(properties);\n      };\n      /**\n       * Encodes the specified ContextAnswer message. Does not implicitly {@link DecoderResult.ContextAnswer.verify|verify} messages.\n       * @function encode\n       * @memberof DecoderResult.ContextAnswer\n       * @static\n       * @param {DecoderResult.IContextAnswer} message ContextAnswer message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      ContextAnswer.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create();\n        if (message.contextResult != null && message.contextResult.length) for (var i = 0; i < message.contextResult.length; ++i) $root.DecoderResult.ContextAnswer.ContextRef.encode(message.contextResult[i], writer.uint32(\n        /* id 1, wireType 2 =*/\n        10).fork()).ldelim();\n        return writer;\n      };\n      /**\n       * Encodes the specified ContextAnswer message, length delimited. Does not implicitly {@link DecoderResult.ContextAnswer.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof DecoderResult.ContextAnswer\n       * @static\n       * @param {DecoderResult.IContextAnswer} message ContextAnswer message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      ContextAnswer.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n      /**\n       * Decodes a ContextAnswer message from the specified reader or buffer.\n       * @function decode\n       * @memberof DecoderResult.ContextAnswer\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {DecoderResult.ContextAnswer} ContextAnswer\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      ContextAnswer.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.DecoderResult.ContextAnswer();\n\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              if (!(message.contextResult && message.contextResult.length)) message.contextResult = [];\n              message.contextResult.push($root.DecoderResult.ContextAnswer.ContextRef.decode(reader, reader.uint32()));\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n      /**\n       * Decodes a ContextAnswer message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof DecoderResult.ContextAnswer\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {DecoderResult.ContextAnswer} ContextAnswer\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      ContextAnswer.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n      };\n      /**\n       * Verifies a ContextAnswer message.\n       * @function verify\n       * @memberof DecoderResult.ContextAnswer\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n\n\n      ContextAnswer.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) return 'object expected';\n\n        if (message.contextResult != null && message.hasOwnProperty('contextResult')) {\n          if (!Array.isArray(message.contextResult)) return 'contextResult: array expected';\n\n          for (var i = 0; i < message.contextResult.length; ++i) {\n            var error = $root.DecoderResult.ContextAnswer.ContextRef.verify(message.contextResult[i]);\n            if (error) return 'contextResult.' + error;\n          }\n        }\n\n        return null;\n      };\n      /**\n       * Creates a ContextAnswer message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof DecoderResult.ContextAnswer\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {DecoderResult.ContextAnswer} ContextAnswer\n       */\n\n\n      ContextAnswer.fromObject = function fromObject(object) {\n        if (object instanceof $root.DecoderResult.ContextAnswer) return object;\n        var message = new $root.DecoderResult.ContextAnswer();\n\n        if (object.contextResult) {\n          if (!Array.isArray(object.contextResult)) throw TypeError('.DecoderResult.ContextAnswer.contextResult: array expected');\n          message.contextResult = [];\n\n          for (var i = 0; i < object.contextResult.length; ++i) {\n            if (typeof object.contextResult[i] !== 'object') throw TypeError('.DecoderResult.ContextAnswer.contextResult: object expected');\n            message.contextResult[i] = $root.DecoderResult.ContextAnswer.ContextRef.fromObject(object.contextResult[i]);\n          }\n        }\n\n        return message;\n      };\n      /**\n       * Creates a plain object from a ContextAnswer message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof DecoderResult.ContextAnswer\n       * @static\n       * @param {DecoderResult.ContextAnswer} message ContextAnswer\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n\n\n      ContextAnswer.toObject = function toObject(message, options) {\n        if (!options) options = {};\n        var object = {};\n        if (options.arrays || options.defaults) object.contextResult = [];\n\n        if (message.contextResult && message.contextResult.length) {\n          object.contextResult = [];\n\n          for (var j = 0; j < message.contextResult.length; ++j) object.contextResult[j] = $root.DecoderResult.ContextAnswer.ContextRef.toObject(message.contextResult[j], options);\n        }\n\n        return object;\n      };\n      /**\n       * Converts this ContextAnswer to JSON.\n       * @function toJSON\n       * @memberof DecoderResult.ContextAnswer\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n\n\n      ContextAnswer.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      ContextAnswer.ContextRef = function () {\n        /**\n         * Properties of a ContextRef.\n         * @memberof DecoderResult.ContextAnswer\n         * @interface IContextRef\n         * @property {string|null} [id] ContextRef id\n         * @property {number|null} [index] ContextRef index\n         * @property {string|null} [originalValue] ContextRef originalValue\n         * @property {string|null} [predictedValue] ContextRef predictedValue\n         * @property {number|null} [score] ContextRef score\n         */\n\n        /**\n         * Constructs a new ContextRef.\n         * @memberof DecoderResult.ContextAnswer\n         * @classdesc Represents a ContextRef.\n         * @implements IContextRef\n         * @constructor\n         * @param {DecoderResult.ContextAnswer.IContextRef=} [properties] Properties to set\n         */\n        function ContextRef(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * ContextRef id.\n         * @member {string} id\n         * @memberof DecoderResult.ContextAnswer.ContextRef\n         * @instance\n         */\n\n\n        ContextRef.prototype.id = '';\n        /**\n         * ContextRef index.\n         * @member {number} index\n         * @memberof DecoderResult.ContextAnswer.ContextRef\n         * @instance\n         */\n\n        ContextRef.prototype.index = 0;\n        /**\n         * ContextRef originalValue.\n         * @member {string} originalValue\n         * @memberof DecoderResult.ContextAnswer.ContextRef\n         * @instance\n         */\n\n        ContextRef.prototype.originalValue = '';\n        /**\n         * ContextRef predictedValue.\n         * @member {string} predictedValue\n         * @memberof DecoderResult.ContextAnswer.ContextRef\n         * @instance\n         */\n\n        ContextRef.prototype.predictedValue = '';\n        /**\n         * ContextRef score.\n         * @member {number} score\n         * @memberof DecoderResult.ContextAnswer.ContextRef\n         * @instance\n         */\n\n        ContextRef.prototype.score = 0;\n        /**\n         * Creates a new ContextRef instance using the specified properties.\n         * @function create\n         * @memberof DecoderResult.ContextAnswer.ContextRef\n         * @static\n         * @param {DecoderResult.ContextAnswer.IContextRef=} [properties] Properties to set\n         * @returns {DecoderResult.ContextAnswer.ContextRef} ContextRef instance\n         */\n\n        ContextRef.create = function create(properties) {\n          return new ContextRef(properties);\n        };\n        /**\n         * Encodes the specified ContextRef message. Does not implicitly {@link DecoderResult.ContextAnswer.ContextRef.verify|verify} messages.\n         * @function encode\n         * @memberof DecoderResult.ContextAnswer.ContextRef\n         * @static\n         * @param {DecoderResult.ContextAnswer.IContextRef} message ContextRef message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ContextRef.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.id != null && Object.hasOwnProperty.call(message, 'id')) writer.uint32(\n          /* id 1, wireType 2 =*/\n          10).string(message.id);\n          if (message.index != null && Object.hasOwnProperty.call(message, 'index')) writer.uint32(\n          /* id 2, wireType 0 =*/\n          16).int32(message.index);\n          if (message.originalValue != null && Object.hasOwnProperty.call(message, 'originalValue')) writer.uint32(\n          /* id 3, wireType 2 =*/\n          26).string(message.originalValue);\n          if (message.predictedValue != null && Object.hasOwnProperty.call(message, 'predictedValue')) writer.uint32(\n          /* id 4, wireType 2 =*/\n          34).string(message.predictedValue);\n          if (message.score != null && Object.hasOwnProperty.call(message, 'score')) writer.uint32(\n          /* id 5, wireType 5 =*/\n          45).float(message.score);\n          return writer;\n        };\n        /**\n         * Encodes the specified ContextRef message, length delimited. Does not implicitly {@link DecoderResult.ContextAnswer.ContextRef.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof DecoderResult.ContextAnswer.ContextRef\n         * @static\n         * @param {DecoderResult.ContextAnswer.IContextRef} message ContextRef message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n\n\n        ContextRef.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a ContextRef message from the specified reader or buffer.\n         * @function decode\n         * @memberof DecoderResult.ContextAnswer.ContextRef\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {DecoderResult.ContextAnswer.ContextRef} ContextRef\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ContextRef.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.DecoderResult.ContextAnswer.ContextRef();\n\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.id = reader.string();\n                break;\n\n              case 2:\n                message.index = reader.int32();\n                break;\n\n              case 3:\n                message.originalValue = reader.string();\n                break;\n\n              case 4:\n                message.predictedValue = reader.string();\n                break;\n\n              case 5:\n                message.score = reader.float();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n        /**\n         * Decodes a ContextRef message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof DecoderResult.ContextAnswer.ContextRef\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {DecoderResult.ContextAnswer.ContextRef} ContextRef\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n\n        ContextRef.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a ContextRef message.\n         * @function verify\n         * @memberof DecoderResult.ContextAnswer.ContextRef\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n\n\n        ContextRef.verify = function verify(message) {\n          if (typeof message !== 'object' || message === null) return 'object expected';\n          if (message.id != null && message.hasOwnProperty('id')) if (!$util.isString(message.id)) return 'id: string expected';\n          if (message.index != null && message.hasOwnProperty('index')) if (!$util.isInteger(message.index)) return 'index: integer expected';\n          if (message.originalValue != null && message.hasOwnProperty('originalValue')) if (!$util.isString(message.originalValue)) return 'originalValue: string expected';\n          if (message.predictedValue != null && message.hasOwnProperty('predictedValue')) if (!$util.isString(message.predictedValue)) return 'predictedValue: string expected';\n          if (message.score != null && message.hasOwnProperty('score')) if (typeof message.score !== 'number') return 'score: number expected';\n          return null;\n        };\n        /**\n         * Creates a ContextRef message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof DecoderResult.ContextAnswer.ContextRef\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {DecoderResult.ContextAnswer.ContextRef} ContextRef\n         */\n\n\n        ContextRef.fromObject = function fromObject(object) {\n          if (object instanceof $root.DecoderResult.ContextAnswer.ContextRef) return object;\n          var message = new $root.DecoderResult.ContextAnswer.ContextRef();\n          if (object.id != null) message.id = String(object.id);\n          if (object.index != null) message.index = object.index | 0;\n          if (object.originalValue != null) message.originalValue = String(object.originalValue);\n          if (object.predictedValue != null) message.predictedValue = String(object.predictedValue);\n          if (object.score != null) message.score = Number(object.score);\n          return message;\n        };\n        /**\n         * Creates a plain object from a ContextRef message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof DecoderResult.ContextAnswer.ContextRef\n         * @static\n         * @param {DecoderResult.ContextAnswer.ContextRef} message ContextRef\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n\n\n        ContextRef.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          var object = {};\n\n          if (options.defaults) {\n            object.id = '';\n            object.index = 0;\n            object.originalValue = '';\n            object.predictedValue = '';\n            object.score = 0;\n          }\n\n          if (message.id != null && message.hasOwnProperty('id')) object.id = message.id;\n          if (message.index != null && message.hasOwnProperty('index')) object.index = message.index;\n          if (message.originalValue != null && message.hasOwnProperty('originalValue')) object.originalValue = message.originalValue;\n          if (message.predictedValue != null && message.hasOwnProperty('predictedValue')) object.predictedValue = message.predictedValue;\n          if (message.score != null && message.hasOwnProperty('score')) object.score = options.json && !isFinite(message.score) ? String(message.score) : message.score;\n          return object;\n        };\n        /**\n         * Converts this ContextRef to JSON.\n         * @function toJSON\n         * @memberof DecoderResult.ContextAnswer.ContextRef\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n\n\n        ContextRef.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ContextRef;\n      }();\n\n      return ContextAnswer;\n    }();\n\n    return DecoderResult;\n  }();\n\n  $root.ErrorResponse = function () {\n    /**\n     * Properties of an ErrorResponse.\n     * @exports IErrorResponse\n     * @interface IErrorResponse\n     * @property {string|null} [errorMessage] ErrorResponse errorMessage\n     */\n\n    /**\n     * Constructs a new ErrorResponse.\n     * @exports ErrorResponse\n     * @classdesc Represents an ErrorResponse.\n     * @implements IErrorResponse\n     * @constructor\n     * @param {IErrorResponse=} [properties] Properties to set\n     */\n    function ErrorResponse(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * ErrorResponse errorMessage.\n     * @member {string} errorMessage\n     * @memberof ErrorResponse\n     * @instance\n     */\n\n\n    ErrorResponse.prototype.errorMessage = '';\n    /**\n     * Creates a new ErrorResponse instance using the specified properties.\n     * @function create\n     * @memberof ErrorResponse\n     * @static\n     * @param {IErrorResponse=} [properties] Properties to set\n     * @returns {ErrorResponse} ErrorResponse instance\n     */\n\n    ErrorResponse.create = function create(properties) {\n      return new ErrorResponse(properties);\n    };\n    /**\n     * Encodes the specified ErrorResponse message. Does not implicitly {@link ErrorResponse.verify|verify} messages.\n     * @function encode\n     * @memberof ErrorResponse\n     * @static\n     * @param {IErrorResponse} message ErrorResponse message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    ErrorResponse.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.errorMessage != null && Object.hasOwnProperty.call(message, 'errorMessage')) writer.uint32(\n      /* id 1, wireType 2 =*/\n      10).string(message.errorMessage);\n      return writer;\n    };\n    /**\n     * Encodes the specified ErrorResponse message, length delimited. Does not implicitly {@link ErrorResponse.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ErrorResponse\n     * @static\n     * @param {IErrorResponse} message ErrorResponse message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    ErrorResponse.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes an ErrorResponse message from the specified reader or buffer.\n     * @function decode\n     * @memberof ErrorResponse\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ErrorResponse} ErrorResponse\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    ErrorResponse.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.ErrorResponse();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.errorMessage = reader.string();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes an ErrorResponse message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ErrorResponse\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ErrorResponse} ErrorResponse\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    ErrorResponse.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies an ErrorResponse message.\n     * @function verify\n     * @memberof ErrorResponse\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    ErrorResponse.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      if (message.errorMessage != null && message.hasOwnProperty('errorMessage')) if (!$util.isString(message.errorMessage)) return 'errorMessage: string expected';\n      return null;\n    };\n    /**\n     * Creates an ErrorResponse message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof ErrorResponse\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {ErrorResponse} ErrorResponse\n     */\n\n\n    ErrorResponse.fromObject = function fromObject(object) {\n      if (object instanceof $root.ErrorResponse) return object;\n      var message = new $root.ErrorResponse();\n      if (object.errorMessage != null) message.errorMessage = String(object.errorMessage);\n      return message;\n    };\n    /**\n     * Creates a plain object from an ErrorResponse message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ErrorResponse\n     * @static\n     * @param {ErrorResponse} message ErrorResponse\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    ErrorResponse.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.defaults) object.errorMessage = '';\n      if (message.errorMessage != null && message.hasOwnProperty('errorMessage')) object.errorMessage = message.errorMessage;\n      return object;\n    };\n    /**\n     * Converts this ErrorResponse to JSON.\n     * @function toJSON\n     * @memberof ErrorResponse\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    ErrorResponse.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return ErrorResponse;\n  }();\n\n  $root.PacketWrapperToServer = function () {\n    /**\n     * Properties of a PacketWrapperToServer.\n     * @exports IPacketWrapperToServer\n     * @interface IPacketWrapperToServer\n     * @property {IData|null} [dataField] PacketWrapperToServer dataField\n     * @property {IInfo|null} [infoField] PacketWrapperToServer infoField\n     * @property {IFinalized|null} [finalizedField] PacketWrapperToServer finalizedField\n     * @property {ISetOptions|null} [setOptionsField] PacketWrapperToServer setOptionsField\n     */\n\n    /**\n     * Constructs a new PacketWrapperToServer.\n     * @exports PacketWrapperToServer\n     * @classdesc Represents a PacketWrapperToServer.\n     * @implements IPacketWrapperToServer\n     * @constructor\n     * @param {IPacketWrapperToServer=} [properties] Properties to set\n     */\n    function PacketWrapperToServer(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * PacketWrapperToServer dataField.\n     * @member {IData|null|undefined} dataField\n     * @memberof PacketWrapperToServer\n     * @instance\n     */\n\n\n    PacketWrapperToServer.prototype.dataField = null;\n    /**\n     * PacketWrapperToServer infoField.\n     * @member {IInfo|null|undefined} infoField\n     * @memberof PacketWrapperToServer\n     * @instance\n     */\n\n    PacketWrapperToServer.prototype.infoField = null;\n    /**\n     * PacketWrapperToServer finalizedField.\n     * @member {IFinalized|null|undefined} finalizedField\n     * @memberof PacketWrapperToServer\n     * @instance\n     */\n\n    PacketWrapperToServer.prototype.finalizedField = null;\n    /**\n     * PacketWrapperToServer setOptionsField.\n     * @member {ISetOptions|null|undefined} setOptionsField\n     * @memberof PacketWrapperToServer\n     * @instance\n     */\n\n    PacketWrapperToServer.prototype.setOptionsField = null; // OneOf field names bound to virtual getters and setters\n\n    var $oneOfFields;\n    /**\n     * PacketWrapperToServer MessageType.\n     * @member {\"dataField\"|\"infoField\"|\"finalizedField\"|\"setOptionsField\"|undefined} MessageType\n     * @memberof PacketWrapperToServer\n     * @instance\n     */\n\n    Object.defineProperty(PacketWrapperToServer.prototype, 'MessageType', {\n      get: $util.oneOfGetter($oneOfFields = ['dataField', 'infoField', 'finalizedField', 'setOptionsField']),\n      set: $util.oneOfSetter($oneOfFields)\n    });\n    /**\n     * Creates a new PacketWrapperToServer instance using the specified properties.\n     * @function create\n     * @memberof PacketWrapperToServer\n     * @static\n     * @param {IPacketWrapperToServer=} [properties] Properties to set\n     * @returns {PacketWrapperToServer} PacketWrapperToServer instance\n     */\n\n    PacketWrapperToServer.create = function create(properties) {\n      return new PacketWrapperToServer(properties);\n    };\n    /**\n     * Encodes the specified PacketWrapperToServer message. Does not implicitly {@link PacketWrapperToServer.verify|verify} messages.\n     * @function encode\n     * @memberof PacketWrapperToServer\n     * @static\n     * @param {IPacketWrapperToServer} message PacketWrapperToServer message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    PacketWrapperToServer.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.dataField != null && Object.hasOwnProperty.call(message, 'dataField')) $root.Data.encode(message.dataField, writer.uint32(\n      /* id 1, wireType 2 =*/\n      10).fork()).ldelim();\n      if (message.infoField != null && Object.hasOwnProperty.call(message, 'infoField')) $root.Info.encode(message.infoField, writer.uint32(\n      /* id 3, wireType 2 =*/\n      26).fork()).ldelim();\n      if (message.finalizedField != null && Object.hasOwnProperty.call(message, 'finalizedField')) $root.Finalized.encode(message.finalizedField, writer.uint32(\n      /* id 5, wireType 2 =*/\n      42).fork()).ldelim();\n      if (message.setOptionsField != null && Object.hasOwnProperty.call(message, 'setOptionsField')) $root.SetOptions.encode(message.setOptionsField, writer.uint32(\n      /* id 7, wireType 2 =*/\n      58).fork()).ldelim();\n      return writer;\n    };\n    /**\n     * Encodes the specified PacketWrapperToServer message, length delimited. Does not implicitly {@link PacketWrapperToServer.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof PacketWrapperToServer\n     * @static\n     * @param {IPacketWrapperToServer} message PacketWrapperToServer message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    PacketWrapperToServer.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a PacketWrapperToServer message from the specified reader or buffer.\n     * @function decode\n     * @memberof PacketWrapperToServer\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {PacketWrapperToServer} PacketWrapperToServer\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    PacketWrapperToServer.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.PacketWrapperToServer();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.dataField = $root.Data.decode(reader, reader.uint32());\n            break;\n\n          case 3:\n            message.infoField = $root.Info.decode(reader, reader.uint32());\n            break;\n\n          case 5:\n            message.finalizedField = $root.Finalized.decode(reader, reader.uint32());\n            break;\n\n          case 7:\n            message.setOptionsField = $root.SetOptions.decode(reader, reader.uint32());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a PacketWrapperToServer message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof PacketWrapperToServer\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {PacketWrapperToServer} PacketWrapperToServer\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    PacketWrapperToServer.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a PacketWrapperToServer message.\n     * @function verify\n     * @memberof PacketWrapperToServer\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    PacketWrapperToServer.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      var properties = {};\n\n      if (message.dataField != null && message.hasOwnProperty('dataField')) {\n        properties.MessageType = 1;\n        {\n          var error = $root.Data.verify(message.dataField);\n          if (error) return 'dataField.' + error;\n        }\n      }\n\n      if (message.infoField != null && message.hasOwnProperty('infoField')) {\n        if (properties.MessageType === 1) return 'MessageType: multiple values';\n        properties.MessageType = 1;\n        {\n          var error = $root.Info.verify(message.infoField);\n          if (error) return 'infoField.' + error;\n        }\n      }\n\n      if (message.finalizedField != null && message.hasOwnProperty('finalizedField')) {\n        if (properties.MessageType === 1) return 'MessageType: multiple values';\n        properties.MessageType = 1;\n        {\n          var error = $root.Finalized.verify(message.finalizedField);\n          if (error) return 'finalizedField.' + error;\n        }\n      }\n\n      if (message.setOptionsField != null && message.hasOwnProperty('setOptionsField')) {\n        if (properties.MessageType === 1) return 'MessageType: multiple values';\n        properties.MessageType = 1;\n        {\n          var error = $root.SetOptions.verify(message.setOptionsField);\n          if (error) return 'setOptionsField.' + error;\n        }\n      }\n\n      return null;\n    };\n    /**\n     * Creates a PacketWrapperToServer message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof PacketWrapperToServer\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {PacketWrapperToServer} PacketWrapperToServer\n     */\n\n\n    PacketWrapperToServer.fromObject = function fromObject(object) {\n      if (object instanceof $root.PacketWrapperToServer) return object;\n      var message = new $root.PacketWrapperToServer();\n\n      if (object.dataField != null) {\n        if (typeof object.dataField !== 'object') throw TypeError('.PacketWrapperToServer.dataField: object expected');\n        message.dataField = $root.Data.fromObject(object.dataField);\n      }\n\n      if (object.infoField != null) {\n        if (typeof object.infoField !== 'object') throw TypeError('.PacketWrapperToServer.infoField: object expected');\n        message.infoField = $root.Info.fromObject(object.infoField);\n      }\n\n      if (object.finalizedField != null) {\n        if (typeof object.finalizedField !== 'object') throw TypeError('.PacketWrapperToServer.finalizedField: object expected');\n        message.finalizedField = $root.Finalized.fromObject(object.finalizedField);\n      }\n\n      if (object.setOptionsField != null) {\n        if (typeof object.setOptionsField !== 'object') throw TypeError('.PacketWrapperToServer.setOptionsField: object expected');\n        message.setOptionsField = $root.SetOptions.fromObject(object.setOptionsField);\n      }\n\n      return message;\n    };\n    /**\n     * Creates a plain object from a PacketWrapperToServer message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof PacketWrapperToServer\n     * @static\n     * @param {PacketWrapperToServer} message PacketWrapperToServer\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    PacketWrapperToServer.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n\n      if (message.dataField != null && message.hasOwnProperty('dataField')) {\n        object.dataField = $root.Data.toObject(message.dataField, options);\n        if (options.oneofs) object.MessageType = 'dataField';\n      }\n\n      if (message.infoField != null && message.hasOwnProperty('infoField')) {\n        object.infoField = $root.Info.toObject(message.infoField, options);\n        if (options.oneofs) object.MessageType = 'infoField';\n      }\n\n      if (message.finalizedField != null && message.hasOwnProperty('finalizedField')) {\n        object.finalizedField = $root.Finalized.toObject(message.finalizedField, options);\n        if (options.oneofs) object.MessageType = 'finalizedField';\n      }\n\n      if (message.setOptionsField != null && message.hasOwnProperty('setOptionsField')) {\n        object.setOptionsField = $root.SetOptions.toObject(message.setOptionsField, options);\n        if (options.oneofs) object.MessageType = 'setOptionsField';\n      }\n\n      return object;\n    };\n    /**\n     * Converts this PacketWrapperToServer to JSON.\n     * @function toJSON\n     * @memberof PacketWrapperToServer\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    PacketWrapperToServer.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return PacketWrapperToServer;\n  }();\n\n  $root.PacketWrapperFromServer = function () {\n    /**\n     * Properties of a PacketWrapperFromServer.\n     * @exports IPacketWrapperFromServer\n     * @interface IPacketWrapperFromServer\n     * @property {IUndecodedSeconds|null} [undecodedSecondsField] PacketWrapperFromServer undecodedSecondsField\n     * @property {IFullyFinalized|null} [fullyFinalizedField] PacketWrapperFromServer fullyFinalizedField\n     * @property {IDecoderResult|null} [decoderResultField] PacketWrapperFromServer decoderResultField\n     * @property {IErrorResponse|null} [errorResponse] PacketWrapperFromServer errorResponse\n     */\n\n    /**\n     * Constructs a new PacketWrapperFromServer.\n     * @exports PacketWrapperFromServer\n     * @classdesc Represents a PacketWrapperFromServer.\n     * @implements IPacketWrapperFromServer\n     * @constructor\n     * @param {IPacketWrapperFromServer=} [properties] Properties to set\n     */\n    function PacketWrapperFromServer(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * PacketWrapperFromServer undecodedSecondsField.\n     * @member {IUndecodedSeconds|null|undefined} undecodedSecondsField\n     * @memberof PacketWrapperFromServer\n     * @instance\n     */\n\n\n    PacketWrapperFromServer.prototype.undecodedSecondsField = null;\n    /**\n     * PacketWrapperFromServer fullyFinalizedField.\n     * @member {IFullyFinalized|null|undefined} fullyFinalizedField\n     * @memberof PacketWrapperFromServer\n     * @instance\n     */\n\n    PacketWrapperFromServer.prototype.fullyFinalizedField = null;\n    /**\n     * PacketWrapperFromServer decoderResultField.\n     * @member {IDecoderResult|null|undefined} decoderResultField\n     * @memberof PacketWrapperFromServer\n     * @instance\n     */\n\n    PacketWrapperFromServer.prototype.decoderResultField = null;\n    /**\n     * PacketWrapperFromServer errorResponse.\n     * @member {IErrorResponse|null|undefined} errorResponse\n     * @memberof PacketWrapperFromServer\n     * @instance\n     */\n\n    PacketWrapperFromServer.prototype.errorResponse = null; // OneOf field names bound to virtual getters and setters\n\n    var $oneOfFields;\n    /**\n     * PacketWrapperFromServer MessageType.\n     * @member {\"undecodedSecondsField\"|\"fullyFinalizedField\"|\"decoderResultField\"|\"errorResponse\"|undefined} MessageType\n     * @memberof PacketWrapperFromServer\n     * @instance\n     */\n\n    Object.defineProperty(PacketWrapperFromServer.prototype, 'MessageType', {\n      get: $util.oneOfGetter($oneOfFields = ['undecodedSecondsField', 'fullyFinalizedField', 'decoderResultField', 'errorResponse']),\n      set: $util.oneOfSetter($oneOfFields)\n    });\n    /**\n     * Creates a new PacketWrapperFromServer instance using the specified properties.\n     * @function create\n     * @memberof PacketWrapperFromServer\n     * @static\n     * @param {IPacketWrapperFromServer=} [properties] Properties to set\n     * @returns {PacketWrapperFromServer} PacketWrapperFromServer instance\n     */\n\n    PacketWrapperFromServer.create = function create(properties) {\n      return new PacketWrapperFromServer(properties);\n    };\n    /**\n     * Encodes the specified PacketWrapperFromServer message. Does not implicitly {@link PacketWrapperFromServer.verify|verify} messages.\n     * @function encode\n     * @memberof PacketWrapperFromServer\n     * @static\n     * @param {IPacketWrapperFromServer} message PacketWrapperFromServer message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    PacketWrapperFromServer.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.undecodedSecondsField != null && Object.hasOwnProperty.call(message, 'undecodedSecondsField')) $root.UndecodedSeconds.encode(message.undecodedSecondsField, writer.uint32(\n      /* id 1, wireType 2 =*/\n      10).fork()).ldelim();\n      if (message.fullyFinalizedField != null && Object.hasOwnProperty.call(message, 'fullyFinalizedField')) $root.FullyFinalized.encode(message.fullyFinalizedField, writer.uint32(\n      /* id 2, wireType 2 =*/\n      18).fork()).ldelim();\n      if (message.decoderResultField != null && Object.hasOwnProperty.call(message, 'decoderResultField')) $root.DecoderResult.encode(message.decoderResultField, writer.uint32(\n      /* id 4, wireType 2 =*/\n      34).fork()).ldelim();\n      if (message.errorResponse != null && Object.hasOwnProperty.call(message, 'errorResponse')) $root.ErrorResponse.encode(message.errorResponse, writer.uint32(\n      /* id 8, wireType 2 =*/\n      66).fork()).ldelim();\n      return writer;\n    };\n    /**\n     * Encodes the specified PacketWrapperFromServer message, length delimited. Does not implicitly {@link PacketWrapperFromServer.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof PacketWrapperFromServer\n     * @static\n     * @param {IPacketWrapperFromServer} message PacketWrapperFromServer message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    PacketWrapperFromServer.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a PacketWrapperFromServer message from the specified reader or buffer.\n     * @function decode\n     * @memberof PacketWrapperFromServer\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {PacketWrapperFromServer} PacketWrapperFromServer\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    PacketWrapperFromServer.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.PacketWrapperFromServer();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.undecodedSecondsField = $root.UndecodedSeconds.decode(reader, reader.uint32());\n            break;\n\n          case 2:\n            message.fullyFinalizedField = $root.FullyFinalized.decode(reader, reader.uint32());\n            break;\n\n          case 4:\n            message.decoderResultField = $root.DecoderResult.decode(reader, reader.uint32());\n            break;\n\n          case 8:\n            message.errorResponse = $root.ErrorResponse.decode(reader, reader.uint32());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a PacketWrapperFromServer message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof PacketWrapperFromServer\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {PacketWrapperFromServer} PacketWrapperFromServer\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    PacketWrapperFromServer.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a PacketWrapperFromServer message.\n     * @function verify\n     * @memberof PacketWrapperFromServer\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    PacketWrapperFromServer.verify = function verify(message) {\n      if (typeof message !== 'object' || message === null) return 'object expected';\n      var properties = {};\n\n      if (message.undecodedSecondsField != null && message.hasOwnProperty('undecodedSecondsField')) {\n        properties.MessageType = 1;\n        {\n          var error = $root.UndecodedSeconds.verify(message.undecodedSecondsField);\n          if (error) return 'undecodedSecondsField.' + error;\n        }\n      }\n\n      if (message.fullyFinalizedField != null && message.hasOwnProperty('fullyFinalizedField')) {\n        if (properties.MessageType === 1) return 'MessageType: multiple values';\n        properties.MessageType = 1;\n        {\n          var error = $root.FullyFinalized.verify(message.fullyFinalizedField);\n          if (error) return 'fullyFinalizedField.' + error;\n        }\n      }\n\n      if (message.decoderResultField != null && message.hasOwnProperty('decoderResultField')) {\n        if (properties.MessageType === 1) return 'MessageType: multiple values';\n        properties.MessageType = 1;\n        {\n          var error = $root.DecoderResult.verify(message.decoderResultField);\n          if (error) return 'decoderResultField.' + error;\n        }\n      }\n\n      if (message.errorResponse != null && message.hasOwnProperty('errorResponse')) {\n        if (properties.MessageType === 1) return 'MessageType: multiple values';\n        properties.MessageType = 1;\n        {\n          var error = $root.ErrorResponse.verify(message.errorResponse);\n          if (error) return 'errorResponse.' + error;\n        }\n      }\n\n      return null;\n    };\n    /**\n     * Creates a PacketWrapperFromServer message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof PacketWrapperFromServer\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {PacketWrapperFromServer} PacketWrapperFromServer\n     */\n\n\n    PacketWrapperFromServer.fromObject = function fromObject(object) {\n      if (object instanceof $root.PacketWrapperFromServer) return object;\n      var message = new $root.PacketWrapperFromServer();\n\n      if (object.undecodedSecondsField != null) {\n        if (typeof object.undecodedSecondsField !== 'object') throw TypeError('.PacketWrapperFromServer.undecodedSecondsField: object expected');\n        message.undecodedSecondsField = $root.UndecodedSeconds.fromObject(object.undecodedSecondsField);\n      }\n\n      if (object.fullyFinalizedField != null) {\n        if (typeof object.fullyFinalizedField !== 'object') throw TypeError('.PacketWrapperFromServer.fullyFinalizedField: object expected');\n        message.fullyFinalizedField = $root.FullyFinalized.fromObject(object.fullyFinalizedField);\n      }\n\n      if (object.decoderResultField != null) {\n        if (typeof object.decoderResultField !== 'object') throw TypeError('.PacketWrapperFromServer.decoderResultField: object expected');\n        message.decoderResultField = $root.DecoderResult.fromObject(object.decoderResultField);\n      }\n\n      if (object.errorResponse != null) {\n        if (typeof object.errorResponse !== 'object') throw TypeError('.PacketWrapperFromServer.errorResponse: object expected');\n        message.errorResponse = $root.ErrorResponse.fromObject(object.errorResponse);\n      }\n\n      return message;\n    };\n    /**\n     * Creates a plain object from a PacketWrapperFromServer message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof PacketWrapperFromServer\n     * @static\n     * @param {PacketWrapperFromServer} message PacketWrapperFromServer\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    PacketWrapperFromServer.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n\n      if (message.undecodedSecondsField != null && message.hasOwnProperty('undecodedSecondsField')) {\n        object.undecodedSecondsField = $root.UndecodedSeconds.toObject(message.undecodedSecondsField, options);\n        if (options.oneofs) object.MessageType = 'undecodedSecondsField';\n      }\n\n      if (message.fullyFinalizedField != null && message.hasOwnProperty('fullyFinalizedField')) {\n        object.fullyFinalizedField = $root.FullyFinalized.toObject(message.fullyFinalizedField, options);\n        if (options.oneofs) object.MessageType = 'fullyFinalizedField';\n      }\n\n      if (message.decoderResultField != null && message.hasOwnProperty('decoderResultField')) {\n        object.decoderResultField = $root.DecoderResult.toObject(message.decoderResultField, options);\n        if (options.oneofs) object.MessageType = 'decoderResultField';\n      }\n\n      if (message.errorResponse != null && message.hasOwnProperty('errorResponse')) {\n        object.errorResponse = $root.ErrorResponse.toObject(message.errorResponse, options);\n        if (options.oneofs) object.MessageType = 'errorResponse';\n      }\n\n      return object;\n    };\n    /**\n     * Converts this PacketWrapperFromServer to JSON.\n     * @function toJSON\n     * @memberof PacketWrapperFromServer\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    PacketWrapperFromServer.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return PacketWrapperFromServer;\n  }();\n\n  return $root;\n});","map":{"version":3,"sources":["/home/zelairy/ /todo-canvas-app/node_modules/@sberdevices/assistant-client/dist/asr/index.js"],"names":["global","factory","define","amd","require","module","exports","$protobuf","$Reader","Reader","$Writer","Writer","$util","util","$root","roots","Data","properties","keys","Object","i","length","prototype","streamName","data","newBuffer","create","encode","message","writer","hasOwnProperty","call","uint32","string","bytes","encodeDelimited","ldelim","decode","reader","end","undefined","len","pos","tag","skipType","decodeDelimited","verify","isString","fromObject","object","String","base64","toObject","options","defaults","Array","slice","toJSON","constructor","toJSONOptions","Variables","variables","emptyObject","fork","key","skip","isObject","TypeError","objects","keys2","j","Info","info","messageId","channelName","sessionId","userId","Finalized","SetOptions","nonFinalHypothesisOptions","shortPhraseModelOptions","sampleRateOptions","audioEncodingOptions","languageOptions","profanityFilterOptions","normalizationOptions","nBestOptions","modelOptions","NonFinalHypothesisOptions","ShortPhraseModelOptions","SampleRateOptions","AudioEncodingOptions","LanguageOptions","ProfanityFilterOptions","NormalizationOptions","NBestOptions","ModelOptions","error","enableNonFinalHypothesisReport","nonFinalHypothesisReportIntervalSeconds","bool","float","Boolean","Number","json","isFinite","enableShortPhraseModel","shortPhraseModelCutoff","sampleRate","int32","isInteger","AudioEncoding","valuesById","values","encoding","enums","languageCode","enable","count","contexts","modelName","emptyArray","Context","push","isArray","arrays","prefixes","id","contextType","ContextType","UndecodedSeconds","undecodedSeconds","FullyFinalized","EmotionResult","name","confidence","Hypothesis","words","acousticCost","linguisticCost","finalCost","phraseStart","phraseEnd","normalizedText","DecoderResult","hypothesis","emotionResult","contextAnswer","chunkStart","chunkEnd","timeEndpointDetectionMs","timeDecodingMs","isFinal","ContextAnswer","contextResult","ContextRef","index","originalValue","predictedValue","score","ErrorResponse","errorMessage","PacketWrapperToServer","dataField","infoField","finalizedField","setOptionsField","$oneOfFields","defineProperty","get","oneOfGetter","set","oneOfSetter","MessageType","oneofs","PacketWrapperFromServer","undecodedSecondsField","fullyFinalizedField","decoderResultField","errorResponse"],"mappings":"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","sourcesContent":["\"use strict\";\n/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n(function (global, factory) {\n    /* global define, require, module */\n    /* AMD */ if (typeof define === 'function' && define.amd)\n        define(['protobufjs/minimal'], factory);\n    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)\n        module.exports = factory(require('protobufjs/minimal'));\n})(this, function ($protobuf) {\n    'use strict';\n    // Common aliases\n    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n    // Exported root namespace\n    var $root = $protobuf.roots['default'] || ($protobuf.roots['default'] = {});\n    $root.Data = (function () {\n        /**\n         * Properties of a Data.\n         * @exports IData\n         * @interface IData\n         * @property {string|null} [streamName] Data streamName\n         * @property {Uint8Array|null} [data] Data data\n         */\n        /**\n         * Constructs a new Data.\n         * @exports Data\n         * @classdesc Represents a Data.\n         * @implements IData\n         * @constructor\n         * @param {IData=} [properties] Properties to set\n         */\n        function Data(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * Data streamName.\n         * @member {string} streamName\n         * @memberof Data\n         * @instance\n         */\n        Data.prototype.streamName = '';\n        /**\n         * Data data.\n         * @member {Uint8Array} data\n         * @memberof Data\n         * @instance\n         */\n        Data.prototype.data = $util.newBuffer([]);\n        /**\n         * Creates a new Data instance using the specified properties.\n         * @function create\n         * @memberof Data\n         * @static\n         * @param {IData=} [properties] Properties to set\n         * @returns {Data} Data instance\n         */\n        Data.create = function create(properties) {\n            return new Data(properties);\n        };\n        /**\n         * Encodes the specified Data message. Does not implicitly {@link Data.verify|verify} messages.\n         * @function encode\n         * @memberof Data\n         * @static\n         * @param {IData} message Data message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Data.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.streamName != null && Object.hasOwnProperty.call(message, 'streamName'))\n                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.streamName);\n            if (message.data != null && Object.hasOwnProperty.call(message, 'data'))\n                writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.data);\n            return writer;\n        };\n        /**\n         * Encodes the specified Data message, length delimited. Does not implicitly {@link Data.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Data\n         * @static\n         * @param {IData} message Data message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Data.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a Data message from the specified reader or buffer.\n         * @function decode\n         * @memberof Data\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Data} Data\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Data.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Data();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.streamName = reader.string();\n                        break;\n                    case 2:\n                        message.data = reader.bytes();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        /**\n         * Decodes a Data message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Data\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Data} Data\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Data.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a Data message.\n         * @function verify\n         * @memberof Data\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Data.verify = function verify(message) {\n            if (typeof message !== 'object' || message === null)\n                return 'object expected';\n            if (message.streamName != null && message.hasOwnProperty('streamName'))\n                if (!$util.isString(message.streamName))\n                    return 'streamName: string expected';\n            if (message.data != null && message.hasOwnProperty('data'))\n                if (!((message.data && typeof message.data.length === 'number') || $util.isString(message.data)))\n                    return 'data: buffer expected';\n            return null;\n        };\n        /**\n         * Creates a Data message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Data\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Data} Data\n         */\n        Data.fromObject = function fromObject(object) {\n            if (object instanceof $root.Data)\n                return object;\n            var message = new $root.Data();\n            if (object.streamName != null)\n                message.streamName = String(object.streamName);\n            if (object.data != null)\n                if (typeof object.data === 'string')\n                    $util.base64.decode(object.data, (message.data = $util.newBuffer($util.base64.length(object.data))), 0);\n                else if (object.data.length)\n                    message.data = object.data;\n            return message;\n        };\n        /**\n         * Creates a plain object from a Data message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Data\n         * @static\n         * @param {Data} message Data\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Data.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.streamName = '';\n                if (options.bytes === String)\n                    object.data = '';\n                else {\n                    object.data = [];\n                    if (options.bytes !== Array)\n                        object.data = $util.newBuffer(object.data);\n                }\n            }\n            if (message.streamName != null && message.hasOwnProperty('streamName'))\n                object.streamName = message.streamName;\n            if (message.data != null && message.hasOwnProperty('data'))\n                object.data =\n                    options.bytes === String\n                        ? $util.base64.encode(message.data, 0, message.data.length)\n                        : options.bytes === Array\n                            ? Array.prototype.slice.call(message.data)\n                            : message.data;\n            return object;\n        };\n        /**\n         * Converts this Data to JSON.\n         * @function toJSON\n         * @memberof Data\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Data.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        return Data;\n    })();\n    $root.Variables = (function () {\n        /**\n         * Properties of a Variables.\n         * @exports IVariables\n         * @interface IVariables\n         * @property {Object.<string,string>|null} [variables] Variables variables\n         */\n        /**\n         * Constructs a new Variables.\n         * @exports Variables\n         * @classdesc Represents a Variables.\n         * @implements IVariables\n         * @constructor\n         * @param {IVariables=} [properties] Properties to set\n         */\n        function Variables(properties) {\n            this.variables = {};\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * Variables variables.\n         * @member {Object.<string,string>} variables\n         * @memberof Variables\n         * @instance\n         */\n        Variables.prototype.variables = $util.emptyObject;\n        /**\n         * Creates a new Variables instance using the specified properties.\n         * @function create\n         * @memberof Variables\n         * @static\n         * @param {IVariables=} [properties] Properties to set\n         * @returns {Variables} Variables instance\n         */\n        Variables.create = function create(properties) {\n            return new Variables(properties);\n        };\n        /**\n         * Encodes the specified Variables message. Does not implicitly {@link Variables.verify|verify} messages.\n         * @function encode\n         * @memberof Variables\n         * @static\n         * @param {IVariables} message Variables message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Variables.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.variables != null && Object.hasOwnProperty.call(message, 'variables'))\n                for (var keys = Object.keys(message.variables), i = 0; i < keys.length; ++i)\n                    writer\n                        .uint32(/* id 1, wireType 2 =*/ 10)\n                        .fork()\n                        .uint32(/* id 1, wireType 2 =*/ 10)\n                        .string(keys[i])\n                        .uint32(/* id 2, wireType 2 =*/ 18)\n                        .string(message.variables[keys[i]])\n                        .ldelim();\n            return writer;\n        };\n        /**\n         * Encodes the specified Variables message, length delimited. Does not implicitly {@link Variables.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Variables\n         * @static\n         * @param {IVariables} message Variables message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Variables.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a Variables message from the specified reader or buffer.\n         * @function decode\n         * @memberof Variables\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Variables} Variables\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Variables.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Variables(), key;\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        reader.skip().pos++;\n                        if (message.variables === $util.emptyObject)\n                            message.variables = {};\n                        key = reader.string();\n                        reader.pos++;\n                        message.variables[key] = reader.string();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        /**\n         * Decodes a Variables message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Variables\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Variables} Variables\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Variables.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a Variables message.\n         * @function verify\n         * @memberof Variables\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Variables.verify = function verify(message) {\n            if (typeof message !== 'object' || message === null)\n                return 'object expected';\n            if (message.variables != null && message.hasOwnProperty('variables')) {\n                if (!$util.isObject(message.variables))\n                    return 'variables: object expected';\n                var key = Object.keys(message.variables);\n                for (var i = 0; i < key.length; ++i)\n                    if (!$util.isString(message.variables[key[i]]))\n                        return 'variables: string{k:string} expected';\n            }\n            return null;\n        };\n        /**\n         * Creates a Variables message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Variables\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Variables} Variables\n         */\n        Variables.fromObject = function fromObject(object) {\n            if (object instanceof $root.Variables)\n                return object;\n            var message = new $root.Variables();\n            if (object.variables) {\n                if (typeof object.variables !== 'object')\n                    throw TypeError('.Variables.variables: object expected');\n                message.variables = {};\n                for (var keys = Object.keys(object.variables), i = 0; i < keys.length; ++i)\n                    message.variables[keys[i]] = String(object.variables[keys[i]]);\n            }\n            return message;\n        };\n        /**\n         * Creates a plain object from a Variables message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Variables\n         * @static\n         * @param {Variables} message Variables\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Variables.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.objects || options.defaults)\n                object.variables = {};\n            var keys2;\n            if (message.variables && (keys2 = Object.keys(message.variables)).length) {\n                object.variables = {};\n                for (var j = 0; j < keys2.length; ++j)\n                    object.variables[keys2[j]] = message.variables[keys2[j]];\n            }\n            return object;\n        };\n        /**\n         * Converts this Variables to JSON.\n         * @function toJSON\n         * @memberof Variables\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Variables.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        return Variables;\n    })();\n    $root.Info = (function () {\n        /**\n         * Properties of an Info.\n         * @exports IInfo\n         * @interface IInfo\n         * @property {string|null} [info] Info info\n         * @property {string|null} [messageId] Info messageId\n         * @property {string|null} [channelName] Info channelName\n         * @property {string|null} [sessionId] Info sessionId\n         * @property {string|null} [userId] Info userId\n         */\n        /**\n         * Constructs a new Info.\n         * @exports Info\n         * @classdesc Represents an Info.\n         * @implements IInfo\n         * @constructor\n         * @param {IInfo=} [properties] Properties to set\n         */\n        function Info(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * Info info.\n         * @member {string} info\n         * @memberof Info\n         * @instance\n         */\n        Info.prototype.info = '';\n        /**\n         * Info messageId.\n         * @member {string} messageId\n         * @memberof Info\n         * @instance\n         */\n        Info.prototype.messageId = '';\n        /**\n         * Info channelName.\n         * @member {string} channelName\n         * @memberof Info\n         * @instance\n         */\n        Info.prototype.channelName = '';\n        /**\n         * Info sessionId.\n         * @member {string} sessionId\n         * @memberof Info\n         * @instance\n         */\n        Info.prototype.sessionId = '';\n        /**\n         * Info userId.\n         * @member {string} userId\n         * @memberof Info\n         * @instance\n         */\n        Info.prototype.userId = '';\n        /**\n         * Creates a new Info instance using the specified properties.\n         * @function create\n         * @memberof Info\n         * @static\n         * @param {IInfo=} [properties] Properties to set\n         * @returns {Info} Info instance\n         */\n        Info.create = function create(properties) {\n            return new Info(properties);\n        };\n        /**\n         * Encodes the specified Info message. Does not implicitly {@link Info.verify|verify} messages.\n         * @function encode\n         * @memberof Info\n         * @static\n         * @param {IInfo} message Info message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Info.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.info != null && Object.hasOwnProperty.call(message, 'info'))\n                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.info);\n            if (message.messageId != null && Object.hasOwnProperty.call(message, 'messageId'))\n                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.messageId);\n            if (message.channelName != null && Object.hasOwnProperty.call(message, 'channelName'))\n                writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.channelName);\n            if (message.sessionId != null && Object.hasOwnProperty.call(message, 'sessionId'))\n                writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.sessionId);\n            if (message.userId != null && Object.hasOwnProperty.call(message, 'userId'))\n                writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.userId);\n            return writer;\n        };\n        /**\n         * Encodes the specified Info message, length delimited. Does not implicitly {@link Info.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Info\n         * @static\n         * @param {IInfo} message Info message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Info.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes an Info message from the specified reader or buffer.\n         * @function decode\n         * @memberof Info\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Info} Info\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Info.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Info();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.info = reader.string();\n                        break;\n                    case 2:\n                        message.messageId = reader.string();\n                        break;\n                    case 3:\n                        message.channelName = reader.string();\n                        break;\n                    case 4:\n                        message.sessionId = reader.string();\n                        break;\n                    case 5:\n                        message.userId = reader.string();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        /**\n         * Decodes an Info message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Info\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Info} Info\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Info.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies an Info message.\n         * @function verify\n         * @memberof Info\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Info.verify = function verify(message) {\n            if (typeof message !== 'object' || message === null)\n                return 'object expected';\n            if (message.info != null && message.hasOwnProperty('info'))\n                if (!$util.isString(message.info))\n                    return 'info: string expected';\n            if (message.messageId != null && message.hasOwnProperty('messageId'))\n                if (!$util.isString(message.messageId))\n                    return 'messageId: string expected';\n            if (message.channelName != null && message.hasOwnProperty('channelName'))\n                if (!$util.isString(message.channelName))\n                    return 'channelName: string expected';\n            if (message.sessionId != null && message.hasOwnProperty('sessionId'))\n                if (!$util.isString(message.sessionId))\n                    return 'sessionId: string expected';\n            if (message.userId != null && message.hasOwnProperty('userId'))\n                if (!$util.isString(message.userId))\n                    return 'userId: string expected';\n            return null;\n        };\n        /**\n         * Creates an Info message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Info\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Info} Info\n         */\n        Info.fromObject = function fromObject(object) {\n            if (object instanceof $root.Info)\n                return object;\n            var message = new $root.Info();\n            if (object.info != null)\n                message.info = String(object.info);\n            if (object.messageId != null)\n                message.messageId = String(object.messageId);\n            if (object.channelName != null)\n                message.channelName = String(object.channelName);\n            if (object.sessionId != null)\n                message.sessionId = String(object.sessionId);\n            if (object.userId != null)\n                message.userId = String(object.userId);\n            return message;\n        };\n        /**\n         * Creates a plain object from an Info message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Info\n         * @static\n         * @param {Info} message Info\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Info.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.info = '';\n                object.messageId = '';\n                object.channelName = '';\n                object.sessionId = '';\n                object.userId = '';\n            }\n            if (message.info != null && message.hasOwnProperty('info'))\n                object.info = message.info;\n            if (message.messageId != null && message.hasOwnProperty('messageId'))\n                object.messageId = message.messageId;\n            if (message.channelName != null && message.hasOwnProperty('channelName'))\n                object.channelName = message.channelName;\n            if (message.sessionId != null && message.hasOwnProperty('sessionId'))\n                object.sessionId = message.sessionId;\n            if (message.userId != null && message.hasOwnProperty('userId'))\n                object.userId = message.userId;\n            return object;\n        };\n        /**\n         * Converts this Info to JSON.\n         * @function toJSON\n         * @memberof Info\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Info.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        return Info;\n    })();\n    $root.Finalized = (function () {\n        /**\n         * Properties of a Finalized.\n         * @exports IFinalized\n         * @interface IFinalized\n         */\n        /**\n         * Constructs a new Finalized.\n         * @exports Finalized\n         * @classdesc Represents a Finalized.\n         * @implements IFinalized\n         * @constructor\n         * @param {IFinalized=} [properties] Properties to set\n         */\n        function Finalized(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * Creates a new Finalized instance using the specified properties.\n         * @function create\n         * @memberof Finalized\n         * @static\n         * @param {IFinalized=} [properties] Properties to set\n         * @returns {Finalized} Finalized instance\n         */\n        Finalized.create = function create(properties) {\n            return new Finalized(properties);\n        };\n        /**\n         * Encodes the specified Finalized message. Does not implicitly {@link Finalized.verify|verify} messages.\n         * @function encode\n         * @memberof Finalized\n         * @static\n         * @param {IFinalized} message Finalized message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Finalized.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            return writer;\n        };\n        /**\n         * Encodes the specified Finalized message, length delimited. Does not implicitly {@link Finalized.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Finalized\n         * @static\n         * @param {IFinalized} message Finalized message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Finalized.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a Finalized message from the specified reader or buffer.\n         * @function decode\n         * @memberof Finalized\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Finalized} Finalized\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Finalized.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Finalized();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        /**\n         * Decodes a Finalized message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Finalized\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Finalized} Finalized\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Finalized.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a Finalized message.\n         * @function verify\n         * @memberof Finalized\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Finalized.verify = function verify(message) {\n            if (typeof message !== 'object' || message === null)\n                return 'object expected';\n            return null;\n        };\n        /**\n         * Creates a Finalized message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Finalized\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Finalized} Finalized\n         */\n        Finalized.fromObject = function fromObject(object) {\n            if (object instanceof $root.Finalized)\n                return object;\n            return new $root.Finalized();\n        };\n        /**\n         * Creates a plain object from a Finalized message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Finalized\n         * @static\n         * @param {Finalized} message Finalized\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Finalized.toObject = function toObject() {\n            return {};\n        };\n        /**\n         * Converts this Finalized to JSON.\n         * @function toJSON\n         * @memberof Finalized\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Finalized.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        return Finalized;\n    })();\n    $root.SetOptions = (function () {\n        /**\n         * Properties of a SetOptions.\n         * @exports ISetOptions\n         * @interface ISetOptions\n         * @property {SetOptions.INonFinalHypothesisOptions|null} [nonFinalHypothesisOptions] SetOptions nonFinalHypothesisOptions\n         * @property {SetOptions.IShortPhraseModelOptions|null} [shortPhraseModelOptions] SetOptions shortPhraseModelOptions\n         * @property {SetOptions.ISampleRateOptions|null} [sampleRateOptions] SetOptions sampleRateOptions\n         * @property {SetOptions.IAudioEncodingOptions|null} [audioEncodingOptions] SetOptions audioEncodingOptions\n         * @property {SetOptions.ILanguageOptions|null} [languageOptions] SetOptions languageOptions\n         * @property {SetOptions.IProfanityFilterOptions|null} [profanityFilterOptions] SetOptions profanityFilterOptions\n         * @property {SetOptions.INormalizationOptions|null} [normalizationOptions] SetOptions normalizationOptions\n         * @property {SetOptions.INBestOptions|null} [nBestOptions] SetOptions nBestOptions\n         * @property {SetOptions.IModelOptions|null} [modelOptions] SetOptions modelOptions\n         * @property {IInfo|null} [info] SetOptions info\n         */\n        /**\n         * Constructs a new SetOptions.\n         * @exports SetOptions\n         * @classdesc Represents a SetOptions.\n         * @implements ISetOptions\n         * @constructor\n         * @param {ISetOptions=} [properties] Properties to set\n         */\n        function SetOptions(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * SetOptions nonFinalHypothesisOptions.\n         * @member {SetOptions.INonFinalHypothesisOptions|null|undefined} nonFinalHypothesisOptions\n         * @memberof SetOptions\n         * @instance\n         */\n        SetOptions.prototype.nonFinalHypothesisOptions = null;\n        /**\n         * SetOptions shortPhraseModelOptions.\n         * @member {SetOptions.IShortPhraseModelOptions|null|undefined} shortPhraseModelOptions\n         * @memberof SetOptions\n         * @instance\n         */\n        SetOptions.prototype.shortPhraseModelOptions = null;\n        /**\n         * SetOptions sampleRateOptions.\n         * @member {SetOptions.ISampleRateOptions|null|undefined} sampleRateOptions\n         * @memberof SetOptions\n         * @instance\n         */\n        SetOptions.prototype.sampleRateOptions = null;\n        /**\n         * SetOptions audioEncodingOptions.\n         * @member {SetOptions.IAudioEncodingOptions|null|undefined} audioEncodingOptions\n         * @memberof SetOptions\n         * @instance\n         */\n        SetOptions.prototype.audioEncodingOptions = null;\n        /**\n         * SetOptions languageOptions.\n         * @member {SetOptions.ILanguageOptions|null|undefined} languageOptions\n         * @memberof SetOptions\n         * @instance\n         */\n        SetOptions.prototype.languageOptions = null;\n        /**\n         * SetOptions profanityFilterOptions.\n         * @member {SetOptions.IProfanityFilterOptions|null|undefined} profanityFilterOptions\n         * @memberof SetOptions\n         * @instance\n         */\n        SetOptions.prototype.profanityFilterOptions = null;\n        /**\n         * SetOptions normalizationOptions.\n         * @member {SetOptions.INormalizationOptions|null|undefined} normalizationOptions\n         * @memberof SetOptions\n         * @instance\n         */\n        SetOptions.prototype.normalizationOptions = null;\n        /**\n         * SetOptions nBestOptions.\n         * @member {SetOptions.INBestOptions|null|undefined} nBestOptions\n         * @memberof SetOptions\n         * @instance\n         */\n        SetOptions.prototype.nBestOptions = null;\n        /**\n         * SetOptions modelOptions.\n         * @member {SetOptions.IModelOptions|null|undefined} modelOptions\n         * @memberof SetOptions\n         * @instance\n         */\n        SetOptions.prototype.modelOptions = null;\n        /**\n         * SetOptions info.\n         * @member {IInfo|null|undefined} info\n         * @memberof SetOptions\n         * @instance\n         */\n        SetOptions.prototype.info = null;\n        /**\n         * Creates a new SetOptions instance using the specified properties.\n         * @function create\n         * @memberof SetOptions\n         * @static\n         * @param {ISetOptions=} [properties] Properties to set\n         * @returns {SetOptions} SetOptions instance\n         */\n        SetOptions.create = function create(properties) {\n            return new SetOptions(properties);\n        };\n        /**\n         * Encodes the specified SetOptions message. Does not implicitly {@link SetOptions.verify|verify} messages.\n         * @function encode\n         * @memberof SetOptions\n         * @static\n         * @param {ISetOptions} message SetOptions message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        SetOptions.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.nonFinalHypothesisOptions != null &&\n                Object.hasOwnProperty.call(message, 'nonFinalHypothesisOptions'))\n                $root.SetOptions.NonFinalHypothesisOptions.encode(message.nonFinalHypothesisOptions, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();\n            if (message.shortPhraseModelOptions != null &&\n                Object.hasOwnProperty.call(message, 'shortPhraseModelOptions'))\n                $root.SetOptions.ShortPhraseModelOptions.encode(message.shortPhraseModelOptions, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();\n            if (message.sampleRateOptions != null && Object.hasOwnProperty.call(message, 'sampleRateOptions'))\n                $root.SetOptions.SampleRateOptions.encode(message.sampleRateOptions, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();\n            if (message.audioEncodingOptions != null && Object.hasOwnProperty.call(message, 'audioEncodingOptions'))\n                $root.SetOptions.AudioEncodingOptions.encode(message.audioEncodingOptions, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();\n            if (message.languageOptions != null && Object.hasOwnProperty.call(message, 'languageOptions'))\n                $root.SetOptions.LanguageOptions.encode(message.languageOptions, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();\n            if (message.profanityFilterOptions != null && Object.hasOwnProperty.call(message, 'profanityFilterOptions'))\n                $root.SetOptions.ProfanityFilterOptions.encode(message.profanityFilterOptions, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();\n            if (message.normalizationOptions != null && Object.hasOwnProperty.call(message, 'normalizationOptions'))\n                $root.SetOptions.NormalizationOptions.encode(message.normalizationOptions, writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();\n            if (message.nBestOptions != null && Object.hasOwnProperty.call(message, 'nBestOptions'))\n                $root.SetOptions.NBestOptions.encode(message.nBestOptions, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();\n            if (message.modelOptions != null && Object.hasOwnProperty.call(message, 'modelOptions'))\n                $root.SetOptions.ModelOptions.encode(message.modelOptions, writer.uint32(/* id 9, wireType 2 =*/ 74).fork()).ldelim();\n            if (message.info != null && Object.hasOwnProperty.call(message, 'info'))\n                $root.Info.encode(message.info, writer.uint32(/* id 10, wireType 2 =*/ 82).fork()).ldelim();\n            return writer;\n        };\n        /**\n         * Encodes the specified SetOptions message, length delimited. Does not implicitly {@link SetOptions.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof SetOptions\n         * @static\n         * @param {ISetOptions} message SetOptions message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        SetOptions.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a SetOptions message from the specified reader or buffer.\n         * @function decode\n         * @memberof SetOptions\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {SetOptions} SetOptions\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        SetOptions.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SetOptions();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.nonFinalHypothesisOptions = $root.SetOptions.NonFinalHypothesisOptions.decode(reader, reader.uint32());\n                        break;\n                    case 2:\n                        message.shortPhraseModelOptions = $root.SetOptions.ShortPhraseModelOptions.decode(reader, reader.uint32());\n                        break;\n                    case 3:\n                        message.sampleRateOptions = $root.SetOptions.SampleRateOptions.decode(reader, reader.uint32());\n                        break;\n                    case 4:\n                        message.audioEncodingOptions = $root.SetOptions.AudioEncodingOptions.decode(reader, reader.uint32());\n                        break;\n                    case 5:\n                        message.languageOptions = $root.SetOptions.LanguageOptions.decode(reader, reader.uint32());\n                        break;\n                    case 6:\n                        message.profanityFilterOptions = $root.SetOptions.ProfanityFilterOptions.decode(reader, reader.uint32());\n                        break;\n                    case 7:\n                        message.normalizationOptions = $root.SetOptions.NormalizationOptions.decode(reader, reader.uint32());\n                        break;\n                    case 8:\n                        message.nBestOptions = $root.SetOptions.NBestOptions.decode(reader, reader.uint32());\n                        break;\n                    case 9:\n                        message.modelOptions = $root.SetOptions.ModelOptions.decode(reader, reader.uint32());\n                        break;\n                    case 10:\n                        message.info = $root.Info.decode(reader, reader.uint32());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        /**\n         * Decodes a SetOptions message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof SetOptions\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {SetOptions} SetOptions\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        SetOptions.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a SetOptions message.\n         * @function verify\n         * @memberof SetOptions\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        SetOptions.verify = function verify(message) {\n            if (typeof message !== 'object' || message === null)\n                return 'object expected';\n            if (message.nonFinalHypothesisOptions != null && message.hasOwnProperty('nonFinalHypothesisOptions')) {\n                var error = $root.SetOptions.NonFinalHypothesisOptions.verify(message.nonFinalHypothesisOptions);\n                if (error)\n                    return 'nonFinalHypothesisOptions.' + error;\n            }\n            if (message.shortPhraseModelOptions != null && message.hasOwnProperty('shortPhraseModelOptions')) {\n                var error = $root.SetOptions.ShortPhraseModelOptions.verify(message.shortPhraseModelOptions);\n                if (error)\n                    return 'shortPhraseModelOptions.' + error;\n            }\n            if (message.sampleRateOptions != null && message.hasOwnProperty('sampleRateOptions')) {\n                var error = $root.SetOptions.SampleRateOptions.verify(message.sampleRateOptions);\n                if (error)\n                    return 'sampleRateOptions.' + error;\n            }\n            if (message.audioEncodingOptions != null && message.hasOwnProperty('audioEncodingOptions')) {\n                var error = $root.SetOptions.AudioEncodingOptions.verify(message.audioEncodingOptions);\n                if (error)\n                    return 'audioEncodingOptions.' + error;\n            }\n            if (message.languageOptions != null && message.hasOwnProperty('languageOptions')) {\n                var error = $root.SetOptions.LanguageOptions.verify(message.languageOptions);\n                if (error)\n                    return 'languageOptions.' + error;\n            }\n            if (message.profanityFilterOptions != null && message.hasOwnProperty('profanityFilterOptions')) {\n                var error = $root.SetOptions.ProfanityFilterOptions.verify(message.profanityFilterOptions);\n                if (error)\n                    return 'profanityFilterOptions.' + error;\n            }\n            if (message.normalizationOptions != null && message.hasOwnProperty('normalizationOptions')) {\n                var error = $root.SetOptions.NormalizationOptions.verify(message.normalizationOptions);\n                if (error)\n                    return 'normalizationOptions.' + error;\n            }\n            if (message.nBestOptions != null && message.hasOwnProperty('nBestOptions')) {\n                var error = $root.SetOptions.NBestOptions.verify(message.nBestOptions);\n                if (error)\n                    return 'nBestOptions.' + error;\n            }\n            if (message.modelOptions != null && message.hasOwnProperty('modelOptions')) {\n                var error = $root.SetOptions.ModelOptions.verify(message.modelOptions);\n                if (error)\n                    return 'modelOptions.' + error;\n            }\n            if (message.info != null && message.hasOwnProperty('info')) {\n                var error = $root.Info.verify(message.info);\n                if (error)\n                    return 'info.' + error;\n            }\n            return null;\n        };\n        /**\n         * Creates a SetOptions message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof SetOptions\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {SetOptions} SetOptions\n         */\n        SetOptions.fromObject = function fromObject(object) {\n            if (object instanceof $root.SetOptions)\n                return object;\n            var message = new $root.SetOptions();\n            if (object.nonFinalHypothesisOptions != null) {\n                if (typeof object.nonFinalHypothesisOptions !== 'object')\n                    throw TypeError('.SetOptions.nonFinalHypothesisOptions: object expected');\n                message.nonFinalHypothesisOptions = $root.SetOptions.NonFinalHypothesisOptions.fromObject(object.nonFinalHypothesisOptions);\n            }\n            if (object.shortPhraseModelOptions != null) {\n                if (typeof object.shortPhraseModelOptions !== 'object')\n                    throw TypeError('.SetOptions.shortPhraseModelOptions: object expected');\n                message.shortPhraseModelOptions = $root.SetOptions.ShortPhraseModelOptions.fromObject(object.shortPhraseModelOptions);\n            }\n            if (object.sampleRateOptions != null) {\n                if (typeof object.sampleRateOptions !== 'object')\n                    throw TypeError('.SetOptions.sampleRateOptions: object expected');\n                message.sampleRateOptions = $root.SetOptions.SampleRateOptions.fromObject(object.sampleRateOptions);\n            }\n            if (object.audioEncodingOptions != null) {\n                if (typeof object.audioEncodingOptions !== 'object')\n                    throw TypeError('.SetOptions.audioEncodingOptions: object expected');\n                message.audioEncodingOptions = $root.SetOptions.AudioEncodingOptions.fromObject(object.audioEncodingOptions);\n            }\n            if (object.languageOptions != null) {\n                if (typeof object.languageOptions !== 'object')\n                    throw TypeError('.SetOptions.languageOptions: object expected');\n                message.languageOptions = $root.SetOptions.LanguageOptions.fromObject(object.languageOptions);\n            }\n            if (object.profanityFilterOptions != null) {\n                if (typeof object.profanityFilterOptions !== 'object')\n                    throw TypeError('.SetOptions.profanityFilterOptions: object expected');\n                message.profanityFilterOptions = $root.SetOptions.ProfanityFilterOptions.fromObject(object.profanityFilterOptions);\n            }\n            if (object.normalizationOptions != null) {\n                if (typeof object.normalizationOptions !== 'object')\n                    throw TypeError('.SetOptions.normalizationOptions: object expected');\n                message.normalizationOptions = $root.SetOptions.NormalizationOptions.fromObject(object.normalizationOptions);\n            }\n            if (object.nBestOptions != null) {\n                if (typeof object.nBestOptions !== 'object')\n                    throw TypeError('.SetOptions.nBestOptions: object expected');\n                message.nBestOptions = $root.SetOptions.NBestOptions.fromObject(object.nBestOptions);\n            }\n            if (object.modelOptions != null) {\n                if (typeof object.modelOptions !== 'object')\n                    throw TypeError('.SetOptions.modelOptions: object expected');\n                message.modelOptions = $root.SetOptions.ModelOptions.fromObject(object.modelOptions);\n            }\n            if (object.info != null) {\n                if (typeof object.info !== 'object')\n                    throw TypeError('.SetOptions.info: object expected');\n                message.info = $root.Info.fromObject(object.info);\n            }\n            return message;\n        };\n        /**\n         * Creates a plain object from a SetOptions message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof SetOptions\n         * @static\n         * @param {SetOptions} message SetOptions\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        SetOptions.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.nonFinalHypothesisOptions = null;\n                object.shortPhraseModelOptions = null;\n                object.sampleRateOptions = null;\n                object.audioEncodingOptions = null;\n                object.languageOptions = null;\n                object.profanityFilterOptions = null;\n                object.normalizationOptions = null;\n                object.nBestOptions = null;\n                object.modelOptions = null;\n                object.info = null;\n            }\n            if (message.nonFinalHypothesisOptions != null && message.hasOwnProperty('nonFinalHypothesisOptions'))\n                object.nonFinalHypothesisOptions = $root.SetOptions.NonFinalHypothesisOptions.toObject(message.nonFinalHypothesisOptions, options);\n            if (message.shortPhraseModelOptions != null && message.hasOwnProperty('shortPhraseModelOptions'))\n                object.shortPhraseModelOptions = $root.SetOptions.ShortPhraseModelOptions.toObject(message.shortPhraseModelOptions, options);\n            if (message.sampleRateOptions != null && message.hasOwnProperty('sampleRateOptions'))\n                object.sampleRateOptions = $root.SetOptions.SampleRateOptions.toObject(message.sampleRateOptions, options);\n            if (message.audioEncodingOptions != null && message.hasOwnProperty('audioEncodingOptions'))\n                object.audioEncodingOptions = $root.SetOptions.AudioEncodingOptions.toObject(message.audioEncodingOptions, options);\n            if (message.languageOptions != null && message.hasOwnProperty('languageOptions'))\n                object.languageOptions = $root.SetOptions.LanguageOptions.toObject(message.languageOptions, options);\n            if (message.profanityFilterOptions != null && message.hasOwnProperty('profanityFilterOptions'))\n                object.profanityFilterOptions = $root.SetOptions.ProfanityFilterOptions.toObject(message.profanityFilterOptions, options);\n            if (message.normalizationOptions != null && message.hasOwnProperty('normalizationOptions'))\n                object.normalizationOptions = $root.SetOptions.NormalizationOptions.toObject(message.normalizationOptions, options);\n            if (message.nBestOptions != null && message.hasOwnProperty('nBestOptions'))\n                object.nBestOptions = $root.SetOptions.NBestOptions.toObject(message.nBestOptions, options);\n            if (message.modelOptions != null && message.hasOwnProperty('modelOptions'))\n                object.modelOptions = $root.SetOptions.ModelOptions.toObject(message.modelOptions, options);\n            if (message.info != null && message.hasOwnProperty('info'))\n                object.info = $root.Info.toObject(message.info, options);\n            return object;\n        };\n        /**\n         * Converts this SetOptions to JSON.\n         * @function toJSON\n         * @memberof SetOptions\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        SetOptions.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        SetOptions.NonFinalHypothesisOptions = (function () {\n            /**\n             * Properties of a NonFinalHypothesisOptions.\n             * @memberof SetOptions\n             * @interface INonFinalHypothesisOptions\n             * @property {boolean|null} [enableNonFinalHypothesisReport] NonFinalHypothesisOptions enableNonFinalHypothesisReport\n             * @property {number|null} [nonFinalHypothesisReportIntervalSeconds] NonFinalHypothesisOptions nonFinalHypothesisReportIntervalSeconds\n             */\n            /**\n             * Constructs a new NonFinalHypothesisOptions.\n             * @memberof SetOptions\n             * @classdesc Represents a NonFinalHypothesisOptions.\n             * @implements INonFinalHypothesisOptions\n             * @constructor\n             * @param {SetOptions.INonFinalHypothesisOptions=} [properties] Properties to set\n             */\n            function NonFinalHypothesisOptions(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n            /**\n             * NonFinalHypothesisOptions enableNonFinalHypothesisReport.\n             * @member {boolean} enableNonFinalHypothesisReport\n             * @memberof SetOptions.NonFinalHypothesisOptions\n             * @instance\n             */\n            NonFinalHypothesisOptions.prototype.enableNonFinalHypothesisReport = false;\n            /**\n             * NonFinalHypothesisOptions nonFinalHypothesisReportIntervalSeconds.\n             * @member {number} nonFinalHypothesisReportIntervalSeconds\n             * @memberof SetOptions.NonFinalHypothesisOptions\n             * @instance\n             */\n            NonFinalHypothesisOptions.prototype.nonFinalHypothesisReportIntervalSeconds = 0;\n            /**\n             * Creates a new NonFinalHypothesisOptions instance using the specified properties.\n             * @function create\n             * @memberof SetOptions.NonFinalHypothesisOptions\n             * @static\n             * @param {SetOptions.INonFinalHypothesisOptions=} [properties] Properties to set\n             * @returns {SetOptions.NonFinalHypothesisOptions} NonFinalHypothesisOptions instance\n             */\n            NonFinalHypothesisOptions.create = function create(properties) {\n                return new NonFinalHypothesisOptions(properties);\n            };\n            /**\n             * Encodes the specified NonFinalHypothesisOptions message. Does not implicitly {@link SetOptions.NonFinalHypothesisOptions.verify|verify} messages.\n             * @function encode\n             * @memberof SetOptions.NonFinalHypothesisOptions\n             * @static\n             * @param {SetOptions.INonFinalHypothesisOptions} message NonFinalHypothesisOptions message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            NonFinalHypothesisOptions.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.enableNonFinalHypothesisReport != null &&\n                    Object.hasOwnProperty.call(message, 'enableNonFinalHypothesisReport'))\n                    writer.uint32(/* id 1, wireType 0 =*/ 8).bool(message.enableNonFinalHypothesisReport);\n                if (message.nonFinalHypothesisReportIntervalSeconds != null &&\n                    Object.hasOwnProperty.call(message, 'nonFinalHypothesisReportIntervalSeconds'))\n                    writer.uint32(/* id 2, wireType 5 =*/ 21).float(message.nonFinalHypothesisReportIntervalSeconds);\n                return writer;\n            };\n            /**\n             * Encodes the specified NonFinalHypothesisOptions message, length delimited. Does not implicitly {@link SetOptions.NonFinalHypothesisOptions.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof SetOptions.NonFinalHypothesisOptions\n             * @static\n             * @param {SetOptions.INonFinalHypothesisOptions} message NonFinalHypothesisOptions message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            NonFinalHypothesisOptions.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n            /**\n             * Decodes a NonFinalHypothesisOptions message from the specified reader or buffer.\n             * @function decode\n             * @memberof SetOptions.NonFinalHypothesisOptions\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {SetOptions.NonFinalHypothesisOptions} NonFinalHypothesisOptions\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            NonFinalHypothesisOptions.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SetOptions.NonFinalHypothesisOptions();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            message.enableNonFinalHypothesisReport = reader.bool();\n                            break;\n                        case 2:\n                            message.nonFinalHypothesisReportIntervalSeconds = reader.float();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return message;\n            };\n            /**\n             * Decodes a NonFinalHypothesisOptions message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof SetOptions.NonFinalHypothesisOptions\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {SetOptions.NonFinalHypothesisOptions} NonFinalHypothesisOptions\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            NonFinalHypothesisOptions.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n            /**\n             * Verifies a NonFinalHypothesisOptions message.\n             * @function verify\n             * @memberof SetOptions.NonFinalHypothesisOptions\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            NonFinalHypothesisOptions.verify = function verify(message) {\n                if (typeof message !== 'object' || message === null)\n                    return 'object expected';\n                if (message.enableNonFinalHypothesisReport != null &&\n                    message.hasOwnProperty('enableNonFinalHypothesisReport'))\n                    if (typeof message.enableNonFinalHypothesisReport !== 'boolean')\n                        return 'enableNonFinalHypothesisReport: boolean expected';\n                if (message.nonFinalHypothesisReportIntervalSeconds != null &&\n                    message.hasOwnProperty('nonFinalHypothesisReportIntervalSeconds'))\n                    if (typeof message.nonFinalHypothesisReportIntervalSeconds !== 'number')\n                        return 'nonFinalHypothesisReportIntervalSeconds: number expected';\n                return null;\n            };\n            /**\n             * Creates a NonFinalHypothesisOptions message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof SetOptions.NonFinalHypothesisOptions\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {SetOptions.NonFinalHypothesisOptions} NonFinalHypothesisOptions\n             */\n            NonFinalHypothesisOptions.fromObject = function fromObject(object) {\n                if (object instanceof $root.SetOptions.NonFinalHypothesisOptions)\n                    return object;\n                var message = new $root.SetOptions.NonFinalHypothesisOptions();\n                if (object.enableNonFinalHypothesisReport != null)\n                    message.enableNonFinalHypothesisReport = Boolean(object.enableNonFinalHypothesisReport);\n                if (object.nonFinalHypothesisReportIntervalSeconds != null)\n                    message.nonFinalHypothesisReportIntervalSeconds = Number(object.nonFinalHypothesisReportIntervalSeconds);\n                return message;\n            };\n            /**\n             * Creates a plain object from a NonFinalHypothesisOptions message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof SetOptions.NonFinalHypothesisOptions\n             * @static\n             * @param {SetOptions.NonFinalHypothesisOptions} message NonFinalHypothesisOptions\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            NonFinalHypothesisOptions.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    object.enableNonFinalHypothesisReport = false;\n                    object.nonFinalHypothesisReportIntervalSeconds = 0;\n                }\n                if (message.enableNonFinalHypothesisReport != null &&\n                    message.hasOwnProperty('enableNonFinalHypothesisReport'))\n                    object.enableNonFinalHypothesisReport = message.enableNonFinalHypothesisReport;\n                if (message.nonFinalHypothesisReportIntervalSeconds != null &&\n                    message.hasOwnProperty('nonFinalHypothesisReportIntervalSeconds'))\n                    object.nonFinalHypothesisReportIntervalSeconds =\n                        options.json && !isFinite(message.nonFinalHypothesisReportIntervalSeconds)\n                            ? String(message.nonFinalHypothesisReportIntervalSeconds)\n                            : message.nonFinalHypothesisReportIntervalSeconds;\n                return object;\n            };\n            /**\n             * Converts this NonFinalHypothesisOptions to JSON.\n             * @function toJSON\n             * @memberof SetOptions.NonFinalHypothesisOptions\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            NonFinalHypothesisOptions.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n            return NonFinalHypothesisOptions;\n        })();\n        SetOptions.ShortPhraseModelOptions = (function () {\n            /**\n             * Properties of a ShortPhraseModelOptions.\n             * @memberof SetOptions\n             * @interface IShortPhraseModelOptions\n             * @property {boolean|null} [enableShortPhraseModel] ShortPhraseModelOptions enableShortPhraseModel\n             * @property {number|null} [shortPhraseModelCutoff] ShortPhraseModelOptions shortPhraseModelCutoff\n             */\n            /**\n             * Constructs a new ShortPhraseModelOptions.\n             * @memberof SetOptions\n             * @classdesc Represents a ShortPhraseModelOptions.\n             * @implements IShortPhraseModelOptions\n             * @constructor\n             * @param {SetOptions.IShortPhraseModelOptions=} [properties] Properties to set\n             */\n            function ShortPhraseModelOptions(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n            /**\n             * ShortPhraseModelOptions enableShortPhraseModel.\n             * @member {boolean} enableShortPhraseModel\n             * @memberof SetOptions.ShortPhraseModelOptions\n             * @instance\n             */\n            ShortPhraseModelOptions.prototype.enableShortPhraseModel = false;\n            /**\n             * ShortPhraseModelOptions shortPhraseModelCutoff.\n             * @member {number} shortPhraseModelCutoff\n             * @memberof SetOptions.ShortPhraseModelOptions\n             * @instance\n             */\n            ShortPhraseModelOptions.prototype.shortPhraseModelCutoff = 0;\n            /**\n             * Creates a new ShortPhraseModelOptions instance using the specified properties.\n             * @function create\n             * @memberof SetOptions.ShortPhraseModelOptions\n             * @static\n             * @param {SetOptions.IShortPhraseModelOptions=} [properties] Properties to set\n             * @returns {SetOptions.ShortPhraseModelOptions} ShortPhraseModelOptions instance\n             */\n            ShortPhraseModelOptions.create = function create(properties) {\n                return new ShortPhraseModelOptions(properties);\n            };\n            /**\n             * Encodes the specified ShortPhraseModelOptions message. Does not implicitly {@link SetOptions.ShortPhraseModelOptions.verify|verify} messages.\n             * @function encode\n             * @memberof SetOptions.ShortPhraseModelOptions\n             * @static\n             * @param {SetOptions.IShortPhraseModelOptions} message ShortPhraseModelOptions message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ShortPhraseModelOptions.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.enableShortPhraseModel != null &&\n                    Object.hasOwnProperty.call(message, 'enableShortPhraseModel'))\n                    writer.uint32(/* id 1, wireType 0 =*/ 8).bool(message.enableShortPhraseModel);\n                if (message.shortPhraseModelCutoff != null &&\n                    Object.hasOwnProperty.call(message, 'shortPhraseModelCutoff'))\n                    writer.uint32(/* id 2, wireType 5 =*/ 21).float(message.shortPhraseModelCutoff);\n                return writer;\n            };\n            /**\n             * Encodes the specified ShortPhraseModelOptions message, length delimited. Does not implicitly {@link SetOptions.ShortPhraseModelOptions.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof SetOptions.ShortPhraseModelOptions\n             * @static\n             * @param {SetOptions.IShortPhraseModelOptions} message ShortPhraseModelOptions message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ShortPhraseModelOptions.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n            /**\n             * Decodes a ShortPhraseModelOptions message from the specified reader or buffer.\n             * @function decode\n             * @memberof SetOptions.ShortPhraseModelOptions\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {SetOptions.ShortPhraseModelOptions} ShortPhraseModelOptions\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ShortPhraseModelOptions.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SetOptions.ShortPhraseModelOptions();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            message.enableShortPhraseModel = reader.bool();\n                            break;\n                        case 2:\n                            message.shortPhraseModelCutoff = reader.float();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return message;\n            };\n            /**\n             * Decodes a ShortPhraseModelOptions message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof SetOptions.ShortPhraseModelOptions\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {SetOptions.ShortPhraseModelOptions} ShortPhraseModelOptions\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ShortPhraseModelOptions.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n            /**\n             * Verifies a ShortPhraseModelOptions message.\n             * @function verify\n             * @memberof SetOptions.ShortPhraseModelOptions\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            ShortPhraseModelOptions.verify = function verify(message) {\n                if (typeof message !== 'object' || message === null)\n                    return 'object expected';\n                if (message.enableShortPhraseModel != null && message.hasOwnProperty('enableShortPhraseModel'))\n                    if (typeof message.enableShortPhraseModel !== 'boolean')\n                        return 'enableShortPhraseModel: boolean expected';\n                if (message.shortPhraseModelCutoff != null && message.hasOwnProperty('shortPhraseModelCutoff'))\n                    if (typeof message.shortPhraseModelCutoff !== 'number')\n                        return 'shortPhraseModelCutoff: number expected';\n                return null;\n            };\n            /**\n             * Creates a ShortPhraseModelOptions message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof SetOptions.ShortPhraseModelOptions\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {SetOptions.ShortPhraseModelOptions} ShortPhraseModelOptions\n             */\n            ShortPhraseModelOptions.fromObject = function fromObject(object) {\n                if (object instanceof $root.SetOptions.ShortPhraseModelOptions)\n                    return object;\n                var message = new $root.SetOptions.ShortPhraseModelOptions();\n                if (object.enableShortPhraseModel != null)\n                    message.enableShortPhraseModel = Boolean(object.enableShortPhraseModel);\n                if (object.shortPhraseModelCutoff != null)\n                    message.shortPhraseModelCutoff = Number(object.shortPhraseModelCutoff);\n                return message;\n            };\n            /**\n             * Creates a plain object from a ShortPhraseModelOptions message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof SetOptions.ShortPhraseModelOptions\n             * @static\n             * @param {SetOptions.ShortPhraseModelOptions} message ShortPhraseModelOptions\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            ShortPhraseModelOptions.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    object.enableShortPhraseModel = false;\n                    object.shortPhraseModelCutoff = 0;\n                }\n                if (message.enableShortPhraseModel != null && message.hasOwnProperty('enableShortPhraseModel'))\n                    object.enableShortPhraseModel = message.enableShortPhraseModel;\n                if (message.shortPhraseModelCutoff != null && message.hasOwnProperty('shortPhraseModelCutoff'))\n                    object.shortPhraseModelCutoff =\n                        options.json && !isFinite(message.shortPhraseModelCutoff)\n                            ? String(message.shortPhraseModelCutoff)\n                            : message.shortPhraseModelCutoff;\n                return object;\n            };\n            /**\n             * Converts this ShortPhraseModelOptions to JSON.\n             * @function toJSON\n             * @memberof SetOptions.ShortPhraseModelOptions\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            ShortPhraseModelOptions.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n            return ShortPhraseModelOptions;\n        })();\n        SetOptions.SampleRateOptions = (function () {\n            /**\n             * Properties of a SampleRateOptions.\n             * @memberof SetOptions\n             * @interface ISampleRateOptions\n             * @property {number|null} [sampleRate] SampleRateOptions sampleRate\n             */\n            /**\n             * Constructs a new SampleRateOptions.\n             * @memberof SetOptions\n             * @classdesc Represents a SampleRateOptions.\n             * @implements ISampleRateOptions\n             * @constructor\n             * @param {SetOptions.ISampleRateOptions=} [properties] Properties to set\n             */\n            function SampleRateOptions(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n            /**\n             * SampleRateOptions sampleRate.\n             * @member {number} sampleRate\n             * @memberof SetOptions.SampleRateOptions\n             * @instance\n             */\n            SampleRateOptions.prototype.sampleRate = 0;\n            /**\n             * Creates a new SampleRateOptions instance using the specified properties.\n             * @function create\n             * @memberof SetOptions.SampleRateOptions\n             * @static\n             * @param {SetOptions.ISampleRateOptions=} [properties] Properties to set\n             * @returns {SetOptions.SampleRateOptions} SampleRateOptions instance\n             */\n            SampleRateOptions.create = function create(properties) {\n                return new SampleRateOptions(properties);\n            };\n            /**\n             * Encodes the specified SampleRateOptions message. Does not implicitly {@link SetOptions.SampleRateOptions.verify|verify} messages.\n             * @function encode\n             * @memberof SetOptions.SampleRateOptions\n             * @static\n             * @param {SetOptions.ISampleRateOptions} message SampleRateOptions message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            SampleRateOptions.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.sampleRate != null && Object.hasOwnProperty.call(message, 'sampleRate'))\n                    writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.sampleRate);\n                return writer;\n            };\n            /**\n             * Encodes the specified SampleRateOptions message, length delimited. Does not implicitly {@link SetOptions.SampleRateOptions.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof SetOptions.SampleRateOptions\n             * @static\n             * @param {SetOptions.ISampleRateOptions} message SampleRateOptions message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            SampleRateOptions.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n            /**\n             * Decodes a SampleRateOptions message from the specified reader or buffer.\n             * @function decode\n             * @memberof SetOptions.SampleRateOptions\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {SetOptions.SampleRateOptions} SampleRateOptions\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            SampleRateOptions.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SetOptions.SampleRateOptions();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            message.sampleRate = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return message;\n            };\n            /**\n             * Decodes a SampleRateOptions message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof SetOptions.SampleRateOptions\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {SetOptions.SampleRateOptions} SampleRateOptions\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            SampleRateOptions.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n            /**\n             * Verifies a SampleRateOptions message.\n             * @function verify\n             * @memberof SetOptions.SampleRateOptions\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            SampleRateOptions.verify = function verify(message) {\n                if (typeof message !== 'object' || message === null)\n                    return 'object expected';\n                if (message.sampleRate != null && message.hasOwnProperty('sampleRate'))\n                    if (!$util.isInteger(message.sampleRate))\n                        return 'sampleRate: integer expected';\n                return null;\n            };\n            /**\n             * Creates a SampleRateOptions message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof SetOptions.SampleRateOptions\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {SetOptions.SampleRateOptions} SampleRateOptions\n             */\n            SampleRateOptions.fromObject = function fromObject(object) {\n                if (object instanceof $root.SetOptions.SampleRateOptions)\n                    return object;\n                var message = new $root.SetOptions.SampleRateOptions();\n                if (object.sampleRate != null)\n                    message.sampleRate = object.sampleRate | 0;\n                return message;\n            };\n            /**\n             * Creates a plain object from a SampleRateOptions message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof SetOptions.SampleRateOptions\n             * @static\n             * @param {SetOptions.SampleRateOptions} message SampleRateOptions\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            SampleRateOptions.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults)\n                    object.sampleRate = 0;\n                if (message.sampleRate != null && message.hasOwnProperty('sampleRate'))\n                    object.sampleRate = message.sampleRate;\n                return object;\n            };\n            /**\n             * Converts this SampleRateOptions to JSON.\n             * @function toJSON\n             * @memberof SetOptions.SampleRateOptions\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            SampleRateOptions.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n            return SampleRateOptions;\n        })();\n        /**\n         * AudioEncoding enum.\n         * @name SetOptions.AudioEncoding\n         * @enum {number}\n         * @property {number} PCM_S16LE=0 PCM_S16LE value\n         * @property {number} OPUS=1 OPUS value\n         */\n        SetOptions.AudioEncoding = (function () {\n            var valuesById = {}, values = Object.create(valuesById);\n            values[(valuesById[0] = 'PCM_S16LE')] = 0;\n            values[(valuesById[1] = 'OPUS')] = 1;\n            return values;\n        })();\n        SetOptions.AudioEncodingOptions = (function () {\n            /**\n             * Properties of an AudioEncodingOptions.\n             * @memberof SetOptions\n             * @interface IAudioEncodingOptions\n             * @property {SetOptions.AudioEncoding|null} [encoding] AudioEncodingOptions encoding\n             */\n            /**\n             * Constructs a new AudioEncodingOptions.\n             * @memberof SetOptions\n             * @classdesc Represents an AudioEncodingOptions.\n             * @implements IAudioEncodingOptions\n             * @constructor\n             * @param {SetOptions.IAudioEncodingOptions=} [properties] Properties to set\n             */\n            function AudioEncodingOptions(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n            /**\n             * AudioEncodingOptions encoding.\n             * @member {SetOptions.AudioEncoding} encoding\n             * @memberof SetOptions.AudioEncodingOptions\n             * @instance\n             */\n            AudioEncodingOptions.prototype.encoding = 0;\n            /**\n             * Creates a new AudioEncodingOptions instance using the specified properties.\n             * @function create\n             * @memberof SetOptions.AudioEncodingOptions\n             * @static\n             * @param {SetOptions.IAudioEncodingOptions=} [properties] Properties to set\n             * @returns {SetOptions.AudioEncodingOptions} AudioEncodingOptions instance\n             */\n            AudioEncodingOptions.create = function create(properties) {\n                return new AudioEncodingOptions(properties);\n            };\n            /**\n             * Encodes the specified AudioEncodingOptions message. Does not implicitly {@link SetOptions.AudioEncodingOptions.verify|verify} messages.\n             * @function encode\n             * @memberof SetOptions.AudioEncodingOptions\n             * @static\n             * @param {SetOptions.IAudioEncodingOptions} message AudioEncodingOptions message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            AudioEncodingOptions.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.encoding != null && Object.hasOwnProperty.call(message, 'encoding'))\n                    writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.encoding);\n                return writer;\n            };\n            /**\n             * Encodes the specified AudioEncodingOptions message, length delimited. Does not implicitly {@link SetOptions.AudioEncodingOptions.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof SetOptions.AudioEncodingOptions\n             * @static\n             * @param {SetOptions.IAudioEncodingOptions} message AudioEncodingOptions message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            AudioEncodingOptions.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n            /**\n             * Decodes an AudioEncodingOptions message from the specified reader or buffer.\n             * @function decode\n             * @memberof SetOptions.AudioEncodingOptions\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {SetOptions.AudioEncodingOptions} AudioEncodingOptions\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            AudioEncodingOptions.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SetOptions.AudioEncodingOptions();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            message.encoding = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return message;\n            };\n            /**\n             * Decodes an AudioEncodingOptions message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof SetOptions.AudioEncodingOptions\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {SetOptions.AudioEncodingOptions} AudioEncodingOptions\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            AudioEncodingOptions.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n            /**\n             * Verifies an AudioEncodingOptions message.\n             * @function verify\n             * @memberof SetOptions.AudioEncodingOptions\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            AudioEncodingOptions.verify = function verify(message) {\n                if (typeof message !== 'object' || message === null)\n                    return 'object expected';\n                if (message.encoding != null && message.hasOwnProperty('encoding'))\n                    switch (message.encoding) {\n                        default:\n                            return 'encoding: enum value expected';\n                        case 0:\n                        case 1:\n                            break;\n                    }\n                return null;\n            };\n            /**\n             * Creates an AudioEncodingOptions message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof SetOptions.AudioEncodingOptions\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {SetOptions.AudioEncodingOptions} AudioEncodingOptions\n             */\n            AudioEncodingOptions.fromObject = function fromObject(object) {\n                if (object instanceof $root.SetOptions.AudioEncodingOptions)\n                    return object;\n                var message = new $root.SetOptions.AudioEncodingOptions();\n                switch (object.encoding) {\n                    case 'PCM_S16LE':\n                    case 0:\n                        message.encoding = 0;\n                        break;\n                    case 'OPUS':\n                    case 1:\n                        message.encoding = 1;\n                        break;\n                }\n                return message;\n            };\n            /**\n             * Creates a plain object from an AudioEncodingOptions message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof SetOptions.AudioEncodingOptions\n             * @static\n             * @param {SetOptions.AudioEncodingOptions} message AudioEncodingOptions\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            AudioEncodingOptions.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults)\n                    object.encoding = options.enums === String ? 'PCM_S16LE' : 0;\n                if (message.encoding != null && message.hasOwnProperty('encoding'))\n                    object.encoding =\n                        options.enums === String ? $root.SetOptions.AudioEncoding[message.encoding] : message.encoding;\n                return object;\n            };\n            /**\n             * Converts this AudioEncodingOptions to JSON.\n             * @function toJSON\n             * @memberof SetOptions.AudioEncodingOptions\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            AudioEncodingOptions.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n            return AudioEncodingOptions;\n        })();\n        SetOptions.LanguageOptions = (function () {\n            /**\n             * Properties of a LanguageOptions.\n             * @memberof SetOptions\n             * @interface ILanguageOptions\n             * @property {string|null} [languageCode] LanguageOptions languageCode\n             */\n            /**\n             * Constructs a new LanguageOptions.\n             * @memberof SetOptions\n             * @classdesc Represents a LanguageOptions.\n             * @implements ILanguageOptions\n             * @constructor\n             * @param {SetOptions.ILanguageOptions=} [properties] Properties to set\n             */\n            function LanguageOptions(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n            /**\n             * LanguageOptions languageCode.\n             * @member {string} languageCode\n             * @memberof SetOptions.LanguageOptions\n             * @instance\n             */\n            LanguageOptions.prototype.languageCode = '';\n            /**\n             * Creates a new LanguageOptions instance using the specified properties.\n             * @function create\n             * @memberof SetOptions.LanguageOptions\n             * @static\n             * @param {SetOptions.ILanguageOptions=} [properties] Properties to set\n             * @returns {SetOptions.LanguageOptions} LanguageOptions instance\n             */\n            LanguageOptions.create = function create(properties) {\n                return new LanguageOptions(properties);\n            };\n            /**\n             * Encodes the specified LanguageOptions message. Does not implicitly {@link SetOptions.LanguageOptions.verify|verify} messages.\n             * @function encode\n             * @memberof SetOptions.LanguageOptions\n             * @static\n             * @param {SetOptions.ILanguageOptions} message LanguageOptions message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            LanguageOptions.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.languageCode != null && Object.hasOwnProperty.call(message, 'languageCode'))\n                    writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.languageCode);\n                return writer;\n            };\n            /**\n             * Encodes the specified LanguageOptions message, length delimited. Does not implicitly {@link SetOptions.LanguageOptions.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof SetOptions.LanguageOptions\n             * @static\n             * @param {SetOptions.ILanguageOptions} message LanguageOptions message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            LanguageOptions.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n            /**\n             * Decodes a LanguageOptions message from the specified reader or buffer.\n             * @function decode\n             * @memberof SetOptions.LanguageOptions\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {SetOptions.LanguageOptions} LanguageOptions\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            LanguageOptions.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SetOptions.LanguageOptions();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            message.languageCode = reader.string();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return message;\n            };\n            /**\n             * Decodes a LanguageOptions message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof SetOptions.LanguageOptions\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {SetOptions.LanguageOptions} LanguageOptions\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            LanguageOptions.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n            /**\n             * Verifies a LanguageOptions message.\n             * @function verify\n             * @memberof SetOptions.LanguageOptions\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            LanguageOptions.verify = function verify(message) {\n                if (typeof message !== 'object' || message === null)\n                    return 'object expected';\n                if (message.languageCode != null && message.hasOwnProperty('languageCode'))\n                    if (!$util.isString(message.languageCode))\n                        return 'languageCode: string expected';\n                return null;\n            };\n            /**\n             * Creates a LanguageOptions message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof SetOptions.LanguageOptions\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {SetOptions.LanguageOptions} LanguageOptions\n             */\n            LanguageOptions.fromObject = function fromObject(object) {\n                if (object instanceof $root.SetOptions.LanguageOptions)\n                    return object;\n                var message = new $root.SetOptions.LanguageOptions();\n                if (object.languageCode != null)\n                    message.languageCode = String(object.languageCode);\n                return message;\n            };\n            /**\n             * Creates a plain object from a LanguageOptions message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof SetOptions.LanguageOptions\n             * @static\n             * @param {SetOptions.LanguageOptions} message LanguageOptions\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            LanguageOptions.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults)\n                    object.languageCode = '';\n                if (message.languageCode != null && message.hasOwnProperty('languageCode'))\n                    object.languageCode = message.languageCode;\n                return object;\n            };\n            /**\n             * Converts this LanguageOptions to JSON.\n             * @function toJSON\n             * @memberof SetOptions.LanguageOptions\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            LanguageOptions.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n            return LanguageOptions;\n        })();\n        SetOptions.ProfanityFilterOptions = (function () {\n            /**\n             * Properties of a ProfanityFilterOptions.\n             * @memberof SetOptions\n             * @interface IProfanityFilterOptions\n             * @property {boolean|null} [enable] ProfanityFilterOptions enable\n             */\n            /**\n             * Constructs a new ProfanityFilterOptions.\n             * @memberof SetOptions\n             * @classdesc Represents a ProfanityFilterOptions.\n             * @implements IProfanityFilterOptions\n             * @constructor\n             * @param {SetOptions.IProfanityFilterOptions=} [properties] Properties to set\n             */\n            function ProfanityFilterOptions(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n            /**\n             * ProfanityFilterOptions enable.\n             * @member {boolean} enable\n             * @memberof SetOptions.ProfanityFilterOptions\n             * @instance\n             */\n            ProfanityFilterOptions.prototype.enable = false;\n            /**\n             * Creates a new ProfanityFilterOptions instance using the specified properties.\n             * @function create\n             * @memberof SetOptions.ProfanityFilterOptions\n             * @static\n             * @param {SetOptions.IProfanityFilterOptions=} [properties] Properties to set\n             * @returns {SetOptions.ProfanityFilterOptions} ProfanityFilterOptions instance\n             */\n            ProfanityFilterOptions.create = function create(properties) {\n                return new ProfanityFilterOptions(properties);\n            };\n            /**\n             * Encodes the specified ProfanityFilterOptions message. Does not implicitly {@link SetOptions.ProfanityFilterOptions.verify|verify} messages.\n             * @function encode\n             * @memberof SetOptions.ProfanityFilterOptions\n             * @static\n             * @param {SetOptions.IProfanityFilterOptions} message ProfanityFilterOptions message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ProfanityFilterOptions.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.enable != null && Object.hasOwnProperty.call(message, 'enable'))\n                    writer.uint32(/* id 1, wireType 0 =*/ 8).bool(message.enable);\n                return writer;\n            };\n            /**\n             * Encodes the specified ProfanityFilterOptions message, length delimited. Does not implicitly {@link SetOptions.ProfanityFilterOptions.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof SetOptions.ProfanityFilterOptions\n             * @static\n             * @param {SetOptions.IProfanityFilterOptions} message ProfanityFilterOptions message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ProfanityFilterOptions.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n            /**\n             * Decodes a ProfanityFilterOptions message from the specified reader or buffer.\n             * @function decode\n             * @memberof SetOptions.ProfanityFilterOptions\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {SetOptions.ProfanityFilterOptions} ProfanityFilterOptions\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ProfanityFilterOptions.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SetOptions.ProfanityFilterOptions();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            message.enable = reader.bool();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return message;\n            };\n            /**\n             * Decodes a ProfanityFilterOptions message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof SetOptions.ProfanityFilterOptions\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {SetOptions.ProfanityFilterOptions} ProfanityFilterOptions\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ProfanityFilterOptions.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n            /**\n             * Verifies a ProfanityFilterOptions message.\n             * @function verify\n             * @memberof SetOptions.ProfanityFilterOptions\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            ProfanityFilterOptions.verify = function verify(message) {\n                if (typeof message !== 'object' || message === null)\n                    return 'object expected';\n                if (message.enable != null && message.hasOwnProperty('enable'))\n                    if (typeof message.enable !== 'boolean')\n                        return 'enable: boolean expected';\n                return null;\n            };\n            /**\n             * Creates a ProfanityFilterOptions message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof SetOptions.ProfanityFilterOptions\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {SetOptions.ProfanityFilterOptions} ProfanityFilterOptions\n             */\n            ProfanityFilterOptions.fromObject = function fromObject(object) {\n                if (object instanceof $root.SetOptions.ProfanityFilterOptions)\n                    return object;\n                var message = new $root.SetOptions.ProfanityFilterOptions();\n                if (object.enable != null)\n                    message.enable = Boolean(object.enable);\n                return message;\n            };\n            /**\n             * Creates a plain object from a ProfanityFilterOptions message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof SetOptions.ProfanityFilterOptions\n             * @static\n             * @param {SetOptions.ProfanityFilterOptions} message ProfanityFilterOptions\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            ProfanityFilterOptions.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults)\n                    object.enable = false;\n                if (message.enable != null && message.hasOwnProperty('enable'))\n                    object.enable = message.enable;\n                return object;\n            };\n            /**\n             * Converts this ProfanityFilterOptions to JSON.\n             * @function toJSON\n             * @memberof SetOptions.ProfanityFilterOptions\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            ProfanityFilterOptions.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n            return ProfanityFilterOptions;\n        })();\n        SetOptions.NormalizationOptions = (function () {\n            /**\n             * Properties of a NormalizationOptions.\n             * @memberof SetOptions\n             * @interface INormalizationOptions\n             * @property {boolean|null} [enable] NormalizationOptions enable\n             */\n            /**\n             * Constructs a new NormalizationOptions.\n             * @memberof SetOptions\n             * @classdesc Represents a NormalizationOptions.\n             * @implements INormalizationOptions\n             * @constructor\n             * @param {SetOptions.INormalizationOptions=} [properties] Properties to set\n             */\n            function NormalizationOptions(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n            /**\n             * NormalizationOptions enable.\n             * @member {boolean} enable\n             * @memberof SetOptions.NormalizationOptions\n             * @instance\n             */\n            NormalizationOptions.prototype.enable = false;\n            /**\n             * Creates a new NormalizationOptions instance using the specified properties.\n             * @function create\n             * @memberof SetOptions.NormalizationOptions\n             * @static\n             * @param {SetOptions.INormalizationOptions=} [properties] Properties to set\n             * @returns {SetOptions.NormalizationOptions} NormalizationOptions instance\n             */\n            NormalizationOptions.create = function create(properties) {\n                return new NormalizationOptions(properties);\n            };\n            /**\n             * Encodes the specified NormalizationOptions message. Does not implicitly {@link SetOptions.NormalizationOptions.verify|verify} messages.\n             * @function encode\n             * @memberof SetOptions.NormalizationOptions\n             * @static\n             * @param {SetOptions.INormalizationOptions} message NormalizationOptions message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            NormalizationOptions.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.enable != null && Object.hasOwnProperty.call(message, 'enable'))\n                    writer.uint32(/* id 1, wireType 0 =*/ 8).bool(message.enable);\n                return writer;\n            };\n            /**\n             * Encodes the specified NormalizationOptions message, length delimited. Does not implicitly {@link SetOptions.NormalizationOptions.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof SetOptions.NormalizationOptions\n             * @static\n             * @param {SetOptions.INormalizationOptions} message NormalizationOptions message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            NormalizationOptions.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n            /**\n             * Decodes a NormalizationOptions message from the specified reader or buffer.\n             * @function decode\n             * @memberof SetOptions.NormalizationOptions\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {SetOptions.NormalizationOptions} NormalizationOptions\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            NormalizationOptions.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SetOptions.NormalizationOptions();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            message.enable = reader.bool();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return message;\n            };\n            /**\n             * Decodes a NormalizationOptions message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof SetOptions.NormalizationOptions\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {SetOptions.NormalizationOptions} NormalizationOptions\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            NormalizationOptions.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n            /**\n             * Verifies a NormalizationOptions message.\n             * @function verify\n             * @memberof SetOptions.NormalizationOptions\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            NormalizationOptions.verify = function verify(message) {\n                if (typeof message !== 'object' || message === null)\n                    return 'object expected';\n                if (message.enable != null && message.hasOwnProperty('enable'))\n                    if (typeof message.enable !== 'boolean')\n                        return 'enable: boolean expected';\n                return null;\n            };\n            /**\n             * Creates a NormalizationOptions message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof SetOptions.NormalizationOptions\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {SetOptions.NormalizationOptions} NormalizationOptions\n             */\n            NormalizationOptions.fromObject = function fromObject(object) {\n                if (object instanceof $root.SetOptions.NormalizationOptions)\n                    return object;\n                var message = new $root.SetOptions.NormalizationOptions();\n                if (object.enable != null)\n                    message.enable = Boolean(object.enable);\n                return message;\n            };\n            /**\n             * Creates a plain object from a NormalizationOptions message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof SetOptions.NormalizationOptions\n             * @static\n             * @param {SetOptions.NormalizationOptions} message NormalizationOptions\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            NormalizationOptions.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults)\n                    object.enable = false;\n                if (message.enable != null && message.hasOwnProperty('enable'))\n                    object.enable = message.enable;\n                return object;\n            };\n            /**\n             * Converts this NormalizationOptions to JSON.\n             * @function toJSON\n             * @memberof SetOptions.NormalizationOptions\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            NormalizationOptions.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n            return NormalizationOptions;\n        })();\n        SetOptions.NBestOptions = (function () {\n            /**\n             * Properties of a NBestOptions.\n             * @memberof SetOptions\n             * @interface INBestOptions\n             * @property {number|null} [count] NBestOptions count\n             */\n            /**\n             * Constructs a new NBestOptions.\n             * @memberof SetOptions\n             * @classdesc Represents a NBestOptions.\n             * @implements INBestOptions\n             * @constructor\n             * @param {SetOptions.INBestOptions=} [properties] Properties to set\n             */\n            function NBestOptions(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n            /**\n             * NBestOptions count.\n             * @member {number} count\n             * @memberof SetOptions.NBestOptions\n             * @instance\n             */\n            NBestOptions.prototype.count = 0;\n            /**\n             * Creates a new NBestOptions instance using the specified properties.\n             * @function create\n             * @memberof SetOptions.NBestOptions\n             * @static\n             * @param {SetOptions.INBestOptions=} [properties] Properties to set\n             * @returns {SetOptions.NBestOptions} NBestOptions instance\n             */\n            NBestOptions.create = function create(properties) {\n                return new NBestOptions(properties);\n            };\n            /**\n             * Encodes the specified NBestOptions message. Does not implicitly {@link SetOptions.NBestOptions.verify|verify} messages.\n             * @function encode\n             * @memberof SetOptions.NBestOptions\n             * @static\n             * @param {SetOptions.INBestOptions} message NBestOptions message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            NBestOptions.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.count != null && Object.hasOwnProperty.call(message, 'count'))\n                    writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.count);\n                return writer;\n            };\n            /**\n             * Encodes the specified NBestOptions message, length delimited. Does not implicitly {@link SetOptions.NBestOptions.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof SetOptions.NBestOptions\n             * @static\n             * @param {SetOptions.INBestOptions} message NBestOptions message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            NBestOptions.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n            /**\n             * Decodes a NBestOptions message from the specified reader or buffer.\n             * @function decode\n             * @memberof SetOptions.NBestOptions\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {SetOptions.NBestOptions} NBestOptions\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            NBestOptions.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SetOptions.NBestOptions();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            message.count = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return message;\n            };\n            /**\n             * Decodes a NBestOptions message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof SetOptions.NBestOptions\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {SetOptions.NBestOptions} NBestOptions\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            NBestOptions.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n            /**\n             * Verifies a NBestOptions message.\n             * @function verify\n             * @memberof SetOptions.NBestOptions\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            NBestOptions.verify = function verify(message) {\n                if (typeof message !== 'object' || message === null)\n                    return 'object expected';\n                if (message.count != null && message.hasOwnProperty('count'))\n                    if (!$util.isInteger(message.count))\n                        return 'count: integer expected';\n                return null;\n            };\n            /**\n             * Creates a NBestOptions message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof SetOptions.NBestOptions\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {SetOptions.NBestOptions} NBestOptions\n             */\n            NBestOptions.fromObject = function fromObject(object) {\n                if (object instanceof $root.SetOptions.NBestOptions)\n                    return object;\n                var message = new $root.SetOptions.NBestOptions();\n                if (object.count != null)\n                    message.count = object.count | 0;\n                return message;\n            };\n            /**\n             * Creates a plain object from a NBestOptions message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof SetOptions.NBestOptions\n             * @static\n             * @param {SetOptions.NBestOptions} message NBestOptions\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            NBestOptions.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults)\n                    object.count = 0;\n                if (message.count != null && message.hasOwnProperty('count'))\n                    object.count = message.count;\n                return object;\n            };\n            /**\n             * Converts this NBestOptions to JSON.\n             * @function toJSON\n             * @memberof SetOptions.NBestOptions\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            NBestOptions.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n            return NBestOptions;\n        })();\n        SetOptions.ModelOptions = (function () {\n            /**\n             * Properties of a ModelOptions.\n             * @memberof SetOptions\n             * @interface IModelOptions\n             * @property {string|null} [modelName] ModelOptions modelName\n             * @property {Array.<SetOptions.ModelOptions.IContext>|null} [contexts] ModelOptions contexts\n             */\n            /**\n             * Constructs a new ModelOptions.\n             * @memberof SetOptions\n             * @classdesc Represents a ModelOptions.\n             * @implements IModelOptions\n             * @constructor\n             * @param {SetOptions.IModelOptions=} [properties] Properties to set\n             */\n            function ModelOptions(properties) {\n                this.contexts = [];\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n            /**\n             * ModelOptions modelName.\n             * @member {string} modelName\n             * @memberof SetOptions.ModelOptions\n             * @instance\n             */\n            ModelOptions.prototype.modelName = '';\n            /**\n             * ModelOptions contexts.\n             * @member {Array.<SetOptions.ModelOptions.IContext>} contexts\n             * @memberof SetOptions.ModelOptions\n             * @instance\n             */\n            ModelOptions.prototype.contexts = $util.emptyArray;\n            /**\n             * Creates a new ModelOptions instance using the specified properties.\n             * @function create\n             * @memberof SetOptions.ModelOptions\n             * @static\n             * @param {SetOptions.IModelOptions=} [properties] Properties to set\n             * @returns {SetOptions.ModelOptions} ModelOptions instance\n             */\n            ModelOptions.create = function create(properties) {\n                return new ModelOptions(properties);\n            };\n            /**\n             * Encodes the specified ModelOptions message. Does not implicitly {@link SetOptions.ModelOptions.verify|verify} messages.\n             * @function encode\n             * @memberof SetOptions.ModelOptions\n             * @static\n             * @param {SetOptions.IModelOptions} message ModelOptions message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ModelOptions.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.modelName != null && Object.hasOwnProperty.call(message, 'modelName'))\n                    writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.modelName);\n                if (message.contexts != null && message.contexts.length)\n                    for (var i = 0; i < message.contexts.length; ++i)\n                        $root.SetOptions.ModelOptions.Context.encode(message.contexts[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();\n                return writer;\n            };\n            /**\n             * Encodes the specified ModelOptions message, length delimited. Does not implicitly {@link SetOptions.ModelOptions.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof SetOptions.ModelOptions\n             * @static\n             * @param {SetOptions.IModelOptions} message ModelOptions message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ModelOptions.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n            /**\n             * Decodes a ModelOptions message from the specified reader or buffer.\n             * @function decode\n             * @memberof SetOptions.ModelOptions\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {SetOptions.ModelOptions} ModelOptions\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ModelOptions.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SetOptions.ModelOptions();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            message.modelName = reader.string();\n                            break;\n                        case 2:\n                            if (!(message.contexts && message.contexts.length))\n                                message.contexts = [];\n                            message.contexts.push($root.SetOptions.ModelOptions.Context.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return message;\n            };\n            /**\n             * Decodes a ModelOptions message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof SetOptions.ModelOptions\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {SetOptions.ModelOptions} ModelOptions\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ModelOptions.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n            /**\n             * Verifies a ModelOptions message.\n             * @function verify\n             * @memberof SetOptions.ModelOptions\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            ModelOptions.verify = function verify(message) {\n                if (typeof message !== 'object' || message === null)\n                    return 'object expected';\n                if (message.modelName != null && message.hasOwnProperty('modelName'))\n                    if (!$util.isString(message.modelName))\n                        return 'modelName: string expected';\n                if (message.contexts != null && message.hasOwnProperty('contexts')) {\n                    if (!Array.isArray(message.contexts))\n                        return 'contexts: array expected';\n                    for (var i = 0; i < message.contexts.length; ++i) {\n                        var error = $root.SetOptions.ModelOptions.Context.verify(message.contexts[i]);\n                        if (error)\n                            return 'contexts.' + error;\n                    }\n                }\n                return null;\n            };\n            /**\n             * Creates a ModelOptions message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof SetOptions.ModelOptions\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {SetOptions.ModelOptions} ModelOptions\n             */\n            ModelOptions.fromObject = function fromObject(object) {\n                if (object instanceof $root.SetOptions.ModelOptions)\n                    return object;\n                var message = new $root.SetOptions.ModelOptions();\n                if (object.modelName != null)\n                    message.modelName = String(object.modelName);\n                if (object.contexts) {\n                    if (!Array.isArray(object.contexts))\n                        throw TypeError('.SetOptions.ModelOptions.contexts: array expected');\n                    message.contexts = [];\n                    for (var i = 0; i < object.contexts.length; ++i) {\n                        if (typeof object.contexts[i] !== 'object')\n                            throw TypeError('.SetOptions.ModelOptions.contexts: object expected');\n                        message.contexts[i] = $root.SetOptions.ModelOptions.Context.fromObject(object.contexts[i]);\n                    }\n                }\n                return message;\n            };\n            /**\n             * Creates a plain object from a ModelOptions message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof SetOptions.ModelOptions\n             * @static\n             * @param {SetOptions.ModelOptions} message ModelOptions\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            ModelOptions.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.arrays || options.defaults)\n                    object.contexts = [];\n                if (options.defaults)\n                    object.modelName = '';\n                if (message.modelName != null && message.hasOwnProperty('modelName'))\n                    object.modelName = message.modelName;\n                if (message.contexts && message.contexts.length) {\n                    object.contexts = [];\n                    for (var j = 0; j < message.contexts.length; ++j)\n                        object.contexts[j] = $root.SetOptions.ModelOptions.Context.toObject(message.contexts[j], options);\n                }\n                return object;\n            };\n            /**\n             * Converts this ModelOptions to JSON.\n             * @function toJSON\n             * @memberof SetOptions.ModelOptions\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            ModelOptions.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n            ModelOptions.Context = (function () {\n                /**\n                 * Properties of a Context.\n                 * @memberof SetOptions.ModelOptions\n                 * @interface IContext\n                 * @property {string|null} [id] Context id\n                 * @property {SetOptions.ModelOptions.Context.ContextType|null} [contextType] Context contextType\n                 * @property {Array.<string>|null} [prefixes] Context prefixes\n                 * @property {Array.<string>|null} [values] Context values\n                 */\n                /**\n                 * Constructs a new Context.\n                 * @memberof SetOptions.ModelOptions\n                 * @classdesc Represents a Context.\n                 * @implements IContext\n                 * @constructor\n                 * @param {SetOptions.ModelOptions.IContext=} [properties] Properties to set\n                 */\n                function Context(properties) {\n                    this.prefixes = [];\n                    this.values = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n                /**\n                 * Context id.\n                 * @member {string} id\n                 * @memberof SetOptions.ModelOptions.Context\n                 * @instance\n                 */\n                Context.prototype.id = '';\n                /**\n                 * Context contextType.\n                 * @member {SetOptions.ModelOptions.Context.ContextType} contextType\n                 * @memberof SetOptions.ModelOptions.Context\n                 * @instance\n                 */\n                Context.prototype.contextType = 0;\n                /**\n                 * Context prefixes.\n                 * @member {Array.<string>} prefixes\n                 * @memberof SetOptions.ModelOptions.Context\n                 * @instance\n                 */\n                Context.prototype.prefixes = $util.emptyArray;\n                /**\n                 * Context values.\n                 * @member {Array.<string>} values\n                 * @memberof SetOptions.ModelOptions.Context\n                 * @instance\n                 */\n                Context.prototype.values = $util.emptyArray;\n                /**\n                 * Creates a new Context instance using the specified properties.\n                 * @function create\n                 * @memberof SetOptions.ModelOptions.Context\n                 * @static\n                 * @param {SetOptions.ModelOptions.IContext=} [properties] Properties to set\n                 * @returns {SetOptions.ModelOptions.Context} Context instance\n                 */\n                Context.create = function create(properties) {\n                    return new Context(properties);\n                };\n                /**\n                 * Encodes the specified Context message. Does not implicitly {@link SetOptions.ModelOptions.Context.verify|verify} messages.\n                 * @function encode\n                 * @memberof SetOptions.ModelOptions.Context\n                 * @static\n                 * @param {SetOptions.ModelOptions.IContext} message Context message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Context.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.id != null && Object.hasOwnProperty.call(message, 'id'))\n                        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.id);\n                    if (message.contextType != null && Object.hasOwnProperty.call(message, 'contextType'))\n                        writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.contextType);\n                    if (message.prefixes != null && message.prefixes.length)\n                        for (var i = 0; i < message.prefixes.length; ++i)\n                            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.prefixes[i]);\n                    if (message.values != null && message.values.length)\n                        for (var i = 0; i < message.values.length; ++i)\n                            writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.values[i]);\n                    return writer;\n                };\n                /**\n                 * Encodes the specified Context message, length delimited. Does not implicitly {@link SetOptions.ModelOptions.Context.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof SetOptions.ModelOptions.Context\n                 * @static\n                 * @param {SetOptions.ModelOptions.IContext} message Context message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Context.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n                /**\n                 * Decodes a Context message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof SetOptions.ModelOptions.Context\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {SetOptions.ModelOptions.Context} Context\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Context.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SetOptions.ModelOptions.Context();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                            case 1:\n                                message.id = reader.string();\n                                break;\n                            case 2:\n                                message.contextType = reader.int32();\n                                break;\n                            case 3:\n                                if (!(message.prefixes && message.prefixes.length))\n                                    message.prefixes = [];\n                                message.prefixes.push(reader.string());\n                                break;\n                            case 4:\n                                if (!(message.values && message.values.length))\n                                    message.values = [];\n                                message.values.push(reader.string());\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                        }\n                    }\n                    return message;\n                };\n                /**\n                 * Decodes a Context message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof SetOptions.ModelOptions.Context\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {SetOptions.ModelOptions.Context} Context\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Context.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n                /**\n                 * Verifies a Context message.\n                 * @function verify\n                 * @memberof SetOptions.ModelOptions.Context\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                Context.verify = function verify(message) {\n                    if (typeof message !== 'object' || message === null)\n                        return 'object expected';\n                    if (message.id != null && message.hasOwnProperty('id'))\n                        if (!$util.isString(message.id))\n                            return 'id: string expected';\n                    if (message.contextType != null && message.hasOwnProperty('contextType'))\n                        switch (message.contextType) {\n                            default:\n                                return 'contextType: enum value expected';\n                            case 0:\n                            case 1:\n                                break;\n                        }\n                    if (message.prefixes != null && message.hasOwnProperty('prefixes')) {\n                        if (!Array.isArray(message.prefixes))\n                            return 'prefixes: array expected';\n                        for (var i = 0; i < message.prefixes.length; ++i)\n                            if (!$util.isString(message.prefixes[i]))\n                                return 'prefixes: string[] expected';\n                    }\n                    if (message.values != null && message.hasOwnProperty('values')) {\n                        if (!Array.isArray(message.values))\n                            return 'values: array expected';\n                        for (var i = 0; i < message.values.length; ++i)\n                            if (!$util.isString(message.values[i]))\n                                return 'values: string[] expected';\n                    }\n                    return null;\n                };\n                /**\n                 * Creates a Context message from a plain object. Also converts values to their respective internal types.\n                 * @function fromObject\n                 * @memberof SetOptions.ModelOptions.Context\n                 * @static\n                 * @param {Object.<string,*>} object Plain object\n                 * @returns {SetOptions.ModelOptions.Context} Context\n                 */\n                Context.fromObject = function fromObject(object) {\n                    if (object instanceof $root.SetOptions.ModelOptions.Context)\n                        return object;\n                    var message = new $root.SetOptions.ModelOptions.Context();\n                    if (object.id != null)\n                        message.id = String(object.id);\n                    switch (object.contextType) {\n                        case 'GENERAL':\n                        case 0:\n                            message.contextType = 0;\n                            break;\n                        case 'ADDRESSBOOK':\n                        case 1:\n                            message.contextType = 1;\n                            break;\n                    }\n                    if (object.prefixes) {\n                        if (!Array.isArray(object.prefixes))\n                            throw TypeError('.SetOptions.ModelOptions.Context.prefixes: array expected');\n                        message.prefixes = [];\n                        for (var i = 0; i < object.prefixes.length; ++i)\n                            message.prefixes[i] = String(object.prefixes[i]);\n                    }\n                    if (object.values) {\n                        if (!Array.isArray(object.values))\n                            throw TypeError('.SetOptions.ModelOptions.Context.values: array expected');\n                        message.values = [];\n                        for (var i = 0; i < object.values.length; ++i)\n                            message.values[i] = String(object.values[i]);\n                    }\n                    return message;\n                };\n                /**\n                 * Creates a plain object from a Context message. Also converts values to other types if specified.\n                 * @function toObject\n                 * @memberof SetOptions.ModelOptions.Context\n                 * @static\n                 * @param {SetOptions.ModelOptions.Context} message Context\n                 * @param {$protobuf.IConversionOptions} [options] Conversion options\n                 * @returns {Object.<string,*>} Plain object\n                 */\n                Context.toObject = function toObject(message, options) {\n                    if (!options)\n                        options = {};\n                    var object = {};\n                    if (options.arrays || options.defaults) {\n                        object.prefixes = [];\n                        object.values = [];\n                    }\n                    if (options.defaults) {\n                        object.id = '';\n                        object.contextType = options.enums === String ? 'GENERAL' : 0;\n                    }\n                    if (message.id != null && message.hasOwnProperty('id'))\n                        object.id = message.id;\n                    if (message.contextType != null && message.hasOwnProperty('contextType'))\n                        object.contextType =\n                            options.enums === String\n                                ? $root.SetOptions.ModelOptions.Context.ContextType[message.contextType]\n                                : message.contextType;\n                    if (message.prefixes && message.prefixes.length) {\n                        object.prefixes = [];\n                        for (var j = 0; j < message.prefixes.length; ++j)\n                            object.prefixes[j] = message.prefixes[j];\n                    }\n                    if (message.values && message.values.length) {\n                        object.values = [];\n                        for (var j = 0; j < message.values.length; ++j)\n                            object.values[j] = message.values[j];\n                    }\n                    return object;\n                };\n                /**\n                 * Converts this Context to JSON.\n                 * @function toJSON\n                 * @memberof SetOptions.ModelOptions.Context\n                 * @instance\n                 * @returns {Object.<string,*>} JSON object\n                 */\n                Context.prototype.toJSON = function toJSON() {\n                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                };\n                /**\n                 * ContextType enum.\n                 * @name SetOptions.ModelOptions.Context.ContextType\n                 * @enum {number}\n                 * @property {number} GENERAL=0 GENERAL value\n                 * @property {number} ADDRESSBOOK=1 ADDRESSBOOK value\n                 */\n                Context.ContextType = (function () {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[(valuesById[0] = 'GENERAL')] = 0;\n                    values[(valuesById[1] = 'ADDRESSBOOK')] = 1;\n                    return values;\n                })();\n                return Context;\n            })();\n            return ModelOptions;\n        })();\n        return SetOptions;\n    })();\n    $root.UndecodedSeconds = (function () {\n        /**\n         * Properties of an UndecodedSeconds.\n         * @exports IUndecodedSeconds\n         * @interface IUndecodedSeconds\n         * @property {number|null} [undecodedSeconds] UndecodedSeconds undecodedSeconds\n         */\n        /**\n         * Constructs a new UndecodedSeconds.\n         * @exports UndecodedSeconds\n         * @classdesc Represents an UndecodedSeconds.\n         * @implements IUndecodedSeconds\n         * @constructor\n         * @param {IUndecodedSeconds=} [properties] Properties to set\n         */\n        function UndecodedSeconds(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * UndecodedSeconds undecodedSeconds.\n         * @member {number} undecodedSeconds\n         * @memberof UndecodedSeconds\n         * @instance\n         */\n        UndecodedSeconds.prototype.undecodedSeconds = 0;\n        /**\n         * Creates a new UndecodedSeconds instance using the specified properties.\n         * @function create\n         * @memberof UndecodedSeconds\n         * @static\n         * @param {IUndecodedSeconds=} [properties] Properties to set\n         * @returns {UndecodedSeconds} UndecodedSeconds instance\n         */\n        UndecodedSeconds.create = function create(properties) {\n            return new UndecodedSeconds(properties);\n        };\n        /**\n         * Encodes the specified UndecodedSeconds message. Does not implicitly {@link UndecodedSeconds.verify|verify} messages.\n         * @function encode\n         * @memberof UndecodedSeconds\n         * @static\n         * @param {IUndecodedSeconds} message UndecodedSeconds message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        UndecodedSeconds.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.undecodedSeconds != null && Object.hasOwnProperty.call(message, 'undecodedSeconds'))\n                writer.uint32(/* id 1, wireType 5 =*/ 13).float(message.undecodedSeconds);\n            return writer;\n        };\n        /**\n         * Encodes the specified UndecodedSeconds message, length delimited. Does not implicitly {@link UndecodedSeconds.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof UndecodedSeconds\n         * @static\n         * @param {IUndecodedSeconds} message UndecodedSeconds message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        UndecodedSeconds.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes an UndecodedSeconds message from the specified reader or buffer.\n         * @function decode\n         * @memberof UndecodedSeconds\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {UndecodedSeconds} UndecodedSeconds\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        UndecodedSeconds.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UndecodedSeconds();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.undecodedSeconds = reader.float();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        /**\n         * Decodes an UndecodedSeconds message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof UndecodedSeconds\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {UndecodedSeconds} UndecodedSeconds\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        UndecodedSeconds.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies an UndecodedSeconds message.\n         * @function verify\n         * @memberof UndecodedSeconds\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        UndecodedSeconds.verify = function verify(message) {\n            if (typeof message !== 'object' || message === null)\n                return 'object expected';\n            if (message.undecodedSeconds != null && message.hasOwnProperty('undecodedSeconds'))\n                if (typeof message.undecodedSeconds !== 'number')\n                    return 'undecodedSeconds: number expected';\n            return null;\n        };\n        /**\n         * Creates an UndecodedSeconds message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof UndecodedSeconds\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {UndecodedSeconds} UndecodedSeconds\n         */\n        UndecodedSeconds.fromObject = function fromObject(object) {\n            if (object instanceof $root.UndecodedSeconds)\n                return object;\n            var message = new $root.UndecodedSeconds();\n            if (object.undecodedSeconds != null)\n                message.undecodedSeconds = Number(object.undecodedSeconds);\n            return message;\n        };\n        /**\n         * Creates a plain object from an UndecodedSeconds message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof UndecodedSeconds\n         * @static\n         * @param {UndecodedSeconds} message UndecodedSeconds\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        UndecodedSeconds.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults)\n                object.undecodedSeconds = 0;\n            if (message.undecodedSeconds != null && message.hasOwnProperty('undecodedSeconds'))\n                object.undecodedSeconds =\n                    options.json && !isFinite(message.undecodedSeconds)\n                        ? String(message.undecodedSeconds)\n                        : message.undecodedSeconds;\n            return object;\n        };\n        /**\n         * Converts this UndecodedSeconds to JSON.\n         * @function toJSON\n         * @memberof UndecodedSeconds\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        UndecodedSeconds.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        return UndecodedSeconds;\n    })();\n    $root.FullyFinalized = (function () {\n        /**\n         * Properties of a FullyFinalized.\n         * @exports IFullyFinalized\n         * @interface IFullyFinalized\n         */\n        /**\n         * Constructs a new FullyFinalized.\n         * @exports FullyFinalized\n         * @classdesc Represents a FullyFinalized.\n         * @implements IFullyFinalized\n         * @constructor\n         * @param {IFullyFinalized=} [properties] Properties to set\n         */\n        function FullyFinalized(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * Creates a new FullyFinalized instance using the specified properties.\n         * @function create\n         * @memberof FullyFinalized\n         * @static\n         * @param {IFullyFinalized=} [properties] Properties to set\n         * @returns {FullyFinalized} FullyFinalized instance\n         */\n        FullyFinalized.create = function create(properties) {\n            return new FullyFinalized(properties);\n        };\n        /**\n         * Encodes the specified FullyFinalized message. Does not implicitly {@link FullyFinalized.verify|verify} messages.\n         * @function encode\n         * @memberof FullyFinalized\n         * @static\n         * @param {IFullyFinalized} message FullyFinalized message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        FullyFinalized.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            return writer;\n        };\n        /**\n         * Encodes the specified FullyFinalized message, length delimited. Does not implicitly {@link FullyFinalized.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof FullyFinalized\n         * @static\n         * @param {IFullyFinalized} message FullyFinalized message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        FullyFinalized.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a FullyFinalized message from the specified reader or buffer.\n         * @function decode\n         * @memberof FullyFinalized\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {FullyFinalized} FullyFinalized\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        FullyFinalized.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.FullyFinalized();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        /**\n         * Decodes a FullyFinalized message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof FullyFinalized\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {FullyFinalized} FullyFinalized\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        FullyFinalized.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a FullyFinalized message.\n         * @function verify\n         * @memberof FullyFinalized\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        FullyFinalized.verify = function verify(message) {\n            if (typeof message !== 'object' || message === null)\n                return 'object expected';\n            return null;\n        };\n        /**\n         * Creates a FullyFinalized message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof FullyFinalized\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {FullyFinalized} FullyFinalized\n         */\n        FullyFinalized.fromObject = function fromObject(object) {\n            if (object instanceof $root.FullyFinalized)\n                return object;\n            return new $root.FullyFinalized();\n        };\n        /**\n         * Creates a plain object from a FullyFinalized message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof FullyFinalized\n         * @static\n         * @param {FullyFinalized} message FullyFinalized\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        FullyFinalized.toObject = function toObject() {\n            return {};\n        };\n        /**\n         * Converts this FullyFinalized to JSON.\n         * @function toJSON\n         * @memberof FullyFinalized\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        FullyFinalized.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        return FullyFinalized;\n    })();\n    $root.EmotionResult = (function () {\n        /**\n         * Properties of an EmotionResult.\n         * @exports IEmotionResult\n         * @interface IEmotionResult\n         * @property {string|null} [name] EmotionResult name\n         * @property {number|null} [confidence] EmotionResult confidence\n         */\n        /**\n         * Constructs a new EmotionResult.\n         * @exports EmotionResult\n         * @classdesc Represents an EmotionResult.\n         * @implements IEmotionResult\n         * @constructor\n         * @param {IEmotionResult=} [properties] Properties to set\n         */\n        function EmotionResult(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * EmotionResult name.\n         * @member {string} name\n         * @memberof EmotionResult\n         * @instance\n         */\n        EmotionResult.prototype.name = '';\n        /**\n         * EmotionResult confidence.\n         * @member {number} confidence\n         * @memberof EmotionResult\n         * @instance\n         */\n        EmotionResult.prototype.confidence = 0;\n        /**\n         * Creates a new EmotionResult instance using the specified properties.\n         * @function create\n         * @memberof EmotionResult\n         * @static\n         * @param {IEmotionResult=} [properties] Properties to set\n         * @returns {EmotionResult} EmotionResult instance\n         */\n        EmotionResult.create = function create(properties) {\n            return new EmotionResult(properties);\n        };\n        /**\n         * Encodes the specified EmotionResult message. Does not implicitly {@link EmotionResult.verify|verify} messages.\n         * @function encode\n         * @memberof EmotionResult\n         * @static\n         * @param {IEmotionResult} message EmotionResult message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        EmotionResult.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.name != null && Object.hasOwnProperty.call(message, 'name'))\n                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);\n            if (message.confidence != null && Object.hasOwnProperty.call(message, 'confidence'))\n                writer.uint32(/* id 2, wireType 5 =*/ 21).float(message.confidence);\n            return writer;\n        };\n        /**\n         * Encodes the specified EmotionResult message, length delimited. Does not implicitly {@link EmotionResult.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof EmotionResult\n         * @static\n         * @param {IEmotionResult} message EmotionResult message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        EmotionResult.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes an EmotionResult message from the specified reader or buffer.\n         * @function decode\n         * @memberof EmotionResult\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {EmotionResult} EmotionResult\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        EmotionResult.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EmotionResult();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.name = reader.string();\n                        break;\n                    case 2:\n                        message.confidence = reader.float();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        /**\n         * Decodes an EmotionResult message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof EmotionResult\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {EmotionResult} EmotionResult\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        EmotionResult.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies an EmotionResult message.\n         * @function verify\n         * @memberof EmotionResult\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        EmotionResult.verify = function verify(message) {\n            if (typeof message !== 'object' || message === null)\n                return 'object expected';\n            if (message.name != null && message.hasOwnProperty('name'))\n                if (!$util.isString(message.name))\n                    return 'name: string expected';\n            if (message.confidence != null && message.hasOwnProperty('confidence'))\n                if (typeof message.confidence !== 'number')\n                    return 'confidence: number expected';\n            return null;\n        };\n        /**\n         * Creates an EmotionResult message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof EmotionResult\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {EmotionResult} EmotionResult\n         */\n        EmotionResult.fromObject = function fromObject(object) {\n            if (object instanceof $root.EmotionResult)\n                return object;\n            var message = new $root.EmotionResult();\n            if (object.name != null)\n                message.name = String(object.name);\n            if (object.confidence != null)\n                message.confidence = Number(object.confidence);\n            return message;\n        };\n        /**\n         * Creates a plain object from an EmotionResult message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof EmotionResult\n         * @static\n         * @param {EmotionResult} message EmotionResult\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        EmotionResult.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.name = '';\n                object.confidence = 0;\n            }\n            if (message.name != null && message.hasOwnProperty('name'))\n                object.name = message.name;\n            if (message.confidence != null && message.hasOwnProperty('confidence'))\n                object.confidence =\n                    options.json && !isFinite(message.confidence) ? String(message.confidence) : message.confidence;\n            return object;\n        };\n        /**\n         * Converts this EmotionResult to JSON.\n         * @function toJSON\n         * @memberof EmotionResult\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        EmotionResult.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        return EmotionResult;\n    })();\n    $root.Hypothesis = (function () {\n        /**\n         * Properties of a Hypothesis.\n         * @exports IHypothesis\n         * @interface IHypothesis\n         * @property {string|null} [words] Hypothesis words\n         * @property {number|null} [acousticCost] Hypothesis acousticCost\n         * @property {number|null} [linguisticCost] Hypothesis linguisticCost\n         * @property {number|null} [finalCost] Hypothesis finalCost\n         * @property {number|null} [phraseStart] Hypothesis phraseStart\n         * @property {number|null} [phraseEnd] Hypothesis phraseEnd\n         * @property {string|null} [normalizedText] Hypothesis normalizedText\n         */\n        /**\n         * Constructs a new Hypothesis.\n         * @exports Hypothesis\n         * @classdesc Represents a Hypothesis.\n         * @implements IHypothesis\n         * @constructor\n         * @param {IHypothesis=} [properties] Properties to set\n         */\n        function Hypothesis(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * Hypothesis words.\n         * @member {string} words\n         * @memberof Hypothesis\n         * @instance\n         */\n        Hypothesis.prototype.words = '';\n        /**\n         * Hypothesis acousticCost.\n         * @member {number} acousticCost\n         * @memberof Hypothesis\n         * @instance\n         */\n        Hypothesis.prototype.acousticCost = 0;\n        /**\n         * Hypothesis linguisticCost.\n         * @member {number} linguisticCost\n         * @memberof Hypothesis\n         * @instance\n         */\n        Hypothesis.prototype.linguisticCost = 0;\n        /**\n         * Hypothesis finalCost.\n         * @member {number} finalCost\n         * @memberof Hypothesis\n         * @instance\n         */\n        Hypothesis.prototype.finalCost = 0;\n        /**\n         * Hypothesis phraseStart.\n         * @member {number} phraseStart\n         * @memberof Hypothesis\n         * @instance\n         */\n        Hypothesis.prototype.phraseStart = 0;\n        /**\n         * Hypothesis phraseEnd.\n         * @member {number} phraseEnd\n         * @memberof Hypothesis\n         * @instance\n         */\n        Hypothesis.prototype.phraseEnd = 0;\n        /**\n         * Hypothesis normalizedText.\n         * @member {string} normalizedText\n         * @memberof Hypothesis\n         * @instance\n         */\n        Hypothesis.prototype.normalizedText = '';\n        /**\n         * Creates a new Hypothesis instance using the specified properties.\n         * @function create\n         * @memberof Hypothesis\n         * @static\n         * @param {IHypothesis=} [properties] Properties to set\n         * @returns {Hypothesis} Hypothesis instance\n         */\n        Hypothesis.create = function create(properties) {\n            return new Hypothesis(properties);\n        };\n        /**\n         * Encodes the specified Hypothesis message. Does not implicitly {@link Hypothesis.verify|verify} messages.\n         * @function encode\n         * @memberof Hypothesis\n         * @static\n         * @param {IHypothesis} message Hypothesis message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Hypothesis.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.words != null && Object.hasOwnProperty.call(message, 'words'))\n                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.words);\n            if (message.acousticCost != null && Object.hasOwnProperty.call(message, 'acousticCost'))\n                writer.uint32(/* id 2, wireType 5 =*/ 21).float(message.acousticCost);\n            if (message.linguisticCost != null && Object.hasOwnProperty.call(message, 'linguisticCost'))\n                writer.uint32(/* id 3, wireType 5 =*/ 29).float(message.linguisticCost);\n            if (message.finalCost != null && Object.hasOwnProperty.call(message, 'finalCost'))\n                writer.uint32(/* id 4, wireType 5 =*/ 37).float(message.finalCost);\n            if (message.phraseStart != null && Object.hasOwnProperty.call(message, 'phraseStart'))\n                writer.uint32(/* id 5, wireType 5 =*/ 45).float(message.phraseStart);\n            if (message.phraseEnd != null && Object.hasOwnProperty.call(message, 'phraseEnd'))\n                writer.uint32(/* id 6, wireType 5 =*/ 53).float(message.phraseEnd);\n            if (message.normalizedText != null && Object.hasOwnProperty.call(message, 'normalizedText'))\n                writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.normalizedText);\n            return writer;\n        };\n        /**\n         * Encodes the specified Hypothesis message, length delimited. Does not implicitly {@link Hypothesis.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Hypothesis\n         * @static\n         * @param {IHypothesis} message Hypothesis message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Hypothesis.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a Hypothesis message from the specified reader or buffer.\n         * @function decode\n         * @memberof Hypothesis\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Hypothesis} Hypothesis\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Hypothesis.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Hypothesis();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.words = reader.string();\n                        break;\n                    case 2:\n                        message.acousticCost = reader.float();\n                        break;\n                    case 3:\n                        message.linguisticCost = reader.float();\n                        break;\n                    case 4:\n                        message.finalCost = reader.float();\n                        break;\n                    case 5:\n                        message.phraseStart = reader.float();\n                        break;\n                    case 6:\n                        message.phraseEnd = reader.float();\n                        break;\n                    case 7:\n                        message.normalizedText = reader.string();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        /**\n         * Decodes a Hypothesis message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Hypothesis\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Hypothesis} Hypothesis\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Hypothesis.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a Hypothesis message.\n         * @function verify\n         * @memberof Hypothesis\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Hypothesis.verify = function verify(message) {\n            if (typeof message !== 'object' || message === null)\n                return 'object expected';\n            if (message.words != null && message.hasOwnProperty('words'))\n                if (!$util.isString(message.words))\n                    return 'words: string expected';\n            if (message.acousticCost != null && message.hasOwnProperty('acousticCost'))\n                if (typeof message.acousticCost !== 'number')\n                    return 'acousticCost: number expected';\n            if (message.linguisticCost != null && message.hasOwnProperty('linguisticCost'))\n                if (typeof message.linguisticCost !== 'number')\n                    return 'linguisticCost: number expected';\n            if (message.finalCost != null && message.hasOwnProperty('finalCost'))\n                if (typeof message.finalCost !== 'number')\n                    return 'finalCost: number expected';\n            if (message.phraseStart != null && message.hasOwnProperty('phraseStart'))\n                if (typeof message.phraseStart !== 'number')\n                    return 'phraseStart: number expected';\n            if (message.phraseEnd != null && message.hasOwnProperty('phraseEnd'))\n                if (typeof message.phraseEnd !== 'number')\n                    return 'phraseEnd: number expected';\n            if (message.normalizedText != null && message.hasOwnProperty('normalizedText'))\n                if (!$util.isString(message.normalizedText))\n                    return 'normalizedText: string expected';\n            return null;\n        };\n        /**\n         * Creates a Hypothesis message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof Hypothesis\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {Hypothesis} Hypothesis\n         */\n        Hypothesis.fromObject = function fromObject(object) {\n            if (object instanceof $root.Hypothesis)\n                return object;\n            var message = new $root.Hypothesis();\n            if (object.words != null)\n                message.words = String(object.words);\n            if (object.acousticCost != null)\n                message.acousticCost = Number(object.acousticCost);\n            if (object.linguisticCost != null)\n                message.linguisticCost = Number(object.linguisticCost);\n            if (object.finalCost != null)\n                message.finalCost = Number(object.finalCost);\n            if (object.phraseStart != null)\n                message.phraseStart = Number(object.phraseStart);\n            if (object.phraseEnd != null)\n                message.phraseEnd = Number(object.phraseEnd);\n            if (object.normalizedText != null)\n                message.normalizedText = String(object.normalizedText);\n            return message;\n        };\n        /**\n         * Creates a plain object from a Hypothesis message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Hypothesis\n         * @static\n         * @param {Hypothesis} message Hypothesis\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Hypothesis.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.words = '';\n                object.acousticCost = 0;\n                object.linguisticCost = 0;\n                object.finalCost = 0;\n                object.phraseStart = 0;\n                object.phraseEnd = 0;\n                object.normalizedText = '';\n            }\n            if (message.words != null && message.hasOwnProperty('words'))\n                object.words = message.words;\n            if (message.acousticCost != null && message.hasOwnProperty('acousticCost'))\n                object.acousticCost =\n                    options.json && !isFinite(message.acousticCost)\n                        ? String(message.acousticCost)\n                        : message.acousticCost;\n            if (message.linguisticCost != null && message.hasOwnProperty('linguisticCost'))\n                object.linguisticCost =\n                    options.json && !isFinite(message.linguisticCost)\n                        ? String(message.linguisticCost)\n                        : message.linguisticCost;\n            if (message.finalCost != null && message.hasOwnProperty('finalCost'))\n                object.finalCost =\n                    options.json && !isFinite(message.finalCost) ? String(message.finalCost) : message.finalCost;\n            if (message.phraseStart != null && message.hasOwnProperty('phraseStart'))\n                object.phraseStart =\n                    options.json && !isFinite(message.phraseStart) ? String(message.phraseStart) : message.phraseStart;\n            if (message.phraseEnd != null && message.hasOwnProperty('phraseEnd'))\n                object.phraseEnd =\n                    options.json && !isFinite(message.phraseEnd) ? String(message.phraseEnd) : message.phraseEnd;\n            if (message.normalizedText != null && message.hasOwnProperty('normalizedText'))\n                object.normalizedText = message.normalizedText;\n            return object;\n        };\n        /**\n         * Converts this Hypothesis to JSON.\n         * @function toJSON\n         * @memberof Hypothesis\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Hypothesis.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        return Hypothesis;\n    })();\n    $root.DecoderResult = (function () {\n        /**\n         * Properties of a DecoderResult.\n         * @exports IDecoderResult\n         * @interface IDecoderResult\n         * @property {Array.<IHypothesis>|null} [hypothesis] DecoderResult hypothesis\n         * @property {number|null} [chunkStart] DecoderResult chunkStart\n         * @property {number|null} [chunkEnd] DecoderResult chunkEnd\n         * @property {number|null} [timeEndpointDetectionMs] DecoderResult timeEndpointDetectionMs\n         * @property {number|null} [timeDecodingMs] DecoderResult timeDecodingMs\n         * @property {IVariables|null} [variables] DecoderResult variables\n         * @property {boolean|null} [isFinal] DecoderResult isFinal\n         * @property {Array.<IEmotionResult>|null} [emotionResult] DecoderResult emotionResult\n         * @property {Array.<DecoderResult.IContextAnswer>|null} [contextAnswer] DecoderResult contextAnswer\n         */\n        /**\n         * Constructs a new DecoderResult.\n         * @exports DecoderResult\n         * @classdesc Represents a DecoderResult.\n         * @implements IDecoderResult\n         * @constructor\n         * @param {IDecoderResult=} [properties] Properties to set\n         */\n        function DecoderResult(properties) {\n            this.hypothesis = [];\n            this.emotionResult = [];\n            this.contextAnswer = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * DecoderResult hypothesis.\n         * @member {Array.<IHypothesis>} hypothesis\n         * @memberof DecoderResult\n         * @instance\n         */\n        DecoderResult.prototype.hypothesis = $util.emptyArray;\n        /**\n         * DecoderResult chunkStart.\n         * @member {number} chunkStart\n         * @memberof DecoderResult\n         * @instance\n         */\n        DecoderResult.prototype.chunkStart = 0;\n        /**\n         * DecoderResult chunkEnd.\n         * @member {number} chunkEnd\n         * @memberof DecoderResult\n         * @instance\n         */\n        DecoderResult.prototype.chunkEnd = 0;\n        /**\n         * DecoderResult timeEndpointDetectionMs.\n         * @member {number} timeEndpointDetectionMs\n         * @memberof DecoderResult\n         * @instance\n         */\n        DecoderResult.prototype.timeEndpointDetectionMs = 0;\n        /**\n         * DecoderResult timeDecodingMs.\n         * @member {number} timeDecodingMs\n         * @memberof DecoderResult\n         * @instance\n         */\n        DecoderResult.prototype.timeDecodingMs = 0;\n        /**\n         * DecoderResult variables.\n         * @member {IVariables|null|undefined} variables\n         * @memberof DecoderResult\n         * @instance\n         */\n        DecoderResult.prototype.variables = null;\n        /**\n         * DecoderResult isFinal.\n         * @member {boolean} isFinal\n         * @memberof DecoderResult\n         * @instance\n         */\n        DecoderResult.prototype.isFinal = false;\n        /**\n         * DecoderResult emotionResult.\n         * @member {Array.<IEmotionResult>} emotionResult\n         * @memberof DecoderResult\n         * @instance\n         */\n        DecoderResult.prototype.emotionResult = $util.emptyArray;\n        /**\n         * DecoderResult contextAnswer.\n         * @member {Array.<DecoderResult.IContextAnswer>} contextAnswer\n         * @memberof DecoderResult\n         * @instance\n         */\n        DecoderResult.prototype.contextAnswer = $util.emptyArray;\n        /**\n         * Creates a new DecoderResult instance using the specified properties.\n         * @function create\n         * @memberof DecoderResult\n         * @static\n         * @param {IDecoderResult=} [properties] Properties to set\n         * @returns {DecoderResult} DecoderResult instance\n         */\n        DecoderResult.create = function create(properties) {\n            return new DecoderResult(properties);\n        };\n        /**\n         * Encodes the specified DecoderResult message. Does not implicitly {@link DecoderResult.verify|verify} messages.\n         * @function encode\n         * @memberof DecoderResult\n         * @static\n         * @param {IDecoderResult} message DecoderResult message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        DecoderResult.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.hypothesis != null && message.hypothesis.length)\n                for (var i = 0; i < message.hypothesis.length; ++i)\n                    $root.Hypothesis.encode(message.hypothesis[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();\n            if (message.chunkStart != null && Object.hasOwnProperty.call(message, 'chunkStart'))\n                writer.uint32(/* id 2, wireType 5 =*/ 21).float(message.chunkStart);\n            if (message.chunkEnd != null && Object.hasOwnProperty.call(message, 'chunkEnd'))\n                writer.uint32(/* id 3, wireType 5 =*/ 29).float(message.chunkEnd);\n            if (message.timeEndpointDetectionMs != null &&\n                Object.hasOwnProperty.call(message, 'timeEndpointDetectionMs'))\n                writer.uint32(/* id 4, wireType 5 =*/ 37).float(message.timeEndpointDetectionMs);\n            if (message.timeDecodingMs != null && Object.hasOwnProperty.call(message, 'timeDecodingMs'))\n                writer.uint32(/* id 5, wireType 5 =*/ 45).float(message.timeDecodingMs);\n            if (message.variables != null && Object.hasOwnProperty.call(message, 'variables'))\n                $root.Variables.encode(message.variables, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();\n            if (message.isFinal != null && Object.hasOwnProperty.call(message, 'isFinal'))\n                writer.uint32(/* id 7, wireType 0 =*/ 56).bool(message.isFinal);\n            if (message.emotionResult != null && message.emotionResult.length)\n                for (var i = 0; i < message.emotionResult.length; ++i)\n                    $root.EmotionResult.encode(message.emotionResult[i], writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();\n            if (message.contextAnswer != null && message.contextAnswer.length)\n                for (var i = 0; i < message.contextAnswer.length; ++i)\n                    $root.DecoderResult.ContextAnswer.encode(message.contextAnswer[i], writer.uint32(/* id 9, wireType 2 =*/ 74).fork()).ldelim();\n            return writer;\n        };\n        /**\n         * Encodes the specified DecoderResult message, length delimited. Does not implicitly {@link DecoderResult.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof DecoderResult\n         * @static\n         * @param {IDecoderResult} message DecoderResult message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        DecoderResult.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a DecoderResult message from the specified reader or buffer.\n         * @function decode\n         * @memberof DecoderResult\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {DecoderResult} DecoderResult\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        DecoderResult.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DecoderResult();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        if (!(message.hypothesis && message.hypothesis.length))\n                            message.hypothesis = [];\n                        message.hypothesis.push($root.Hypothesis.decode(reader, reader.uint32()));\n                        break;\n                    case 2:\n                        message.chunkStart = reader.float();\n                        break;\n                    case 3:\n                        message.chunkEnd = reader.float();\n                        break;\n                    case 4:\n                        message.timeEndpointDetectionMs = reader.float();\n                        break;\n                    case 5:\n                        message.timeDecodingMs = reader.float();\n                        break;\n                    case 6:\n                        message.variables = $root.Variables.decode(reader, reader.uint32());\n                        break;\n                    case 7:\n                        message.isFinal = reader.bool();\n                        break;\n                    case 8:\n                        if (!(message.emotionResult && message.emotionResult.length))\n                            message.emotionResult = [];\n                        message.emotionResult.push($root.EmotionResult.decode(reader, reader.uint32()));\n                        break;\n                    case 9:\n                        if (!(message.contextAnswer && message.contextAnswer.length))\n                            message.contextAnswer = [];\n                        message.contextAnswer.push($root.DecoderResult.ContextAnswer.decode(reader, reader.uint32()));\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        /**\n         * Decodes a DecoderResult message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof DecoderResult\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {DecoderResult} DecoderResult\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        DecoderResult.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a DecoderResult message.\n         * @function verify\n         * @memberof DecoderResult\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        DecoderResult.verify = function verify(message) {\n            if (typeof message !== 'object' || message === null)\n                return 'object expected';\n            if (message.hypothesis != null && message.hasOwnProperty('hypothesis')) {\n                if (!Array.isArray(message.hypothesis))\n                    return 'hypothesis: array expected';\n                for (var i = 0; i < message.hypothesis.length; ++i) {\n                    var error = $root.Hypothesis.verify(message.hypothesis[i]);\n                    if (error)\n                        return 'hypothesis.' + error;\n                }\n            }\n            if (message.chunkStart != null && message.hasOwnProperty('chunkStart'))\n                if (typeof message.chunkStart !== 'number')\n                    return 'chunkStart: number expected';\n            if (message.chunkEnd != null && message.hasOwnProperty('chunkEnd'))\n                if (typeof message.chunkEnd !== 'number')\n                    return 'chunkEnd: number expected';\n            if (message.timeEndpointDetectionMs != null && message.hasOwnProperty('timeEndpointDetectionMs'))\n                if (typeof message.timeEndpointDetectionMs !== 'number')\n                    return 'timeEndpointDetectionMs: number expected';\n            if (message.timeDecodingMs != null && message.hasOwnProperty('timeDecodingMs'))\n                if (typeof message.timeDecodingMs !== 'number')\n                    return 'timeDecodingMs: number expected';\n            if (message.variables != null && message.hasOwnProperty('variables')) {\n                var error = $root.Variables.verify(message.variables);\n                if (error)\n                    return 'variables.' + error;\n            }\n            if (message.isFinal != null && message.hasOwnProperty('isFinal'))\n                if (typeof message.isFinal !== 'boolean')\n                    return 'isFinal: boolean expected';\n            if (message.emotionResult != null && message.hasOwnProperty('emotionResult')) {\n                if (!Array.isArray(message.emotionResult))\n                    return 'emotionResult: array expected';\n                for (var i = 0; i < message.emotionResult.length; ++i) {\n                    var error = $root.EmotionResult.verify(message.emotionResult[i]);\n                    if (error)\n                        return 'emotionResult.' + error;\n                }\n            }\n            if (message.contextAnswer != null && message.hasOwnProperty('contextAnswer')) {\n                if (!Array.isArray(message.contextAnswer))\n                    return 'contextAnswer: array expected';\n                for (var i = 0; i < message.contextAnswer.length; ++i) {\n                    var error = $root.DecoderResult.ContextAnswer.verify(message.contextAnswer[i]);\n                    if (error)\n                        return 'contextAnswer.' + error;\n                }\n            }\n            return null;\n        };\n        /**\n         * Creates a DecoderResult message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof DecoderResult\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {DecoderResult} DecoderResult\n         */\n        DecoderResult.fromObject = function fromObject(object) {\n            if (object instanceof $root.DecoderResult)\n                return object;\n            var message = new $root.DecoderResult();\n            if (object.hypothesis) {\n                if (!Array.isArray(object.hypothesis))\n                    throw TypeError('.DecoderResult.hypothesis: array expected');\n                message.hypothesis = [];\n                for (var i = 0; i < object.hypothesis.length; ++i) {\n                    if (typeof object.hypothesis[i] !== 'object')\n                        throw TypeError('.DecoderResult.hypothesis: object expected');\n                    message.hypothesis[i] = $root.Hypothesis.fromObject(object.hypothesis[i]);\n                }\n            }\n            if (object.chunkStart != null)\n                message.chunkStart = Number(object.chunkStart);\n            if (object.chunkEnd != null)\n                message.chunkEnd = Number(object.chunkEnd);\n            if (object.timeEndpointDetectionMs != null)\n                message.timeEndpointDetectionMs = Number(object.timeEndpointDetectionMs);\n            if (object.timeDecodingMs != null)\n                message.timeDecodingMs = Number(object.timeDecodingMs);\n            if (object.variables != null) {\n                if (typeof object.variables !== 'object')\n                    throw TypeError('.DecoderResult.variables: object expected');\n                message.variables = $root.Variables.fromObject(object.variables);\n            }\n            if (object.isFinal != null)\n                message.isFinal = Boolean(object.isFinal);\n            if (object.emotionResult) {\n                if (!Array.isArray(object.emotionResult))\n                    throw TypeError('.DecoderResult.emotionResult: array expected');\n                message.emotionResult = [];\n                for (var i = 0; i < object.emotionResult.length; ++i) {\n                    if (typeof object.emotionResult[i] !== 'object')\n                        throw TypeError('.DecoderResult.emotionResult: object expected');\n                    message.emotionResult[i] = $root.EmotionResult.fromObject(object.emotionResult[i]);\n                }\n            }\n            if (object.contextAnswer) {\n                if (!Array.isArray(object.contextAnswer))\n                    throw TypeError('.DecoderResult.contextAnswer: array expected');\n                message.contextAnswer = [];\n                for (var i = 0; i < object.contextAnswer.length; ++i) {\n                    if (typeof object.contextAnswer[i] !== 'object')\n                        throw TypeError('.DecoderResult.contextAnswer: object expected');\n                    message.contextAnswer[i] = $root.DecoderResult.ContextAnswer.fromObject(object.contextAnswer[i]);\n                }\n            }\n            return message;\n        };\n        /**\n         * Creates a plain object from a DecoderResult message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof DecoderResult\n         * @static\n         * @param {DecoderResult} message DecoderResult\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        DecoderResult.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults) {\n                object.hypothesis = [];\n                object.emotionResult = [];\n                object.contextAnswer = [];\n            }\n            if (options.defaults) {\n                object.chunkStart = 0;\n                object.chunkEnd = 0;\n                object.timeEndpointDetectionMs = 0;\n                object.timeDecodingMs = 0;\n                object.variables = null;\n                object.isFinal = false;\n            }\n            if (message.hypothesis && message.hypothesis.length) {\n                object.hypothesis = [];\n                for (var j = 0; j < message.hypothesis.length; ++j)\n                    object.hypothesis[j] = $root.Hypothesis.toObject(message.hypothesis[j], options);\n            }\n            if (message.chunkStart != null && message.hasOwnProperty('chunkStart'))\n                object.chunkStart =\n                    options.json && !isFinite(message.chunkStart) ? String(message.chunkStart) : message.chunkStart;\n            if (message.chunkEnd != null && message.hasOwnProperty('chunkEnd'))\n                object.chunkEnd =\n                    options.json && !isFinite(message.chunkEnd) ? String(message.chunkEnd) : message.chunkEnd;\n            if (message.timeEndpointDetectionMs != null && message.hasOwnProperty('timeEndpointDetectionMs'))\n                object.timeEndpointDetectionMs =\n                    options.json && !isFinite(message.timeEndpointDetectionMs)\n                        ? String(message.timeEndpointDetectionMs)\n                        : message.timeEndpointDetectionMs;\n            if (message.timeDecodingMs != null && message.hasOwnProperty('timeDecodingMs'))\n                object.timeDecodingMs =\n                    options.json && !isFinite(message.timeDecodingMs)\n                        ? String(message.timeDecodingMs)\n                        : message.timeDecodingMs;\n            if (message.variables != null && message.hasOwnProperty('variables'))\n                object.variables = $root.Variables.toObject(message.variables, options);\n            if (message.isFinal != null && message.hasOwnProperty('isFinal'))\n                object.isFinal = message.isFinal;\n            if (message.emotionResult && message.emotionResult.length) {\n                object.emotionResult = [];\n                for (var j = 0; j < message.emotionResult.length; ++j)\n                    object.emotionResult[j] = $root.EmotionResult.toObject(message.emotionResult[j], options);\n            }\n            if (message.contextAnswer && message.contextAnswer.length) {\n                object.contextAnswer = [];\n                for (var j = 0; j < message.contextAnswer.length; ++j)\n                    object.contextAnswer[j] = $root.DecoderResult.ContextAnswer.toObject(message.contextAnswer[j], options);\n            }\n            return object;\n        };\n        /**\n         * Converts this DecoderResult to JSON.\n         * @function toJSON\n         * @memberof DecoderResult\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        DecoderResult.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        DecoderResult.ContextAnswer = (function () {\n            /**\n             * Properties of a ContextAnswer.\n             * @memberof DecoderResult\n             * @interface IContextAnswer\n             * @property {Array.<DecoderResult.ContextAnswer.IContextRef>|null} [contextResult] ContextAnswer contextResult\n             */\n            /**\n             * Constructs a new ContextAnswer.\n             * @memberof DecoderResult\n             * @classdesc Represents a ContextAnswer.\n             * @implements IContextAnswer\n             * @constructor\n             * @param {DecoderResult.IContextAnswer=} [properties] Properties to set\n             */\n            function ContextAnswer(properties) {\n                this.contextResult = [];\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n            /**\n             * ContextAnswer contextResult.\n             * @member {Array.<DecoderResult.ContextAnswer.IContextRef>} contextResult\n             * @memberof DecoderResult.ContextAnswer\n             * @instance\n             */\n            ContextAnswer.prototype.contextResult = $util.emptyArray;\n            /**\n             * Creates a new ContextAnswer instance using the specified properties.\n             * @function create\n             * @memberof DecoderResult.ContextAnswer\n             * @static\n             * @param {DecoderResult.IContextAnswer=} [properties] Properties to set\n             * @returns {DecoderResult.ContextAnswer} ContextAnswer instance\n             */\n            ContextAnswer.create = function create(properties) {\n                return new ContextAnswer(properties);\n            };\n            /**\n             * Encodes the specified ContextAnswer message. Does not implicitly {@link DecoderResult.ContextAnswer.verify|verify} messages.\n             * @function encode\n             * @memberof DecoderResult.ContextAnswer\n             * @static\n             * @param {DecoderResult.IContextAnswer} message ContextAnswer message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ContextAnswer.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.contextResult != null && message.contextResult.length)\n                    for (var i = 0; i < message.contextResult.length; ++i)\n                        $root.DecoderResult.ContextAnswer.ContextRef.encode(message.contextResult[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();\n                return writer;\n            };\n            /**\n             * Encodes the specified ContextAnswer message, length delimited. Does not implicitly {@link DecoderResult.ContextAnswer.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof DecoderResult.ContextAnswer\n             * @static\n             * @param {DecoderResult.IContextAnswer} message ContextAnswer message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ContextAnswer.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n            /**\n             * Decodes a ContextAnswer message from the specified reader or buffer.\n             * @function decode\n             * @memberof DecoderResult.ContextAnswer\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {DecoderResult.ContextAnswer} ContextAnswer\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ContextAnswer.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DecoderResult.ContextAnswer();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            if (!(message.contextResult && message.contextResult.length))\n                                message.contextResult = [];\n                            message.contextResult.push($root.DecoderResult.ContextAnswer.ContextRef.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return message;\n            };\n            /**\n             * Decodes a ContextAnswer message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof DecoderResult.ContextAnswer\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {DecoderResult.ContextAnswer} ContextAnswer\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ContextAnswer.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n            /**\n             * Verifies a ContextAnswer message.\n             * @function verify\n             * @memberof DecoderResult.ContextAnswer\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            ContextAnswer.verify = function verify(message) {\n                if (typeof message !== 'object' || message === null)\n                    return 'object expected';\n                if (message.contextResult != null && message.hasOwnProperty('contextResult')) {\n                    if (!Array.isArray(message.contextResult))\n                        return 'contextResult: array expected';\n                    for (var i = 0; i < message.contextResult.length; ++i) {\n                        var error = $root.DecoderResult.ContextAnswer.ContextRef.verify(message.contextResult[i]);\n                        if (error)\n                            return 'contextResult.' + error;\n                    }\n                }\n                return null;\n            };\n            /**\n             * Creates a ContextAnswer message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof DecoderResult.ContextAnswer\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {DecoderResult.ContextAnswer} ContextAnswer\n             */\n            ContextAnswer.fromObject = function fromObject(object) {\n                if (object instanceof $root.DecoderResult.ContextAnswer)\n                    return object;\n                var message = new $root.DecoderResult.ContextAnswer();\n                if (object.contextResult) {\n                    if (!Array.isArray(object.contextResult))\n                        throw TypeError('.DecoderResult.ContextAnswer.contextResult: array expected');\n                    message.contextResult = [];\n                    for (var i = 0; i < object.contextResult.length; ++i) {\n                        if (typeof object.contextResult[i] !== 'object')\n                            throw TypeError('.DecoderResult.ContextAnswer.contextResult: object expected');\n                        message.contextResult[i] = $root.DecoderResult.ContextAnswer.ContextRef.fromObject(object.contextResult[i]);\n                    }\n                }\n                return message;\n            };\n            /**\n             * Creates a plain object from a ContextAnswer message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof DecoderResult.ContextAnswer\n             * @static\n             * @param {DecoderResult.ContextAnswer} message ContextAnswer\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            ContextAnswer.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.arrays || options.defaults)\n                    object.contextResult = [];\n                if (message.contextResult && message.contextResult.length) {\n                    object.contextResult = [];\n                    for (var j = 0; j < message.contextResult.length; ++j)\n                        object.contextResult[j] = $root.DecoderResult.ContextAnswer.ContextRef.toObject(message.contextResult[j], options);\n                }\n                return object;\n            };\n            /**\n             * Converts this ContextAnswer to JSON.\n             * @function toJSON\n             * @memberof DecoderResult.ContextAnswer\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            ContextAnswer.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n            ContextAnswer.ContextRef = (function () {\n                /**\n                 * Properties of a ContextRef.\n                 * @memberof DecoderResult.ContextAnswer\n                 * @interface IContextRef\n                 * @property {string|null} [id] ContextRef id\n                 * @property {number|null} [index] ContextRef index\n                 * @property {string|null} [originalValue] ContextRef originalValue\n                 * @property {string|null} [predictedValue] ContextRef predictedValue\n                 * @property {number|null} [score] ContextRef score\n                 */\n                /**\n                 * Constructs a new ContextRef.\n                 * @memberof DecoderResult.ContextAnswer\n                 * @classdesc Represents a ContextRef.\n                 * @implements IContextRef\n                 * @constructor\n                 * @param {DecoderResult.ContextAnswer.IContextRef=} [properties] Properties to set\n                 */\n                function ContextRef(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n                /**\n                 * ContextRef id.\n                 * @member {string} id\n                 * @memberof DecoderResult.ContextAnswer.ContextRef\n                 * @instance\n                 */\n                ContextRef.prototype.id = '';\n                /**\n                 * ContextRef index.\n                 * @member {number} index\n                 * @memberof DecoderResult.ContextAnswer.ContextRef\n                 * @instance\n                 */\n                ContextRef.prototype.index = 0;\n                /**\n                 * ContextRef originalValue.\n                 * @member {string} originalValue\n                 * @memberof DecoderResult.ContextAnswer.ContextRef\n                 * @instance\n                 */\n                ContextRef.prototype.originalValue = '';\n                /**\n                 * ContextRef predictedValue.\n                 * @member {string} predictedValue\n                 * @memberof DecoderResult.ContextAnswer.ContextRef\n                 * @instance\n                 */\n                ContextRef.prototype.predictedValue = '';\n                /**\n                 * ContextRef score.\n                 * @member {number} score\n                 * @memberof DecoderResult.ContextAnswer.ContextRef\n                 * @instance\n                 */\n                ContextRef.prototype.score = 0;\n                /**\n                 * Creates a new ContextRef instance using the specified properties.\n                 * @function create\n                 * @memberof DecoderResult.ContextAnswer.ContextRef\n                 * @static\n                 * @param {DecoderResult.ContextAnswer.IContextRef=} [properties] Properties to set\n                 * @returns {DecoderResult.ContextAnswer.ContextRef} ContextRef instance\n                 */\n                ContextRef.create = function create(properties) {\n                    return new ContextRef(properties);\n                };\n                /**\n                 * Encodes the specified ContextRef message. Does not implicitly {@link DecoderResult.ContextAnswer.ContextRef.verify|verify} messages.\n                 * @function encode\n                 * @memberof DecoderResult.ContextAnswer.ContextRef\n                 * @static\n                 * @param {DecoderResult.ContextAnswer.IContextRef} message ContextRef message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                ContextRef.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.id != null && Object.hasOwnProperty.call(message, 'id'))\n                        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.id);\n                    if (message.index != null && Object.hasOwnProperty.call(message, 'index'))\n                        writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.index);\n                    if (message.originalValue != null && Object.hasOwnProperty.call(message, 'originalValue'))\n                        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.originalValue);\n                    if (message.predictedValue != null && Object.hasOwnProperty.call(message, 'predictedValue'))\n                        writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.predictedValue);\n                    if (message.score != null && Object.hasOwnProperty.call(message, 'score'))\n                        writer.uint32(/* id 5, wireType 5 =*/ 45).float(message.score);\n                    return writer;\n                };\n                /**\n                 * Encodes the specified ContextRef message, length delimited. Does not implicitly {@link DecoderResult.ContextAnswer.ContextRef.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof DecoderResult.ContextAnswer.ContextRef\n                 * @static\n                 * @param {DecoderResult.ContextAnswer.IContextRef} message ContextRef message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                ContextRef.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n                /**\n                 * Decodes a ContextRef message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof DecoderResult.ContextAnswer.ContextRef\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {DecoderResult.ContextAnswer.ContextRef} ContextRef\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                ContextRef.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DecoderResult.ContextAnswer.ContextRef();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                            case 1:\n                                message.id = reader.string();\n                                break;\n                            case 2:\n                                message.index = reader.int32();\n                                break;\n                            case 3:\n                                message.originalValue = reader.string();\n                                break;\n                            case 4:\n                                message.predictedValue = reader.string();\n                                break;\n                            case 5:\n                                message.score = reader.float();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                        }\n                    }\n                    return message;\n                };\n                /**\n                 * Decodes a ContextRef message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof DecoderResult.ContextAnswer.ContextRef\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {DecoderResult.ContextAnswer.ContextRef} ContextRef\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                ContextRef.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n                /**\n                 * Verifies a ContextRef message.\n                 * @function verify\n                 * @memberof DecoderResult.ContextAnswer.ContextRef\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                ContextRef.verify = function verify(message) {\n                    if (typeof message !== 'object' || message === null)\n                        return 'object expected';\n                    if (message.id != null && message.hasOwnProperty('id'))\n                        if (!$util.isString(message.id))\n                            return 'id: string expected';\n                    if (message.index != null && message.hasOwnProperty('index'))\n                        if (!$util.isInteger(message.index))\n                            return 'index: integer expected';\n                    if (message.originalValue != null && message.hasOwnProperty('originalValue'))\n                        if (!$util.isString(message.originalValue))\n                            return 'originalValue: string expected';\n                    if (message.predictedValue != null && message.hasOwnProperty('predictedValue'))\n                        if (!$util.isString(message.predictedValue))\n                            return 'predictedValue: string expected';\n                    if (message.score != null && message.hasOwnProperty('score'))\n                        if (typeof message.score !== 'number')\n                            return 'score: number expected';\n                    return null;\n                };\n                /**\n                 * Creates a ContextRef message from a plain object. Also converts values to their respective internal types.\n                 * @function fromObject\n                 * @memberof DecoderResult.ContextAnswer.ContextRef\n                 * @static\n                 * @param {Object.<string,*>} object Plain object\n                 * @returns {DecoderResult.ContextAnswer.ContextRef} ContextRef\n                 */\n                ContextRef.fromObject = function fromObject(object) {\n                    if (object instanceof $root.DecoderResult.ContextAnswer.ContextRef)\n                        return object;\n                    var message = new $root.DecoderResult.ContextAnswer.ContextRef();\n                    if (object.id != null)\n                        message.id = String(object.id);\n                    if (object.index != null)\n                        message.index = object.index | 0;\n                    if (object.originalValue != null)\n                        message.originalValue = String(object.originalValue);\n                    if (object.predictedValue != null)\n                        message.predictedValue = String(object.predictedValue);\n                    if (object.score != null)\n                        message.score = Number(object.score);\n                    return message;\n                };\n                /**\n                 * Creates a plain object from a ContextRef message. Also converts values to other types if specified.\n                 * @function toObject\n                 * @memberof DecoderResult.ContextAnswer.ContextRef\n                 * @static\n                 * @param {DecoderResult.ContextAnswer.ContextRef} message ContextRef\n                 * @param {$protobuf.IConversionOptions} [options] Conversion options\n                 * @returns {Object.<string,*>} Plain object\n                 */\n                ContextRef.toObject = function toObject(message, options) {\n                    if (!options)\n                        options = {};\n                    var object = {};\n                    if (options.defaults) {\n                        object.id = '';\n                        object.index = 0;\n                        object.originalValue = '';\n                        object.predictedValue = '';\n                        object.score = 0;\n                    }\n                    if (message.id != null && message.hasOwnProperty('id'))\n                        object.id = message.id;\n                    if (message.index != null && message.hasOwnProperty('index'))\n                        object.index = message.index;\n                    if (message.originalValue != null && message.hasOwnProperty('originalValue'))\n                        object.originalValue = message.originalValue;\n                    if (message.predictedValue != null && message.hasOwnProperty('predictedValue'))\n                        object.predictedValue = message.predictedValue;\n                    if (message.score != null && message.hasOwnProperty('score'))\n                        object.score = options.json && !isFinite(message.score) ? String(message.score) : message.score;\n                    return object;\n                };\n                /**\n                 * Converts this ContextRef to JSON.\n                 * @function toJSON\n                 * @memberof DecoderResult.ContextAnswer.ContextRef\n                 * @instance\n                 * @returns {Object.<string,*>} JSON object\n                 */\n                ContextRef.prototype.toJSON = function toJSON() {\n                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                };\n                return ContextRef;\n            })();\n            return ContextAnswer;\n        })();\n        return DecoderResult;\n    })();\n    $root.ErrorResponse = (function () {\n        /**\n         * Properties of an ErrorResponse.\n         * @exports IErrorResponse\n         * @interface IErrorResponse\n         * @property {string|null} [errorMessage] ErrorResponse errorMessage\n         */\n        /**\n         * Constructs a new ErrorResponse.\n         * @exports ErrorResponse\n         * @classdesc Represents an ErrorResponse.\n         * @implements IErrorResponse\n         * @constructor\n         * @param {IErrorResponse=} [properties] Properties to set\n         */\n        function ErrorResponse(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * ErrorResponse errorMessage.\n         * @member {string} errorMessage\n         * @memberof ErrorResponse\n         * @instance\n         */\n        ErrorResponse.prototype.errorMessage = '';\n        /**\n         * Creates a new ErrorResponse instance using the specified properties.\n         * @function create\n         * @memberof ErrorResponse\n         * @static\n         * @param {IErrorResponse=} [properties] Properties to set\n         * @returns {ErrorResponse} ErrorResponse instance\n         */\n        ErrorResponse.create = function create(properties) {\n            return new ErrorResponse(properties);\n        };\n        /**\n         * Encodes the specified ErrorResponse message. Does not implicitly {@link ErrorResponse.verify|verify} messages.\n         * @function encode\n         * @memberof ErrorResponse\n         * @static\n         * @param {IErrorResponse} message ErrorResponse message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ErrorResponse.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.errorMessage != null && Object.hasOwnProperty.call(message, 'errorMessage'))\n                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.errorMessage);\n            return writer;\n        };\n        /**\n         * Encodes the specified ErrorResponse message, length delimited. Does not implicitly {@link ErrorResponse.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ErrorResponse\n         * @static\n         * @param {IErrorResponse} message ErrorResponse message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ErrorResponse.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes an ErrorResponse message from the specified reader or buffer.\n         * @function decode\n         * @memberof ErrorResponse\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ErrorResponse} ErrorResponse\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ErrorResponse.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ErrorResponse();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.errorMessage = reader.string();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        /**\n         * Decodes an ErrorResponse message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ErrorResponse\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ErrorResponse} ErrorResponse\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ErrorResponse.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies an ErrorResponse message.\n         * @function verify\n         * @memberof ErrorResponse\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        ErrorResponse.verify = function verify(message) {\n            if (typeof message !== 'object' || message === null)\n                return 'object expected';\n            if (message.errorMessage != null && message.hasOwnProperty('errorMessage'))\n                if (!$util.isString(message.errorMessage))\n                    return 'errorMessage: string expected';\n            return null;\n        };\n        /**\n         * Creates an ErrorResponse message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ErrorResponse\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ErrorResponse} ErrorResponse\n         */\n        ErrorResponse.fromObject = function fromObject(object) {\n            if (object instanceof $root.ErrorResponse)\n                return object;\n            var message = new $root.ErrorResponse();\n            if (object.errorMessage != null)\n                message.errorMessage = String(object.errorMessage);\n            return message;\n        };\n        /**\n         * Creates a plain object from an ErrorResponse message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ErrorResponse\n         * @static\n         * @param {ErrorResponse} message ErrorResponse\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        ErrorResponse.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults)\n                object.errorMessage = '';\n            if (message.errorMessage != null && message.hasOwnProperty('errorMessage'))\n                object.errorMessage = message.errorMessage;\n            return object;\n        };\n        /**\n         * Converts this ErrorResponse to JSON.\n         * @function toJSON\n         * @memberof ErrorResponse\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        ErrorResponse.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        return ErrorResponse;\n    })();\n    $root.PacketWrapperToServer = (function () {\n        /**\n         * Properties of a PacketWrapperToServer.\n         * @exports IPacketWrapperToServer\n         * @interface IPacketWrapperToServer\n         * @property {IData|null} [dataField] PacketWrapperToServer dataField\n         * @property {IInfo|null} [infoField] PacketWrapperToServer infoField\n         * @property {IFinalized|null} [finalizedField] PacketWrapperToServer finalizedField\n         * @property {ISetOptions|null} [setOptionsField] PacketWrapperToServer setOptionsField\n         */\n        /**\n         * Constructs a new PacketWrapperToServer.\n         * @exports PacketWrapperToServer\n         * @classdesc Represents a PacketWrapperToServer.\n         * @implements IPacketWrapperToServer\n         * @constructor\n         * @param {IPacketWrapperToServer=} [properties] Properties to set\n         */\n        function PacketWrapperToServer(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * PacketWrapperToServer dataField.\n         * @member {IData|null|undefined} dataField\n         * @memberof PacketWrapperToServer\n         * @instance\n         */\n        PacketWrapperToServer.prototype.dataField = null;\n        /**\n         * PacketWrapperToServer infoField.\n         * @member {IInfo|null|undefined} infoField\n         * @memberof PacketWrapperToServer\n         * @instance\n         */\n        PacketWrapperToServer.prototype.infoField = null;\n        /**\n         * PacketWrapperToServer finalizedField.\n         * @member {IFinalized|null|undefined} finalizedField\n         * @memberof PacketWrapperToServer\n         * @instance\n         */\n        PacketWrapperToServer.prototype.finalizedField = null;\n        /**\n         * PacketWrapperToServer setOptionsField.\n         * @member {ISetOptions|null|undefined} setOptionsField\n         * @memberof PacketWrapperToServer\n         * @instance\n         */\n        PacketWrapperToServer.prototype.setOptionsField = null;\n        // OneOf field names bound to virtual getters and setters\n        var $oneOfFields;\n        /**\n         * PacketWrapperToServer MessageType.\n         * @member {\"dataField\"|\"infoField\"|\"finalizedField\"|\"setOptionsField\"|undefined} MessageType\n         * @memberof PacketWrapperToServer\n         * @instance\n         */\n        Object.defineProperty(PacketWrapperToServer.prototype, 'MessageType', {\n            get: $util.oneOfGetter(($oneOfFields = ['dataField', 'infoField', 'finalizedField', 'setOptionsField'])),\n            set: $util.oneOfSetter($oneOfFields),\n        });\n        /**\n         * Creates a new PacketWrapperToServer instance using the specified properties.\n         * @function create\n         * @memberof PacketWrapperToServer\n         * @static\n         * @param {IPacketWrapperToServer=} [properties] Properties to set\n         * @returns {PacketWrapperToServer} PacketWrapperToServer instance\n         */\n        PacketWrapperToServer.create = function create(properties) {\n            return new PacketWrapperToServer(properties);\n        };\n        /**\n         * Encodes the specified PacketWrapperToServer message. Does not implicitly {@link PacketWrapperToServer.verify|verify} messages.\n         * @function encode\n         * @memberof PacketWrapperToServer\n         * @static\n         * @param {IPacketWrapperToServer} message PacketWrapperToServer message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        PacketWrapperToServer.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.dataField != null && Object.hasOwnProperty.call(message, 'dataField'))\n                $root.Data.encode(message.dataField, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();\n            if (message.infoField != null && Object.hasOwnProperty.call(message, 'infoField'))\n                $root.Info.encode(message.infoField, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();\n            if (message.finalizedField != null && Object.hasOwnProperty.call(message, 'finalizedField'))\n                $root.Finalized.encode(message.finalizedField, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();\n            if (message.setOptionsField != null && Object.hasOwnProperty.call(message, 'setOptionsField'))\n                $root.SetOptions.encode(message.setOptionsField, writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();\n            return writer;\n        };\n        /**\n         * Encodes the specified PacketWrapperToServer message, length delimited. Does not implicitly {@link PacketWrapperToServer.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof PacketWrapperToServer\n         * @static\n         * @param {IPacketWrapperToServer} message PacketWrapperToServer message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        PacketWrapperToServer.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a PacketWrapperToServer message from the specified reader or buffer.\n         * @function decode\n         * @memberof PacketWrapperToServer\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {PacketWrapperToServer} PacketWrapperToServer\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        PacketWrapperToServer.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PacketWrapperToServer();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.dataField = $root.Data.decode(reader, reader.uint32());\n                        break;\n                    case 3:\n                        message.infoField = $root.Info.decode(reader, reader.uint32());\n                        break;\n                    case 5:\n                        message.finalizedField = $root.Finalized.decode(reader, reader.uint32());\n                        break;\n                    case 7:\n                        message.setOptionsField = $root.SetOptions.decode(reader, reader.uint32());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        /**\n         * Decodes a PacketWrapperToServer message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof PacketWrapperToServer\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {PacketWrapperToServer} PacketWrapperToServer\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        PacketWrapperToServer.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a PacketWrapperToServer message.\n         * @function verify\n         * @memberof PacketWrapperToServer\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        PacketWrapperToServer.verify = function verify(message) {\n            if (typeof message !== 'object' || message === null)\n                return 'object expected';\n            var properties = {};\n            if (message.dataField != null && message.hasOwnProperty('dataField')) {\n                properties.MessageType = 1;\n                {\n                    var error = $root.Data.verify(message.dataField);\n                    if (error)\n                        return 'dataField.' + error;\n                }\n            }\n            if (message.infoField != null && message.hasOwnProperty('infoField')) {\n                if (properties.MessageType === 1)\n                    return 'MessageType: multiple values';\n                properties.MessageType = 1;\n                {\n                    var error = $root.Info.verify(message.infoField);\n                    if (error)\n                        return 'infoField.' + error;\n                }\n            }\n            if (message.finalizedField != null && message.hasOwnProperty('finalizedField')) {\n                if (properties.MessageType === 1)\n                    return 'MessageType: multiple values';\n                properties.MessageType = 1;\n                {\n                    var error = $root.Finalized.verify(message.finalizedField);\n                    if (error)\n                        return 'finalizedField.' + error;\n                }\n            }\n            if (message.setOptionsField != null && message.hasOwnProperty('setOptionsField')) {\n                if (properties.MessageType === 1)\n                    return 'MessageType: multiple values';\n                properties.MessageType = 1;\n                {\n                    var error = $root.SetOptions.verify(message.setOptionsField);\n                    if (error)\n                        return 'setOptionsField.' + error;\n                }\n            }\n            return null;\n        };\n        /**\n         * Creates a PacketWrapperToServer message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof PacketWrapperToServer\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {PacketWrapperToServer} PacketWrapperToServer\n         */\n        PacketWrapperToServer.fromObject = function fromObject(object) {\n            if (object instanceof $root.PacketWrapperToServer)\n                return object;\n            var message = new $root.PacketWrapperToServer();\n            if (object.dataField != null) {\n                if (typeof object.dataField !== 'object')\n                    throw TypeError('.PacketWrapperToServer.dataField: object expected');\n                message.dataField = $root.Data.fromObject(object.dataField);\n            }\n            if (object.infoField != null) {\n                if (typeof object.infoField !== 'object')\n                    throw TypeError('.PacketWrapperToServer.infoField: object expected');\n                message.infoField = $root.Info.fromObject(object.infoField);\n            }\n            if (object.finalizedField != null) {\n                if (typeof object.finalizedField !== 'object')\n                    throw TypeError('.PacketWrapperToServer.finalizedField: object expected');\n                message.finalizedField = $root.Finalized.fromObject(object.finalizedField);\n            }\n            if (object.setOptionsField != null) {\n                if (typeof object.setOptionsField !== 'object')\n                    throw TypeError('.PacketWrapperToServer.setOptionsField: object expected');\n                message.setOptionsField = $root.SetOptions.fromObject(object.setOptionsField);\n            }\n            return message;\n        };\n        /**\n         * Creates a plain object from a PacketWrapperToServer message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof PacketWrapperToServer\n         * @static\n         * @param {PacketWrapperToServer} message PacketWrapperToServer\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        PacketWrapperToServer.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (message.dataField != null && message.hasOwnProperty('dataField')) {\n                object.dataField = $root.Data.toObject(message.dataField, options);\n                if (options.oneofs)\n                    object.MessageType = 'dataField';\n            }\n            if (message.infoField != null && message.hasOwnProperty('infoField')) {\n                object.infoField = $root.Info.toObject(message.infoField, options);\n                if (options.oneofs)\n                    object.MessageType = 'infoField';\n            }\n            if (message.finalizedField != null && message.hasOwnProperty('finalizedField')) {\n                object.finalizedField = $root.Finalized.toObject(message.finalizedField, options);\n                if (options.oneofs)\n                    object.MessageType = 'finalizedField';\n            }\n            if (message.setOptionsField != null && message.hasOwnProperty('setOptionsField')) {\n                object.setOptionsField = $root.SetOptions.toObject(message.setOptionsField, options);\n                if (options.oneofs)\n                    object.MessageType = 'setOptionsField';\n            }\n            return object;\n        };\n        /**\n         * Converts this PacketWrapperToServer to JSON.\n         * @function toJSON\n         * @memberof PacketWrapperToServer\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        PacketWrapperToServer.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        return PacketWrapperToServer;\n    })();\n    $root.PacketWrapperFromServer = (function () {\n        /**\n         * Properties of a PacketWrapperFromServer.\n         * @exports IPacketWrapperFromServer\n         * @interface IPacketWrapperFromServer\n         * @property {IUndecodedSeconds|null} [undecodedSecondsField] PacketWrapperFromServer undecodedSecondsField\n         * @property {IFullyFinalized|null} [fullyFinalizedField] PacketWrapperFromServer fullyFinalizedField\n         * @property {IDecoderResult|null} [decoderResultField] PacketWrapperFromServer decoderResultField\n         * @property {IErrorResponse|null} [errorResponse] PacketWrapperFromServer errorResponse\n         */\n        /**\n         * Constructs a new PacketWrapperFromServer.\n         * @exports PacketWrapperFromServer\n         * @classdesc Represents a PacketWrapperFromServer.\n         * @implements IPacketWrapperFromServer\n         * @constructor\n         * @param {IPacketWrapperFromServer=} [properties] Properties to set\n         */\n        function PacketWrapperFromServer(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * PacketWrapperFromServer undecodedSecondsField.\n         * @member {IUndecodedSeconds|null|undefined} undecodedSecondsField\n         * @memberof PacketWrapperFromServer\n         * @instance\n         */\n        PacketWrapperFromServer.prototype.undecodedSecondsField = null;\n        /**\n         * PacketWrapperFromServer fullyFinalizedField.\n         * @member {IFullyFinalized|null|undefined} fullyFinalizedField\n         * @memberof PacketWrapperFromServer\n         * @instance\n         */\n        PacketWrapperFromServer.prototype.fullyFinalizedField = null;\n        /**\n         * PacketWrapperFromServer decoderResultField.\n         * @member {IDecoderResult|null|undefined} decoderResultField\n         * @memberof PacketWrapperFromServer\n         * @instance\n         */\n        PacketWrapperFromServer.prototype.decoderResultField = null;\n        /**\n         * PacketWrapperFromServer errorResponse.\n         * @member {IErrorResponse|null|undefined} errorResponse\n         * @memberof PacketWrapperFromServer\n         * @instance\n         */\n        PacketWrapperFromServer.prototype.errorResponse = null;\n        // OneOf field names bound to virtual getters and setters\n        var $oneOfFields;\n        /**\n         * PacketWrapperFromServer MessageType.\n         * @member {\"undecodedSecondsField\"|\"fullyFinalizedField\"|\"decoderResultField\"|\"errorResponse\"|undefined} MessageType\n         * @memberof PacketWrapperFromServer\n         * @instance\n         */\n        Object.defineProperty(PacketWrapperFromServer.prototype, 'MessageType', {\n            get: $util.oneOfGetter(($oneOfFields = [\n                'undecodedSecondsField',\n                'fullyFinalizedField',\n                'decoderResultField',\n                'errorResponse',\n            ])),\n            set: $util.oneOfSetter($oneOfFields),\n        });\n        /**\n         * Creates a new PacketWrapperFromServer instance using the specified properties.\n         * @function create\n         * @memberof PacketWrapperFromServer\n         * @static\n         * @param {IPacketWrapperFromServer=} [properties] Properties to set\n         * @returns {PacketWrapperFromServer} PacketWrapperFromServer instance\n         */\n        PacketWrapperFromServer.create = function create(properties) {\n            return new PacketWrapperFromServer(properties);\n        };\n        /**\n         * Encodes the specified PacketWrapperFromServer message. Does not implicitly {@link PacketWrapperFromServer.verify|verify} messages.\n         * @function encode\n         * @memberof PacketWrapperFromServer\n         * @static\n         * @param {IPacketWrapperFromServer} message PacketWrapperFromServer message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        PacketWrapperFromServer.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.undecodedSecondsField != null && Object.hasOwnProperty.call(message, 'undecodedSecondsField'))\n                $root.UndecodedSeconds.encode(message.undecodedSecondsField, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();\n            if (message.fullyFinalizedField != null && Object.hasOwnProperty.call(message, 'fullyFinalizedField'))\n                $root.FullyFinalized.encode(message.fullyFinalizedField, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();\n            if (message.decoderResultField != null && Object.hasOwnProperty.call(message, 'decoderResultField'))\n                $root.DecoderResult.encode(message.decoderResultField, writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();\n            if (message.errorResponse != null && Object.hasOwnProperty.call(message, 'errorResponse'))\n                $root.ErrorResponse.encode(message.errorResponse, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();\n            return writer;\n        };\n        /**\n         * Encodes the specified PacketWrapperFromServer message, length delimited. Does not implicitly {@link PacketWrapperFromServer.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof PacketWrapperFromServer\n         * @static\n         * @param {IPacketWrapperFromServer} message PacketWrapperFromServer message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        PacketWrapperFromServer.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n        /**\n         * Decodes a PacketWrapperFromServer message from the specified reader or buffer.\n         * @function decode\n         * @memberof PacketWrapperFromServer\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {PacketWrapperFromServer} PacketWrapperFromServer\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        PacketWrapperFromServer.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PacketWrapperFromServer();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.undecodedSecondsField = $root.UndecodedSeconds.decode(reader, reader.uint32());\n                        break;\n                    case 2:\n                        message.fullyFinalizedField = $root.FullyFinalized.decode(reader, reader.uint32());\n                        break;\n                    case 4:\n                        message.decoderResultField = $root.DecoderResult.decode(reader, reader.uint32());\n                        break;\n                    case 8:\n                        message.errorResponse = $root.ErrorResponse.decode(reader, reader.uint32());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        /**\n         * Decodes a PacketWrapperFromServer message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof PacketWrapperFromServer\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {PacketWrapperFromServer} PacketWrapperFromServer\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        PacketWrapperFromServer.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n        /**\n         * Verifies a PacketWrapperFromServer message.\n         * @function verify\n         * @memberof PacketWrapperFromServer\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        PacketWrapperFromServer.verify = function verify(message) {\n            if (typeof message !== 'object' || message === null)\n                return 'object expected';\n            var properties = {};\n            if (message.undecodedSecondsField != null && message.hasOwnProperty('undecodedSecondsField')) {\n                properties.MessageType = 1;\n                {\n                    var error = $root.UndecodedSeconds.verify(message.undecodedSecondsField);\n                    if (error)\n                        return 'undecodedSecondsField.' + error;\n                }\n            }\n            if (message.fullyFinalizedField != null && message.hasOwnProperty('fullyFinalizedField')) {\n                if (properties.MessageType === 1)\n                    return 'MessageType: multiple values';\n                properties.MessageType = 1;\n                {\n                    var error = $root.FullyFinalized.verify(message.fullyFinalizedField);\n                    if (error)\n                        return 'fullyFinalizedField.' + error;\n                }\n            }\n            if (message.decoderResultField != null && message.hasOwnProperty('decoderResultField')) {\n                if (properties.MessageType === 1)\n                    return 'MessageType: multiple values';\n                properties.MessageType = 1;\n                {\n                    var error = $root.DecoderResult.verify(message.decoderResultField);\n                    if (error)\n                        return 'decoderResultField.' + error;\n                }\n            }\n            if (message.errorResponse != null && message.hasOwnProperty('errorResponse')) {\n                if (properties.MessageType === 1)\n                    return 'MessageType: multiple values';\n                properties.MessageType = 1;\n                {\n                    var error = $root.ErrorResponse.verify(message.errorResponse);\n                    if (error)\n                        return 'errorResponse.' + error;\n                }\n            }\n            return null;\n        };\n        /**\n         * Creates a PacketWrapperFromServer message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof PacketWrapperFromServer\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {PacketWrapperFromServer} PacketWrapperFromServer\n         */\n        PacketWrapperFromServer.fromObject = function fromObject(object) {\n            if (object instanceof $root.PacketWrapperFromServer)\n                return object;\n            var message = new $root.PacketWrapperFromServer();\n            if (object.undecodedSecondsField != null) {\n                if (typeof object.undecodedSecondsField !== 'object')\n                    throw TypeError('.PacketWrapperFromServer.undecodedSecondsField: object expected');\n                message.undecodedSecondsField = $root.UndecodedSeconds.fromObject(object.undecodedSecondsField);\n            }\n            if (object.fullyFinalizedField != null) {\n                if (typeof object.fullyFinalizedField !== 'object')\n                    throw TypeError('.PacketWrapperFromServer.fullyFinalizedField: object expected');\n                message.fullyFinalizedField = $root.FullyFinalized.fromObject(object.fullyFinalizedField);\n            }\n            if (object.decoderResultField != null) {\n                if (typeof object.decoderResultField !== 'object')\n                    throw TypeError('.PacketWrapperFromServer.decoderResultField: object expected');\n                message.decoderResultField = $root.DecoderResult.fromObject(object.decoderResultField);\n            }\n            if (object.errorResponse != null) {\n                if (typeof object.errorResponse !== 'object')\n                    throw TypeError('.PacketWrapperFromServer.errorResponse: object expected');\n                message.errorResponse = $root.ErrorResponse.fromObject(object.errorResponse);\n            }\n            return message;\n        };\n        /**\n         * Creates a plain object from a PacketWrapperFromServer message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof PacketWrapperFromServer\n         * @static\n         * @param {PacketWrapperFromServer} message PacketWrapperFromServer\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        PacketWrapperFromServer.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (message.undecodedSecondsField != null && message.hasOwnProperty('undecodedSecondsField')) {\n                object.undecodedSecondsField = $root.UndecodedSeconds.toObject(message.undecodedSecondsField, options);\n                if (options.oneofs)\n                    object.MessageType = 'undecodedSecondsField';\n            }\n            if (message.fullyFinalizedField != null && message.hasOwnProperty('fullyFinalizedField')) {\n                object.fullyFinalizedField = $root.FullyFinalized.toObject(message.fullyFinalizedField, options);\n                if (options.oneofs)\n                    object.MessageType = 'fullyFinalizedField';\n            }\n            if (message.decoderResultField != null && message.hasOwnProperty('decoderResultField')) {\n                object.decoderResultField = $root.DecoderResult.toObject(message.decoderResultField, options);\n                if (options.oneofs)\n                    object.MessageType = 'decoderResultField';\n            }\n            if (message.errorResponse != null && message.hasOwnProperty('errorResponse')) {\n                object.errorResponse = $root.ErrorResponse.toObject(message.errorResponse, options);\n                if (options.oneofs)\n                    object.MessageType = 'errorResponse';\n            }\n            return object;\n        };\n        /**\n         * Converts this PacketWrapperFromServer to JSON.\n         * @function toJSON\n         * @memberof PacketWrapperFromServer\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        PacketWrapperFromServer.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        return PacketWrapperFromServer;\n    })();\n    return $root;\n});\n"]},"metadata":{},"sourceType":"script"}