{"ast":null,"code":"import { createNanoEvents } from './nanoevents';\nconst AudioContext = window.AudioContext || window.webkitAudioContext;\nlet context;\nlet processor;\n\nconst downsampleBuffer = (buffer, sampleRate, outSampleRate) => {\n  if (outSampleRate > sampleRate) {\n    throw new Error('downsampling rate show be smaller than original sample rate');\n  }\n\n  const sampleRateRatio = sampleRate / outSampleRate;\n  const newLength = Math.round(buffer.length / sampleRateRatio);\n  const result = new Int16Array(newLength);\n  let empty = true;\n  let offsetResult = 0;\n  let offsetBuffer = 0;\n\n  while (offsetResult < result.length) {\n    const nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);\n    let accum = 0;\n    let count = 0;\n\n    for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {\n      accum += buffer[i];\n      count++;\n    }\n\n    if (empty && accum > 0) {\n      empty = false;\n    }\n\n    result[offsetResult] = Math.min(1, accum / count) * 0x7fff;\n    offsetResult++;\n    offsetBuffer = nextOffsetBuffer;\n  }\n\n  return {\n    buffer: result.buffer,\n    empty\n  };\n};\n\nconst TARGET_SAMPLE_RATE = 16000;\nexport const createAudioRecorder = stream => {\n  const {\n    on,\n    emit\n  } = createNanoEvents();\n  let state = 'inactive';\n  let input;\n\n  const start = () => {\n    if (state !== 'inactive') {\n      throw new Error(\"Can't start not inactive recorder\");\n    }\n\n    state = 'recording';\n\n    if (!context) {\n      context = new AudioContext({\n        sampleRate: 16000\n      });\n    }\n\n    input = context.createMediaStreamSource(stream);\n\n    if (!processor) {\n      processor = context.createScriptProcessor(2048, 1, 1);\n    }\n\n    const listener = e => {\n      const buffer = e.inputBuffer.getChannelData(0);\n      const data = downsampleBuffer(buffer, context.sampleRate, TARGET_SAMPLE_RATE);\n      const last = state === 'inactive';\n      emit('data', data.buffer, last);\n\n      if (last) {\n        processor.removeEventListener('audioprocess', listener);\n      }\n    };\n\n    processor.addEventListener('audioprocess', listener);\n    input.connect(processor);\n    processor.connect(context.destination);\n  };\n\n  const stop = () => {\n    if (state === 'inactive') {\n      throw new Error(\"Can't stop inactive recorder\");\n    }\n\n    state = 'inactive';\n    stream.getTracks().forEach(track => {\n      track.stop();\n    });\n    input.disconnect();\n  };\n\n  return {\n    get state() {\n      return state;\n    },\n\n    start,\n    stop,\n    on,\n    sampleRate: TARGET_SAMPLE_RATE\n  };\n};","map":{"version":3,"sources":["/home/zelairy/Рабочий стол/todo-canvas-app/node_modules/@sberdevices/assistant-client/dist/createAudioRecorder.js"],"names":["createNanoEvents","AudioContext","window","webkitAudioContext","context","processor","downsampleBuffer","buffer","sampleRate","outSampleRate","Error","sampleRateRatio","newLength","Math","round","length","result","Int16Array","empty","offsetResult","offsetBuffer","nextOffsetBuffer","accum","count","i","min","TARGET_SAMPLE_RATE","createAudioRecorder","stream","on","emit","state","input","start","createMediaStreamSource","createScriptProcessor","listener","e","inputBuffer","getChannelData","data","last","removeEventListener","addEventListener","connect","destination","stop","getTracks","forEach","track","disconnect"],"mappings":"AAAA,SAASA,gBAAT,QAAiC,cAAjC;AACA,MAAMC,YAAY,GAAGC,MAAM,CAACD,YAAP,IAAuBC,MAAM,CAACC,kBAAnD;AACA,IAAIC,OAAJ;AACA,IAAIC,SAAJ;;AACA,MAAMC,gBAAgB,GAAG,CAACC,MAAD,EAASC,UAAT,EAAqBC,aAArB,KAAuC;AAC5D,MAAIA,aAAa,GAAGD,UAApB,EAAgC;AAC5B,UAAM,IAAIE,KAAJ,CAAU,6DAAV,CAAN;AACH;;AACD,QAAMC,eAAe,GAAGH,UAAU,GAAGC,aAArC;AACA,QAAMG,SAAS,GAAGC,IAAI,CAACC,KAAL,CAAWP,MAAM,CAACQ,MAAP,GAAgBJ,eAA3B,CAAlB;AACA,QAAMK,MAAM,GAAG,IAAIC,UAAJ,CAAeL,SAAf,CAAf;AACA,MAAIM,KAAK,GAAG,IAAZ;AACA,MAAIC,YAAY,GAAG,CAAnB;AACA,MAAIC,YAAY,GAAG,CAAnB;;AACA,SAAOD,YAAY,GAAGH,MAAM,CAACD,MAA7B,EAAqC;AACjC,UAAMM,gBAAgB,GAAGR,IAAI,CAACC,KAAL,CAAW,CAACK,YAAY,GAAG,CAAhB,IAAqBR,eAAhC,CAAzB;AACA,QAAIW,KAAK,GAAG,CAAZ;AACA,QAAIC,KAAK,GAAG,CAAZ;;AACA,SAAK,IAAIC,CAAC,GAAGJ,YAAb,EAA2BI,CAAC,GAAGH,gBAAJ,IAAwBG,CAAC,GAAGjB,MAAM,CAACQ,MAA9D,EAAsES,CAAC,EAAvE,EAA2E;AACvEF,MAAAA,KAAK,IAAIf,MAAM,CAACiB,CAAD,CAAf;AACAD,MAAAA,KAAK;AACR;;AACD,QAAIL,KAAK,IAAII,KAAK,GAAG,CAArB,EAAwB;AACpBJ,MAAAA,KAAK,GAAG,KAAR;AACH;;AACDF,IAAAA,MAAM,CAACG,YAAD,CAAN,GAAuBN,IAAI,CAACY,GAAL,CAAS,CAAT,EAAYH,KAAK,GAAGC,KAApB,IAA6B,MAApD;AACAJ,IAAAA,YAAY;AACZC,IAAAA,YAAY,GAAGC,gBAAf;AACH;;AACD,SAAO;AACHd,IAAAA,MAAM,EAAES,MAAM,CAACT,MADZ;AAEHW,IAAAA;AAFG,GAAP;AAIH,CA7BD;;AA8BA,MAAMQ,kBAAkB,GAAG,KAA3B;AACA,OAAO,MAAMC,mBAAmB,GAAIC,MAAD,IAAY;AAC3C,QAAM;AAAEC,IAAAA,EAAF;AAAMC,IAAAA;AAAN,MAAe9B,gBAAgB,EAArC;AACA,MAAI+B,KAAK,GAAG,UAAZ;AACA,MAAIC,KAAJ;;AACA,QAAMC,KAAK,GAAG,MAAM;AAChB,QAAIF,KAAK,KAAK,UAAd,EAA0B;AACtB,YAAM,IAAIrB,KAAJ,CAAU,mCAAV,CAAN;AACH;;AACDqB,IAAAA,KAAK,GAAG,WAAR;;AACA,QAAI,CAAC3B,OAAL,EAAc;AACVA,MAAAA,OAAO,GAAG,IAAIH,YAAJ,CAAiB;AACvBO,QAAAA,UAAU,EAAE;AADW,OAAjB,CAAV;AAGH;;AACDwB,IAAAA,KAAK,GAAG5B,OAAO,CAAC8B,uBAAR,CAAgCN,MAAhC,CAAR;;AACA,QAAI,CAACvB,SAAL,EAAgB;AACZA,MAAAA,SAAS,GAAGD,OAAO,CAAC+B,qBAAR,CAA8B,IAA9B,EAAoC,CAApC,EAAuC,CAAvC,CAAZ;AACH;;AACD,UAAMC,QAAQ,GAAIC,CAAD,IAAO;AACpB,YAAM9B,MAAM,GAAG8B,CAAC,CAACC,WAAF,CAAcC,cAAd,CAA6B,CAA7B,CAAf;AACA,YAAMC,IAAI,GAAGlC,gBAAgB,CAACC,MAAD,EAASH,OAAO,CAACI,UAAjB,EAA6BkB,kBAA7B,CAA7B;AACA,YAAMe,IAAI,GAAGV,KAAK,KAAK,UAAvB;AACAD,MAAAA,IAAI,CAAC,MAAD,EAASU,IAAI,CAACjC,MAAd,EAAsBkC,IAAtB,CAAJ;;AACA,UAAIA,IAAJ,EAAU;AACNpC,QAAAA,SAAS,CAACqC,mBAAV,CAA8B,cAA9B,EAA8CN,QAA9C;AACH;AACJ,KARD;;AASA/B,IAAAA,SAAS,CAACsC,gBAAV,CAA2B,cAA3B,EAA2CP,QAA3C;AACAJ,IAAAA,KAAK,CAACY,OAAN,CAAcvC,SAAd;AACAA,IAAAA,SAAS,CAACuC,OAAV,CAAkBxC,OAAO,CAACyC,WAA1B;AACH,GA1BD;;AA2BA,QAAMC,IAAI,GAAG,MAAM;AACf,QAAIf,KAAK,KAAK,UAAd,EAA0B;AACtB,YAAM,IAAIrB,KAAJ,CAAU,8BAAV,CAAN;AACH;;AACDqB,IAAAA,KAAK,GAAG,UAAR;AACAH,IAAAA,MAAM,CAACmB,SAAP,GAAmBC,OAAnB,CAA4BC,KAAD,IAAW;AAClCA,MAAAA,KAAK,CAACH,IAAN;AACH,KAFD;AAGAd,IAAAA,KAAK,CAACkB,UAAN;AACH,GATD;;AAUA,SAAO;AACH,QAAInB,KAAJ,GAAY;AACR,aAAOA,KAAP;AACH,KAHE;;AAIHE,IAAAA,KAJG;AAKHa,IAAAA,IALG;AAMHjB,IAAAA,EANG;AAOHrB,IAAAA,UAAU,EAAEkB;AAPT,GAAP;AASH,CAlDM","sourcesContent":["import { createNanoEvents } from './nanoevents';\nconst AudioContext = window.AudioContext || window.webkitAudioContext;\nlet context;\nlet processor;\nconst downsampleBuffer = (buffer, sampleRate, outSampleRate) => {\n    if (outSampleRate > sampleRate) {\n        throw new Error('downsampling rate show be smaller than original sample rate');\n    }\n    const sampleRateRatio = sampleRate / outSampleRate;\n    const newLength = Math.round(buffer.length / sampleRateRatio);\n    const result = new Int16Array(newLength);\n    let empty = true;\n    let offsetResult = 0;\n    let offsetBuffer = 0;\n    while (offsetResult < result.length) {\n        const nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);\n        let accum = 0;\n        let count = 0;\n        for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {\n            accum += buffer[i];\n            count++;\n        }\n        if (empty && accum > 0) {\n            empty = false;\n        }\n        result[offsetResult] = Math.min(1, accum / count) * 0x7fff;\n        offsetResult++;\n        offsetBuffer = nextOffsetBuffer;\n    }\n    return {\n        buffer: result.buffer,\n        empty,\n    };\n};\nconst TARGET_SAMPLE_RATE = 16000;\nexport const createAudioRecorder = (stream) => {\n    const { on, emit } = createNanoEvents();\n    let state = 'inactive';\n    let input;\n    const start = () => {\n        if (state !== 'inactive') {\n            throw new Error(\"Can't start not inactive recorder\");\n        }\n        state = 'recording';\n        if (!context) {\n            context = new AudioContext({\n                sampleRate: 16000,\n            });\n        }\n        input = context.createMediaStreamSource(stream);\n        if (!processor) {\n            processor = context.createScriptProcessor(2048, 1, 1);\n        }\n        const listener = (e) => {\n            const buffer = e.inputBuffer.getChannelData(0);\n            const data = downsampleBuffer(buffer, context.sampleRate, TARGET_SAMPLE_RATE);\n            const last = state === 'inactive';\n            emit('data', data.buffer, last);\n            if (last) {\n                processor.removeEventListener('audioprocess', listener);\n            }\n        };\n        processor.addEventListener('audioprocess', listener);\n        input.connect(processor);\n        processor.connect(context.destination);\n    };\n    const stop = () => {\n        if (state === 'inactive') {\n            throw new Error(\"Can't stop inactive recorder\");\n        }\n        state = 'inactive';\n        stream.getTracks().forEach((track) => {\n            track.stop();\n        });\n        input.disconnect();\n    };\n    return {\n        get state() {\n            return state;\n        },\n        start,\n        stop,\n        on,\n        sampleRate: TARGET_SAMPLE_RATE,\n    };\n};\n"]},"metadata":{},"sourceType":"module"}