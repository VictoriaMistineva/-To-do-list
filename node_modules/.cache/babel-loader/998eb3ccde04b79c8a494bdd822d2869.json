{"ast":null,"code":"const AudioContext = window.AudioContext || window.webkitAudioContext;\n\nconst createSoundBuffer = (ctx, sampleRate, finishPlayback, bufferSize = 6, delay = 0) => {\n  const chunks = [];\n  let startTime = 0;\n  let lastChunkOffset = 0;\n  let totalChunksDuration = 0;\n  let isPlaying = false;\n\n  const createChunk = chunk => {\n    const audioBuffer = ctx.createBuffer(1, chunk.length, sampleRate);\n    audioBuffer.getChannelData(0).set(chunk);\n    const source = ctx.createBufferSource();\n    source.buffer = audioBuffer;\n    source.connect(ctx.destination);\n\n    source.onended = () => {\n      chunks.splice(chunks.indexOf(source), 1);\n\n      if (chunks.length === 0) {\n        isPlaying = false;\n        startTime = 0;\n        lastChunkOffset = 0;\n        totalChunksDuration = 0;\n        finishPlayback();\n      }\n    };\n\n    totalChunksDuration += source.buffer.duration;\n    return source;\n  };\n\n  const chunkStart = chunk => {\n    var _a;\n\n    chunk.start(startTime + lastChunkOffset);\n    lastChunkOffset += ((_a = chunk.buffer) === null || _a === void 0 ? void 0 : _a.duration) || 0;\n  };\n\n  const doPlay = () => {\n    isPlaying = true;\n    startTime = ctx.currentTime;\n    lastChunkOffset = 0;\n    chunks.forEach(chunk => chunkStart(chunk));\n  };\n\n  const finish = () => {\n    if (totalChunksDuration <= delay && !isPlaying) {\n      doPlay();\n    }\n  };\n\n  const write = data => {\n    const chunk = createChunk(data);\n    chunks.push(chunk);\n\n    if (isPlaying && chunks.length <= bufferSize) {\n      chunkStart(chunk);\n      return;\n    }\n\n    if (totalChunksDuration > delay) doPlay();\n  };\n\n  return {\n    finish,\n    write\n  };\n};\n\nconst from16BitToFloat32 = incomingData => {\n  const l = incomingData.length;\n  const outputData = new Float32Array(l);\n\n  for (let i = 0; i < l; i += 1) {\n    outputData[i] = incomingData[i] / 32768.0;\n  }\n\n  return outputData;\n};\n\nexport const createVoicePlayer = params => {\n  let audioContextForPlayback = null;\n  let audioSlices = [];\n  let extraByte = null;\n  let soundBuffer = null;\n\n  const getExtraBytes = (data, bytesArraysSizes) => {\n    if (extraByte == null && bytesArraysSizes.incomingMessageVoiceDataLength % 2) {\n      extraByte = data[bytesArraysSizes.incomingMessageVoiceDataLength - 1];\n      bytesArraysSizes.incomingMessageVoiceDataLength -= 1;\n      bytesArraysSizes.sourceLen -= 1;\n    } else if (extraByte != null) {\n      bytesArraysSizes.prepend = extraByte;\n      bytesArraysSizes.start = 1;\n\n      if (bytesArraysSizes.incomingMessageVoiceDataLength % 2) {\n        bytesArraysSizes.incomingMessageVoiceDataLength += 1;\n        extraByte = null;\n      } else {\n        extraByte = data[bytesArraysSizes.incomingMessageVoiceDataLength - 1];\n        bytesArraysSizes.sourceLen -= 1;\n      }\n    }\n  };\n\n  const finishPlayback = () => {\n    soundBuffer = null;\n\n    if (audioContextForPlayback) {\n      audioContextForPlayback.close();\n    }\n\n    audioContextForPlayback = null;\n    audioSlices = [];\n  };\n\n  const setFinish = () => {\n    soundBuffer === null || soundBuffer === void 0 ? void 0 : soundBuffer.finish();\n  };\n\n  const streamToDataToPlayer = data => {\n    let slicePoint = 0;\n\n    if (audioSlices.length === 0) {\n      audioContextForPlayback = new AudioContext();\n      soundBuffer = createSoundBuffer(audioContextForPlayback, 24000, finishPlayback, 1000, ((params === null || params === void 0 ? void 0 : params.startVoiceDelay) || 0) > 0 ? params === null || params === void 0 ? void 0 : params.startVoiceDelay : 0.2);\n      slicePoint = 44;\n    }\n\n    const bytesArraysSizes = {\n      incomingMessageVoiceDataLength: data.length,\n      sourceLen: data.length,\n      start: 0,\n      prepend: null\n    };\n    getExtraBytes(data, bytesArraysSizes);\n    const dataBuffer = new ArrayBuffer(bytesArraysSizes.incomingMessageVoiceDataLength);\n    const bufferUi8 = new Uint8Array(dataBuffer);\n    const bufferI16 = new Int16Array(dataBuffer);\n    bufferUi8.set(data.slice(0, bytesArraysSizes.sourceLen), bytesArraysSizes.start);\n\n    if (bytesArraysSizes.prepend != null) {\n      bufferUi8[0] = bytesArraysSizes.prepend;\n    }\n\n    soundBuffer === null || soundBuffer === void 0 ? void 0 : soundBuffer.write(from16BitToFloat32(bufferI16.slice(slicePoint)));\n    audioSlices.push(bufferUi8);\n  };\n\n  return {\n    setFinish,\n    streamToDataToPlayer\n  };\n};","map":{"version":3,"sources":["/home/zelairy/Рабочий стол/todo-canvas-app/node_modules/@sberdevices/assistant-client/dist/createVoicePlayer.js"],"names":["AudioContext","window","webkitAudioContext","createSoundBuffer","ctx","sampleRate","finishPlayback","bufferSize","delay","chunks","startTime","lastChunkOffset","totalChunksDuration","isPlaying","createChunk","chunk","audioBuffer","createBuffer","length","getChannelData","set","source","createBufferSource","buffer","connect","destination","onended","splice","indexOf","duration","chunkStart","_a","start","doPlay","currentTime","forEach","finish","write","data","push","from16BitToFloat32","incomingData","l","outputData","Float32Array","i","createVoicePlayer","params","audioContextForPlayback","audioSlices","extraByte","soundBuffer","getExtraBytes","bytesArraysSizes","incomingMessageVoiceDataLength","sourceLen","prepend","close","setFinish","streamToDataToPlayer","slicePoint","startVoiceDelay","dataBuffer","ArrayBuffer","bufferUi8","Uint8Array","bufferI16","Int16Array","slice"],"mappings":"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","sourcesContent":["const AudioContext = window.AudioContext || window.webkitAudioContext;\nconst createSoundBuffer = (ctx, sampleRate, finishPlayback, bufferSize = 6, delay = 0) => {\n    const chunks = [];\n    let startTime = 0;\n    let lastChunkOffset = 0;\n    let totalChunksDuration = 0;\n    let isPlaying = false;\n    const createChunk = (chunk) => {\n        const audioBuffer = ctx.createBuffer(1, chunk.length, sampleRate);\n        audioBuffer.getChannelData(0).set(chunk);\n        const source = ctx.createBufferSource();\n        source.buffer = audioBuffer;\n        source.connect(ctx.destination);\n        source.onended = () => {\n            chunks.splice(chunks.indexOf(source), 1);\n            if (chunks.length === 0) {\n                isPlaying = false;\n                startTime = 0;\n                lastChunkOffset = 0;\n                totalChunksDuration = 0;\n                finishPlayback();\n            }\n        };\n        totalChunksDuration += source.buffer.duration;\n        return source;\n    };\n    const chunkStart = (chunk) => {\n        var _a;\n        chunk.start(startTime + lastChunkOffset);\n        lastChunkOffset += ((_a = chunk.buffer) === null || _a === void 0 ? void 0 : _a.duration) || 0;\n    };\n    const doPlay = () => {\n        isPlaying = true;\n        startTime = ctx.currentTime;\n        lastChunkOffset = 0;\n        chunks.forEach((chunk) => chunkStart(chunk));\n    };\n    const finish = () => {\n        if (totalChunksDuration <= delay && !isPlaying) {\n            doPlay();\n        }\n    };\n    const write = (data) => {\n        const chunk = createChunk(data);\n        chunks.push(chunk);\n        if (isPlaying && chunks.length <= bufferSize) {\n            chunkStart(chunk);\n            return;\n        }\n        if (totalChunksDuration > delay)\n            doPlay();\n    };\n    return {\n        finish,\n        write,\n    };\n};\nconst from16BitToFloat32 = (incomingData) => {\n    const l = incomingData.length;\n    const outputData = new Float32Array(l);\n    for (let i = 0; i < l; i += 1) {\n        outputData[i] = incomingData[i] / 32768.0;\n    }\n    return outputData;\n};\nexport const createVoicePlayer = (params) => {\n    let audioContextForPlayback = null;\n    let audioSlices = [];\n    let extraByte = null;\n    let soundBuffer = null;\n    const getExtraBytes = (data, bytesArraysSizes) => {\n        if (extraByte == null && bytesArraysSizes.incomingMessageVoiceDataLength % 2) {\n            extraByte = data[bytesArraysSizes.incomingMessageVoiceDataLength - 1];\n            bytesArraysSizes.incomingMessageVoiceDataLength -= 1;\n            bytesArraysSizes.sourceLen -= 1;\n        }\n        else if (extraByte != null) {\n            bytesArraysSizes.prepend = extraByte;\n            bytesArraysSizes.start = 1;\n            if (bytesArraysSizes.incomingMessageVoiceDataLength % 2) {\n                bytesArraysSizes.incomingMessageVoiceDataLength += 1;\n                extraByte = null;\n            }\n            else {\n                extraByte = data[bytesArraysSizes.incomingMessageVoiceDataLength - 1];\n                bytesArraysSizes.sourceLen -= 1;\n            }\n        }\n    };\n    const finishPlayback = () => {\n        soundBuffer = null;\n        if (audioContextForPlayback) {\n            audioContextForPlayback.close();\n        }\n        audioContextForPlayback = null;\n        audioSlices = [];\n    };\n    const setFinish = () => {\n        soundBuffer === null || soundBuffer === void 0 ? void 0 : soundBuffer.finish();\n    };\n    const streamToDataToPlayer = (data) => {\n        let slicePoint = 0;\n        if (audioSlices.length === 0) {\n            audioContextForPlayback = new AudioContext();\n            soundBuffer = createSoundBuffer(audioContextForPlayback, 24000, finishPlayback, 1000, ((params === null || params === void 0 ? void 0 : params.startVoiceDelay) || 0) > 0 ? params === null || params === void 0 ? void 0 : params.startVoiceDelay : 0.2);\n            slicePoint = 44;\n        }\n        const bytesArraysSizes = {\n            incomingMessageVoiceDataLength: data.length,\n            sourceLen: data.length,\n            start: 0,\n            prepend: null,\n        };\n        getExtraBytes(data, bytesArraysSizes);\n        const dataBuffer = new ArrayBuffer(bytesArraysSizes.incomingMessageVoiceDataLength);\n        const bufferUi8 = new Uint8Array(dataBuffer);\n        const bufferI16 = new Int16Array(dataBuffer);\n        bufferUi8.set(data.slice(0, bytesArraysSizes.sourceLen), bytesArraysSizes.start);\n        if (bytesArraysSizes.prepend != null) {\n            bufferUi8[0] = bytesArraysSizes.prepend;\n        }\n        soundBuffer === null || soundBuffer === void 0 ? void 0 : soundBuffer.write(from16BitToFloat32(bufferI16.slice(slicePoint)));\n        audioSlices.push(bufferUi8);\n    };\n    return {\n        setFinish,\n        streamToDataToPlayer,\n    };\n};\n"]},"metadata":{},"sourceType":"module"}